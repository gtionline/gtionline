{"complementExample": "Додатковий розрахунок", "shiftZero": "Нульова мантиса після зсуву", "doubleNegative": "Негатив", "denormalized": "Денормалізація", "fpExerciseIntro": "Потренуйтеся в арифметиці з плаваючою комою за стандартом IEEE-754, використовуючи автоматично згенеровані завдання.", "fpFormatSelectionSimple": "Виберіть кількість розрядів для експоненти та мантиси.", "fpFormatSelection": "Визначте розрядність числа з плаваючою комою, а потім виберіть кількість розрядів для експоненти та мантиси.", "fpArithIntro": "Практикувати арифметику з плаваючою комою відповідно до стандарту IEEE-754 або самостійно визначеного формату на його основі.", "fpConvIntro": "За допомогою згенерованих вправ відпрацювати перетворення між десятковою системою числення та форматом чисел з плаваючою комою за стандартом IEEE-754 або самостійно визначеним форматом на його основі.", "sequentialCircuit": "Приклад комутаційного механізму, що складається з двох D-тригерів і декількох мультиплексорів.", "polyadicDivisionDescription": "Цифри перед десятковою крапкою утворюються з цифр остачі шляхом їх читання знизу вгору.", "polyadicMultiplicationDescription": "Десяткові знаки виходять з цифр залишку, якщо читати їх зверху вниз.", "homePageText": "На цьому сайті ви можете поглибити свої знання з окремих тем лекції \"Основи комп'ютерної інженерії\" (GTI) та пов'язаних з нею вправ.", "startTraining": "Ходімо.", "polyFreeIntro": "Практикуйте поліадичну арифметику з власними числовими значеннями в бажаній системі.", "polyConvGenIntro": "Відпрацювати конвертацію між поліадичними системами на згенерованих вправах.", "polyConvIntro": "Практикуйте конвертацію між поліадичними системами, які ви можете вільно обирати.", "numVarInput": "Кількість змінних", "conversionExercise": "Завдання конверсії", "impressum": "Impressum", "copyright": "Кафедра комп'ютерних наук 12, ФАУ. Всі права захищені.", "herausgeber": "Видавець", "disclaimerFooter": "Ми не надаємо жодних гарантій щодо точності матеріалів, розміщених на цьому веб-сайті.", "representedByHeader": "В особі", "contactPersonHeader": "Контакти", "representedBy": "Кафедра комп'ютерних наук 12 є установою публічного права у складі Університету Фрідріха-Александра в Ерланген-Нюрнберзі (FAU). Відповідно до статей 20 та 21 BayHSchG, ФАУ, як державну установу та самоврядний орган публічного права, зовні представляє Президент.", "haftungsauschlussHeader": "Відмова від відповідальності", "haftungsauschlussBody": "Відповідальність за зміст інших веб-сайтів несуть відповідні установи. Вся інформація, надана на цьому веб-сайті, була зібрана і перевірена, наскільки нам відомо і наскільки ми вважаємо за потрібне. Однак ми не можемо гарантувати, що надана інформація є актуальною, правильною, повною або доступною в будь-який час. Договірні відносини з користувачами інтернет-оферти не виникають. Ми не несемо відповідальності за будь-яку шкоду, спричинену використанням цього веб-сайту. Це виключення відповідальності не застосовується в частині, що стосується положень §839 Цивільного кодексу Німеччини (відповідальність за порушення службових обов'язків). Ми не несемо відповідальності за будь-які збитки, спричинені шкідливим програмним забезпеченням або встановленням чи використанням програмного забезпечення під час виклику чи завантаження даних. Як постачальник послуг, ми несемо відповідальність за власний контент на цих сторінках відповідно до § 7 абз. 1 TMG (Закон про телемедіа Німеччини) згідно із загальним законодавством. Однак, відповідно до §§ 8-10 TMG, ми не зобов'язані як постачальник послуг здійснювати моніторинг переданої або збереженої інформації третіх осіб або розслідувати обставини, що вказують на незаконну діяльність. Зобов'язання видаляти або блокувати використання інформації відповідно до загальних законів залишаються незмінними. Однак, відповідальність у цьому відношенні можлива лише з моменту, коли стало відомо про конкретне порушення. Якщо нам стане відомо про відповідні порушення законодавства, ми негайно видалимо цей контент. Оператор прямо залишає за собою право змінювати, доповнювати або видаляти окремі веб-сторінки, веб-сервіси або всю пропозицію без окремого повідомлення, а також тимчасово або постійно припиняти публікацію.", "confirm": "Підтвердити", "varNaming": "Іменування змінних", "kvDiagram": "Схема КТ", "numeralSystem": "Системи числення", "polyadic": "Поліадичний", "floatingPoint": "Числа з плаваючою комою", "functionMin": "Мінімізація функцій", "exercises": "Навчання", "generateEx": "Сформувати завдання", "generate": "Згенерувати", "addition": "Доповнення", "subtraction": "Віднімання", "multiplication": "Множення", "division": "Підрозділ", "ownSolution": "Власне рішення", "signBit": "Знаковий біт", "correctSolution": "спосіб вирішення", "solution": "Рішення", "exponentBits": "Показник", "fractionBits": "Mantisse", "attRound": "Не забувайте про патрони!", "attSolve": "Будь ласка, спробуйте розв'язати завдання самостійно заздалегідь!", "step": "Крок", "freeCalculation": "Безкоштовний розрахунок", "operationSelect": "Вибір операції", "firstFloatingPoint": "Перше число з плаваючою комою", "secondFloatingPoint": "Друге число з плаваючою комою", "operand": "Операнд", "decimal": "Десяткове число", "binary": "Двійкове число", "inputNumber": "Введіть номер", "fpformat": "Формат з плаваючою комою", "check": "Перевірте.", "values": "Цінності", "load": "Магазин", "arithmetic": "Арифметика", "conversion": "Конверсія", "conversionExercise1": "Навернись: ", "conversionExercise2": "в IEEE число з плаваючою комою експоненціальної довжини ", "steps": "Кроки", "repeatMinuend": "Повторити мінусовку", "doDivision": "Виконавчий відділ", "doMultiplication": "Виконати множення", "getDescription": "Друк", "approach": "спосіб вирішення", "gti": "Основи комп'ютерної інженерії", "disclaimer": "Відмова від відповідальності<br>: Це автоматично згенерований шлях до рішення через веб-сайт GTI Online. Ми не можемо гарантувати правильність, тому запропоноване рішення є <u>неофіційним</u>.<br>Ми докладаємо багато зусиль, щоб розробити для вас надійний і правильний інструмент. Тим не менш, шлях вирішення або саме рішення може містити помилки. Це також може бути пов'язано з певними версіями браузерів. Будь ласка, перевірте рішення, перш ніж використовувати його, наприклад, на іспиті.</br></br>", "example": "Приклад", "composition": "Склад", "negativeSummand": "Додавання з від'ємним значенням розглядається як віднімання.", "negativeSubtrahend": "Від'ємний підчлен має такий самий ефект, як і додатний доданок.", "negativeMinuendSubtrahend": "Спрощення для випадку \\( - x - y \\rightarrow - (x + y) \\)", "addWithZero": "При додаванні з 0 інший доданок не змінюється.", "subWithZero": "Віднімання з 0 не змінює зменшуваного", "divWithZero": "Якщо є ділення з 0 в чисельнику, то результат дорівнює 0.", "mulWithZero": "При множенні на 0 результат завжди дорівнює 0.", "zeroDivision": "Ділення на 0 неможливе!", "arithmeticFree": "Вільна арифметика", "conversionFree": "Безкоштовна конвертація", "value": "Значення", "givenValues": "Значення переданих номерів", "leftValue": "Кількість зліва", "rightValue": "Номер праворуч", "firstSummand": "1. Доданок", "secondSummand": "2. Доданок", "firstFactor": "Фактор 1", "secondFactor": "Фактор 2", "numerator": "Лічильник", "denominator": "Знаменник", "minuend": "Minuend", "subtrahend": "Subtrahend", "sign": "Знак", "exponent": "Показник", "adjustExponents": "Показники обох чисел мають бути скориговані.", "addExponents": "Експоненти обох чисел необхідно скласти разом.", "subtExponents": "Показники степенів обох чисел необхідно відняти.", "diffExponent": "Експонента різниці", "smallerExponent": "Менший показник завжди віднімається від більшого показника.", "resDiffExponent": "Тому різниця полягає в тому, що", "newExponentDivision": "Нова експонента визначається як \\( E_{'{new}'} = E_1 - E_2 + BIAS = {E1} - {E2} + {Bias} = {Result} \\)", "newExponentMultiplication": "Нова експонента задається як \\( E_{'{new}'} = E_1 + E_2 - BIAS = {E1} + {E2} - {Bias} = {Result}\\, ({ExpBits})\\)", "considerExponent": "Експонента примітки", "fpExerciseText": "Нехай числа з плаваючою комою \\( fp_1 \\) та \\( fp_2 \\) задано у 16-бітному форматі з плаваючою комою. Обчислити {op1} \\( fp_1 {op2} fp_2 \\), не виходячи з двійкового представлення, і знову видати результат у вигляді числа з плаваючою комою:", "mantissa": "Mantisse", "solutionIsNan": "Мантису не потрібно обчислювати, оскільки результат, безумовно, є NaN.", "solutionIsInf": "Мантису не потрібно обчислювати, тому що результат, безумовно, нескінченний.", "solutionIsZero": "Мантису обчислювати не потрібно, оскільки результат, безумовно, дорівнює 0.", "mulMantissa": "Мантиси обох чисел необхідно перемножити.", "addMantissa": "Мантиси обох чисел потрібно скласти разом.", "divMantissa": "Богомолів обох чисел необхідно розділити.", "newMantissa": "Нова мантиса", "zeroMantissa": "Мантиси однакові \\( \\rightarrow \\) new mantissa is 0-mantissa", "newMantissaIs": "Отже, ми підрахували", "newMantissaSignBit": "Через доповнення ми обчислюємо зі знаковим розрядом:", "equalMantissa": "Мантиси однакові, експонента \\( \\rightarrow \\) збільшується на 1, мантиса залишається незмінною", "equalMantissaDiv": "Дві богомолки рівні, тому двійкове ділення не виконується. Мантиса дорівнює {Мантиса}.", "adjustSmallerMantissa": "Налаштування мантиси", "shiftMantissa": "Зсув мантиси", "mantissaFloat": "Мантиса в поплавку", "mantissaNormalize": "Для того, щоб мантиса починалася з ведучої 1, потрібно нормалізувати мантису, застосувавши зсув {shift}. Ми також повинні застосувати цей зсув до експоненти, в результаті чого отримаємо нову експоненту {exponent}.", "mantissaNormalizeDenorm": "Результат не може бути представлений в нормалізованому представленні зі зсувом {shift}, тому використовується денормалізоване представлення з експонентою {exponent}.", "mantissaDenormalize": "Оскільки після застосування зсуву ми отримуємо від'ємну експоненту, ми повинні використовувати денормалізоване представлення для відображення результату. Для цього ми встановлюємо експоненту повністю в 0 і зсуваємо наші мантиси, в тому числі і ведучу, на величину експоненти. За мантису приймається ведучий нуль.", "mantissa1float": "Нарешті, ми видаляємо старший розряд мантиси, щоб отримати біти мантиси представлення IEEE-754. Отже, біти мантиси є такими:", "mantissaComplement": "Мантиса від'ємна. Отже, ми маємо сформувати доповнення і встановити знаковий біт.", "subtTwosComplement": "Віднімання відповідає додаванню з доповненням двійки", "mantissaTwosComplement": "Утворення доповнення двійки з мантиси", "switchBits": "Інвертні біти", "add1": "1 addieren", "normalize": "Нормалізувати", "shiftExpMant": "До мантис необхідно застосовувати коефіцієнт зсуву експоненти.", "shift": "Зміна", "considerRepresentation": "Представлення векселів", "consider1comma": "Мантиса завжди починається з 1 перед десятковою крапкою в стандартному поданні (і з 0, якщо денормалізовано).", "ternary": "Тернарне число", "quaternary": "Четвертинне число", "quinary": "Кількість центнерів", "senary": "Шестизначне число", "septenary": "Гептальна система", "octal": "Вісімкове число", "novenary": "Нецифрове число", "hexadecimal": "Шістнадцяткове число", "hex": "Шістнадцяткова система числення", "input": "Вхідні дані", "number": "Кількість", "representation": "Відтворення вихідного формату", "firstFormat": "Вихідний формат", "secondFormat": "Цільовий формат", "doConversion": "Виконати конвертацію:", "modus": "Модус", "to": "до", "TenToPower": "При переведенні з десяткової системи числення в іншу поліадичну систему алгоритм ділення застосовується до десяткової крапки, а алгоритм множення - після десяткової крапки.", "PowerToTen": "Переведення будь-якої системи числення в десяткову здійснюється шляхом підсумовування піднесених до степеня цифр.", "PowerToPower": "Переведення числа однієї системи числення в іншу систему числення відбувається у два етапи. Спочатку число вихідної системи переводиться в десяткову систему шляхом додавання. Потім це десяткове число переводиться в цільову систему шляхом послідовного ділення цифр до коми та послідовного множення цифр після коми.", "noValuesBeforeComma": "Без значень до десяткової крапки. Алгоритм ділення можна опустити", "noValuesAfterComma": "Значення після десяткової крапки відсутні. Алгоритм множення можна опустити", "firstToTen": "1. підсумовування піднесених до степеня цифр", "secondToPower": "2. перетворення за допомогою алгоритму ділення та множення", "shortcutBinToHex": "При перетворенні з двійкової системи числення в шістнадцяткову, значення можна зчитувати безпосередньо.", "shortcutHexToBin": "При перетворенні з шістнадцяткової системи числення в двійкову, значення можна зчитувати безпосередньо.", "divisionAlgorithm": "Ціла частина (алгоритм ділення)", "multiplicationAlgorithm": "Десяткові знаки (алгоритм множення)", "summation": "Підсумувати", "factor": "Фактор", "quotient": "Коефіцієнт", "remainder": "Відпочинок", "newBasis": "Base_{'{new}'}", "calcStep": "Крок розрахунку", "summands": "Доданки", "polyadicExercise1": "Перетворіть", "polyadicExercise3": "в ", "exerciseArchive": "Архів завдань", "randomExercise": "Випадкове завдання", "doCalculation": "Розрахувати", "colorCoding": "Кольорове кодування", "mathDistribution": "Distribriierung", "easy": "просто", "difficultyMiddle": "середній", "difficultyHard": "важкий", "sheet": "аркуш", "goal": "мета", "difficultyUC": "труднощі", "bf_infotext_or_interact_with_kv": "Або взаємодіяти безпосередньо з діаграмою КВ", "bf_infotext_kv_must_not_be_empty": "Діаграма КВ повинна містити одиниці та нулі", "bf_infotest_click_on_hidden_areas_to_make_visible": "Натисніть на приховані області, щоб показати їх", "bf_normal_forms": "Звичайні_форми", "bf_disjunctiveNormalForm": "Диз'юнктивна нормальна форма", "bf_conjunctiveNormalForm": "Сполучникова нормальна форма", "bf_disjunctiveMinimalForm": "Диз'юнктивна мінімальна форма", "bf_conjunctiveMinimalForm": "Сполучникова мінімальна форма", "bf_quineMCCluskeyClasses": "Класи Quine McCluskey", "bf_primeTerms": "Примтерм", "bf_primeImplicants": "прості імпліканти", "bf_primeImplicates": "основні причетні", "bf_primeCoverTable": "титульна таблиця", "bf_petrickExpression": "Вираз Петрика", "bf_minimalForms": "Мінімальні форми", "bf_tableWithCyclicRest": "Циклічна таблиця залишків", "bf_einstelle": "Один", "bf_nullstelle": "Нуль", "bf_einstellen": "Одні", "bf_nullstellen": "Нулі", "bf_goal_determine_DNF": "Визначити DNF", "bf_goal_determine_KNF": "Визначити КNF", "bf_goal_determine_prime_implicants": "Визначити прості імпліканти", "bf_goal_determine_prime_implicates": "Визначити первинні імплікати", "bf_covertable_step_description_initial": "<h4>Початковий крок:</h4>Введіть всі базисні члени ({ifMinTermsSetElseNull}) у стовпці та всі прості члени (PI) у рядки таблиці. Якщо простий член покриває {ifMinTermsEinstelleElseNullstelle}, позначте цю клітинку X. Вартість c є сумою всіх базисних членів ({ifMinTermsEinstellenElseNullstelle}). Вартість c простого терма дорівнює кількості його літералів. Чим більша цифра, тим дорожче її реалізувати апаратно. <br>Підказка: Первісний терм<br>покриває цифру ON саме тоді, коли всі літерали первинного терма зустрічаються так само в базовому тер</br>мі.</br>", "bf_covertable_step_description_core_found": "<h4>Знайдено ядро:</h4>Єдиний простий член, який покриває {ifMinTermsElseNull} {columnName} - це термін {rowName}. Тому цей первісний член обов'язково має бути в нашій комутаційній функції! Позначте рядок як основний і закресліть стовпчик.", "bf_covertable_step_description_cross_column_bc_covered": "<h4>Стовпець, що вже охоплений:</h4>{ifMinTermsSetElseNullSets} {columnName} вже охоплений головним членом {rowName}. Викреслити стовпчик.", "bf_covertable_step_description_cross_row_bc_covered": "<h4>Рядок вже повністю покритий:</h4>Всі X рядка {ім'я_рядка} вже покриті. Перекресліть рядок.", "bf_covertable_step_description_row_domination": "Домінування лінії<h4>:</h4>Лінія {ім'я домінанта} домінує над лінією {ім'я домінанти}, тобто {ім'я домінанта} має маркери скрізь, де лінія {ім'я домінанти} також має маркери (і, можливо, навіть більше). =&gt; Видалити домінуючий рядок {dominatedName}. <br>Зауважте, що домінування рядка застосовується лише тому, що рядок {ім'я домінуючого учасника} коштує менше або стільки ж, скільки {ім'я домінуючого учасника}; або тому, що не існує іншого рядка, який покриває додаткові цифри {ім'я домінуючого учасника} і коштує менше, ніж {ім'я домінуючого учасника} - {ім'я домінуючого учасника}.</br>", "bf_covertable_step_description_column_domination": "Домінування стовпців<h4>:</h4>Стовпець {ім'я домінанта} домінує над стовпцем {ім'я домінанти}, тобто {ім'я домінанта} має маркери скрізь, де стовпець {ім'я домінанти} також має маркери (і, можливо, навіть більше). =&gt; Видалити домінуючий стовпець {dominatorName}На<br>відміну від</br>домінування<br>рядків, домінування стовпців взагалі не потребує врахування витрат (/â-½ï¼¼</br>).", "bf_covertable_step_description_cyclic_rest": "<h4>Циклічний залишок:</h4>правило таблиці перекриття не застосовується. Це називається \"циклічним залишком\".<br>Для того, щоб мати можливість визначити мінімальну форму перемикальної функції, можна перерахувати вираз Петрика, при цьому вписуються тільки ті рядки і стовпці, які ще не були викреслені.</br>", "bf_infoblob_random_exercise_selection": "Обрана складність визначає, скільки термів одного виду (наприклад, мінтермів, простих імплікант) повинна містити перемикальна функція.", "bf_infoblob_petrick_statement": "Алгоритм складається з двох етапів:<ol><li>Переставити терміни так, щоб якомога більше було засвоєно.</li><li>Перемножте терміни.</li></ol>", "bf_distributionUC": "Дистрибуція", "bf_idempotenceUC": "Idempotenz", "bf_absorptionUC": "Поглинання", "bf_sortingUC": "Сортування", "bf_infoblob_functionMin": "Практикуйте різні процедури мінімізації функцій", "bf_disjunctiveNormalForm_explanation": "Диз'юнктивна нормальна форма - це диз'юнкція (veroderung) всіх мінтермів (1s) функції. Кожному мінтерму відповідає рівно одна 1 у функції, всі літерали в ній повинні бути заперечуваними або не заперечуваними.", "bf_conjunctiveNormalForm_explanation": "Кон'юнктивна нормальна форма - це кон'юнкція всіх членів (0) функції. Нулі не вибираються в макстернах (як одиниці в мінтермах), а виключаються. Кожному maxterm відповідає рівно один 0 у функції, всі літерали в ній повинні бути заперечуваними або не заперечуваними.", "bf_quineMCCluskeyClasses_explanation": "Метод Квайна/Мак-Класкі - це метод мінімізації, за допомогою якого можна визначити прості члени функції.", "bf_infoblob_quineMCCluskeyClasses_colorCoding": "Скорочені строки, як правило, позначаються закресленням у процедурі Куайна/МакКласкі. При активному кольоровому кодуванні вони забарвлюються у світло-сірий колір. ", "bf_infoblob_quineMCCluskeyClasses_01": "Зазвичай ми пишемо мінімальні або максимальні терміни в окремих класах. Крім того, ми також можемо працювати з 0 (для заперечних літералів) і 1 (для незаперечних літералів), причому позиція цих символів визначає, який це літерал.", "bf_primeTerms_explanation": "Терміни з мінімальною кількістю літер, що охоплюють тільки одиниці або нулі. ", "bf_bf_primeImplicants_explanation": "Приімплікації - це приставки, які охоплюють лише ОДНУ позицію (з обрізанням). ", "bf_primeImplicates_explanation": "Прості імплікати - це прості члени, які охоплюють тільки нулі (з вакантними місцями). ", "bf_disjunctiveMinimalForm_explanation": "Диз'юнкція літералів, з'єднаних сполучником. Це не може бути спрощено далі (без порушення цієї форми) (спрощений ФНП).", "bf_conjunctiveMinimalForm_explanation": "Об'єднання літералів, з'єднаних диз'юнкцією. Це не може бути спрощено далі (без порушення цієї форми) (спрощена КНФ).", "cmos_infoblob_description": "КМОП являє собою композицію взаємодоповнюючих NMOS-мереж перемикання (pull-down мережа, оскільки підключена до землі) і PMOS-мережі перемикання (pull-up мережа, оскільки підключена до напруги живлення). Як наслідок, у фіксованому стані перемикання споживається менше енергії, оскільки PDN і PUN доповнюють один одного і, таким чином, працюють одночасно лише протягом короткого часу під час перемикання. Однак, на мікросхемі потрібно більше площі.", "cmos_infoblob_input_description": "Примітка: Для воріт АБО можна використовувати \"+\", для воріт І - \"*\", а для заперечення - \"~\". Змінні можуть мати довільні імена (увага: вхідні дані \"ab\" інтерпретуються як змінна, а не як з'єднання \"a\" і \"b\").", "enter_cmos": "Будь ласка, введіть свій CMOS запис.", "polyadicExercise2": "від початкового формату:", "newExponent": "Новий експонента", "systemInBase": "Система до основи", "basis": "База", "minterms": "Minterme", "maxterms": "Maxterme", "contact": "Контакти", "impressumText": "Відбиток ви знайдете під ним: ", "and": " і", "weThank": "Ми хотіли б подякувати наступним людям за допомогу у створенні цього веб-сайту:", "Danksagung": "Подяка", "thankProfessorTeich": "Матеріали на цій сторінці базуються на лекції GTI професора д-ра інж. Юргена Тайча з Університету Фрідріха-Александра (FAU). Ми дякуємо йому за експертизу та меценатство.", "wintersemester": "Зимовий семестр", "sommersemester": "Літній семестр", "downloadSvg": "Експорт SVG", "downloadPng": "Експорт Папуа-Нової Гвінеї", "formula": "Формула", "divByZero": "Ділення на 0 дає NaN.", "falseFormat": "Неправильний формат"}