{
  "complementExample": "Complement",
  "shiftZero": "Zero after shift",
  "doubleNegative": "Negative",
  "denormalized": "Denormalization",
  "fpExerciseIntro": "Practice arithmetic between floating point numbers in IEEE-754 format using generated exercises",
  "fpFormatSelectionSimple": "To select a custom format, specify the distribution of bits between exponents and mantissa.",
  "fpFormatSelection": "To select a custom format, first select the number of bits of the floating point number, and then specify the distribution of bits between exponents and mantissa.",
  "fpArithIntro": "Practice arithmetic between floating point numbers in the format according to IEEE-754 or a self-defined format based on it.",
  "fpConvIntro": "Practice conversion between the decimal system and floating-point number format according to IEEE-754 or a self-defined format based on it, using generated practice problems.",
  "polyConvIntro": "Practice conversion between positional numeral systems that you can freely choose.",
  "polyConvGenIntro": "Practice the conversion between positional numeral systems by solving generated exercises.",
  "polyadicMultiplicationDescription": "The digits after the decimal point are obtained from the digits of the remainder by reading them from top to bottom.",
  "polyadicDivisionDescription": "The digits before the decimal point result from the digits of the remainder by reading them from bottom to top.",
  "enter_cmos": "Please enter your CMOS formula.",
  "sequentialCircuit": "Example of a sequential circuit comprising two D-flip-flops and multiplexers.",
  "homePageText": "The goal of GTI-Online is to deepen the knowledge of selected topics learned in the lecture and corresponding exercise. Select in the menu a topic and start practicing.",
  "startTraining": "Let's go",
  "numVarInput": "Number of variables",
  "fpExerciseText": "Let \\( fp_1 \\) and \\( fp_2 \\) be given as floating point numbers in 16 bit floating point format. Compute the %{op1} \\( fp_1 %{op2} fp_2 \\) without leaving the binary representation and specify it again as a floating point number:",
  "confirm": "Confirm",
  "varNaming": "Variable naming",
  "kvDiagram": "Karnaugh Map",
  "truthtable": "Function Table",
  "numeralSystem": "Numeral System",
  "polyadic": "Positional numeral system",
  "floatingPoint": "Floating Points",
  "functionMin": "Minimization",
  "exercises": "Exercises",
  "generateEx": "Generate Exercise",
  "generate": "Generate",
  "polyFreeIntro": "Practice positional numeral arithmetic with your own numerical values in your desired system.",
  "addition": "Addition",
  "subtraction": "Subtraction",
  "multiplication": "Multiplication",
  "division": "Division",
  "solution": "Solution",
  "ownSolution": "Own Solution",
  "signBit": "Sign Bit",
  "load": "Load",
  "correctSolution": "Solution",
  "exponentBits": "Exponent",
  "fractionBits": "Fraction",
  "attRound": "Do not forget to round!",
  "attSolve": "Please try to solve the exercise beforehand!",
  "step": "Step",
  "freeCalculation": "Free Calculation",
  "operationSelect": "Configure Computation",
  "firstFloatingPoint": "First Floating Point Number",
  "secondFloatingPoint": "Second Floating Point Number",
  "operand": "Operand",
  "decimal": "Decimal",
  "binary": "Binary",
  "inputNumber": "Input Number",
  "fpformat": "Floating Point Format",
  "check": "Check",
  "values": "Values",
  "arithmetic": "Arithmetic",
  "conversion": "Conversion",
  "conversionExercise": "Exercises for conversion",
  "conversionExercise1": "Convert: ",
  "conversionExercise2": "into a IEEE floating point number with exponent length of ",
  "steps": "steps",
  "repeatMinuend": "repeat\\ minuend",
  "doDivision": "execute division",
  "doMultiplication": "execute multiplication",
  "getDescription": "Print",
  "approach": "Approach",
  "gti": "Foundations of Computer Engineering",
  "disclaimer": "Disclaimer:<br>This is an automatically generated solution approach by the GTI-Online-Website. Every output is completely <u>unofficial</u> and in the drafts state.<br>We are making lots of efforts to build a correct and reliable tool for you. Regardless, there may be failures in the solution or approach. That can especially depend on your browser version. Please review before using it for instance in an exam.",
  "example": "Example",
  "composition": "composition",
  "negativeSummand": "An addition with a negative value is similar to a subtraction.",
  "negativeSubtrahend": "A negative subtrahend is similar to a positive summand.",
  "negativeMinuendSubtrahend": "Simplification for the case \\( - x - y \\rightarrow - (x + y) \\)",
  "addWithZero": "An addition with 0 results in the other summand",
  "subWithZero": "A subtraction with 0 results in the other value",
  "mulWithZero": "A multiplication with 0 results always 0.",
  "zeroDivision": "A division by 0 is illegal!",
  "arithmeticFree": "Free arithmetic",
  "conversionFree": "Free conversion",
  "value": "Value",
  "givenValues": "Values of the transmitted numbers",
  "leftValue": "Left value",
  "rightValue": "Right value",
  "firstSummand": "1. summand",
  "secondSummand": "2. summand",
  "firstFactor": "1. factor",
  "secondFactor": "2. factor",
  "minuend": "Minuend",
  "subtrahend": "Subtrahend",
  "numerator": "Numerator",
  "denominator": "Denominator",
  "sign": "Sign",
  "exponent": "Exponent",
  "adjustExponents": "The exponents of both numbers must be balanced.",
  "addExponents": "The exponents of both numbers must be added.",
  "subtExponents": "The exponents of both numbers must be subtracted.",
  "diffExponent": "Difference of the exponents",
  "smallerExponent": "The smaller exponent will be subtracted from the bigger one.",
  "resDiffExponent": "Hence, this difference is",
  "newExponent": "New exponent",
  "considerExponent": "Consider the exponent",
  "mantissa": "Mantissa",
  "mulMantissa": "The mantissa of both numbers must be multiplied.",
  "solutionIsNan": "The mantissa can not be calculated because the input leads to NaN.",
  "solutionIsInf": "The mantissa can not be calculated because the input leads to infinity.",
  "solutionIsZero": "The mantissa can not be calculated because the input leads to zero.",
  "addMantissa": "The mantissa of both numbers must be added.",
  "divMantissa": "The mantissa of both numbers must be divided.",
  "newMantissa": "New mantissa",
  "zeroMantissa": "both mantissa are equal \\( \\rightarrow \\) the new mantissa is the 0-mantissa",
  "newMantissaIs": "Hence the new mantissa is",
  "equalMantissa": "Both mantissa are equal \\( \\rightarrow \\) the exponent will be incremented the mantissa remains",
  "equalMantissaDiv": "Both mantissa are equal, no binary division will be executed",
  "adjustSmallerMantissa": "Adjust the mantissa",
  "shiftMantissa": "Shift the mantissa",
  "mantissaFloat": "Mantissa inside the float",
  "mantissa1float": "The leading digit is not part of the float",
  "subtTwosComplement": "Subtraction is similar to addition with the two's complement",
  "mantissaTwosComplement": "Formation of the two's complement out of the mantissa",
  "switchBits": "Invert bits",
  "add1": "Add 1",
  "normalize": "Normalize",
  "shiftExpMant": "The exponent's shift factor must be applied to the mantissa.",
  "shift": "Shift",
  "considerRepresentation": "Consider the representation",
  "consider1comma": "The mantissa begins with an 1 in the standard form (and 0 in denormalized form).",
  "ternary": "Ternary system",
  "quaternary": "Quaternary system",
  "quinary": "Quinary system",
  "senary": "Senary system",
  "septenary": "Septenary system",
  "octal": "Octal system",
  "novenary": "Nonal system",
  "hexadecimal": "Hexadecimal system",
  "hex": "Hexadecimal",
  "input": "Input",
  "number": "Number",
  "representation": "representation in original format",
  "firstFormat": "Initial format",
  "secondFormat": "Target format",
  "doConversion": "Convert:",
  "modus": "Mode",
  "to": "to",
  "fp_from_archive": "From the Archive",
  "TenToPower": "The conversion from the decimal system to an arbitrary one goes in two steps. Before the comma, the digits were converted with the use of the division algorithm. After the comma, the multiplication algorithm will be applied.",
  "PowerToTen": "An arbitrary number system can be converted to the decimal system by summarizing all potentiated digits.",
  "PowerToPower": "We convert an arbitrary number system into another within two steps via the decimal system. At first, the original number will be transferred into the decimal system be summarizing the potentiated digits. In the second step, we use the division- and multiplication algorithm to create the resulting number.",
  "noValuesBeforeComma": "There are no values in front of the comma. Therefore, the division algorithm can be skipped.",
  "noValuesAfterComma": "There are no values after the comma. Therefore, the multiplication algorithm can be skipped.",
  "firstToTen": "1. Summation of the potentiated digits",
  "secondToPower": "2. Conversion via division- and multiplication algorithm",
  "shortcutBinToHex": "At the conversion from binary to hexadecimal, the values can be read directly.",
  "shortcutHexToBin": "At the conversion from hexadecimal to binary, the values can be read directly.",
  "divisionAlgorithm": "Division algorithm",
  "multiplicationAlgorithm": "Multiplication algorithm",
  "summation": "Summation",
  "factor": "Factor",
  "quotient": "Quotient",
  "remainder": "Remainder",
  "newBasis": "Base_{'{new}'}",
  "calcStep": "calculation\\ step",
  "summands": "Summands",
  "newMantissaSignBit": "Because of the complement, we calculate with a sign bit:",
  "disclaimerFooter": "No warranty is given for the correctness of the materials provided on this website.",
  "polyadicExercise1": "Convert the value in the",
  "polyadicExercise2": "from the initial format",
  "polyadicExercise3": "to the target format",
  "archive": "archive",
  "exerciseArchive": "Exercise Archive",
  "randomExercise": "Random Exercise",
  "doCalculation": "Calculate",
  "colorCoding": "Color coding",
  "mathDistribution": "Distribution",
  "easy": "Easy",
  "difficultyMiddle": "Middle",
  "difficultyHard": "Hard",
  "sheet": "Sheet",
  "goal": "Goal",
  "difficultyUC": "Difficulty",
  "bf_infotext_or_interact_with_kv": "Or directly interact with the KV-Diagram",
  "bf_infotext_kv_must_not_be_empty": "The function must contain 1s and 0s.<br>With only 1s or only 0s, the optimized function will be either the function that always outputs a 1, or always outputs a 0, nevertheless the input.<br>Thus there would not remain much optimization for us to do.",
  "bf_infotest_click_on_hidden_areas_to_make_visible": "Click on hidden areas to reveal them",
  "bf_infotext_what_to_do": "Load an exercise or specify a boolean function using the KV-Diagram or Function Table. Then press 'Calculate' to begin.",
  "bf_normal_forms": "Normal Forms",
  "bf_disjunctiveNormalForm": "Disjunctive normal form",
  "bf_conjunctiveNormalForm": "Conjunctive normal form",
  "bf_disjunctiveMinimalForm": "Disjunctive minimal form",
  "bf_conjunctiveMinimalForm": "Conjunctive minimal form",
  "bf_quineMCCluskeyClasses": "Quine MC Cluskey classes",
  "bf_primeTerms": "Implicants (prime terms)",
  "bf_primeImplicants": "Prime implicants",
  "bf_primeImplicates": "Prime implicates",
  "bf_primeCoverTable": "Prime implicant chart / 'Cover Table'",
  "bf_petrickExpression": "Petrick's method",
  "bf_minimalForms": "Minimal Forms",
  "bf_tableWithCyclicRest": "Table with cyclic rest",
  "bf_einstelle": "One",
  "bf_nullstelle": "Zero",
  "bf_einstellen": "Ones",
  "bf_nullstellen": "Zeros",
  "bf_goal_determine_DNF": "Determine DNF",
  "bf_goal_determine_KNF": "Determine KNF",
  "bf_goal_determine_prime_implicants": "Determine prime implicants",
  "bf_goal_determine_prime_implicates": "Determine prime implicates",
  "bf_covertable_step_description_initial": "<h4>Initial step:</h4>Enter all base terms in the columns and all implicants (PI) in the rows of the table. If a implicant covers a {ifMinTermsEinstelleElseNullstelle}, mark that cell with an X. The cost c of an implicant is the number of its literals. The higher, the more complex (i.e. costly) the implementation in hardware.<br>Tip:<br>A prime implicant covers a 'ONE' exactly if all literals of the implicant also occur in the same way in the base term.",
  "bf_covertable_step_description_core_found": "<h4>Core found:</h4>The only implicant that covers column {columnName} is term {rowName}. Hence this implicant must definitely appear in our resulting function! Mark the row as a 'core' (Kern) and strike out the column.",
  "bf_covertable_step_description_cross_column_bc_covered": "<h4>Column already covered:</h4> Column {columnName} is already being covered by implicant {rowName}. Strike out the column.",
  "bf_covertable_step_description_cross_row_bc_covered": "<h4>Row already covered:</h4>All X's of row {rowName} are already covered. Cross out the row.",
  "bf_covertable_step_description_row_domination": "<h4>Row dominance:</h4>Row {dominatorName} dominates row {dominatedName}; i.e. row {dominatorName} has markers wherever row {dominatedName} does as well (and possibly more!). => cross the dominaTED row {dominatedName}. <br>Note that row dominance is only applicable, because row {dominatorName} costs less than, or the same as {dominatedName}; or because there is no other row that covers the additional markers of {dominatorName} and costs less than {dominatorName} - {dominatedName}.",
  "bf_covertable_step_description_column_domination": "<h4>Column dominance:</h4>Column {dominatorName} dominates column {dominatedName}; i.e. column {dominatorName} has markers wherever column {dominatedName} does as well (and possibly more!). => Cross the dominaTING column {dominatorName}<br>Unlike with row dominance, column dominance doesn't require you to consider costs at all.",
  "bf_covertable_step_description_cyclic_rest": "<h4>Cyclic rest:</h4>No rule of the prime table algorithm is applicable. This is referred to as a 'cyclic rest' (ger: 'Zyklischer Rest').<br>By setting up the Petrick's expression (ger: Petrick Ausdruck) for the rest table, one is still able to determine a minimal form of the original function.",
  "bf_infoblob_random_exercise_selection": "Difficulty states how many individual terms of some kind (e.g. minterms, prime implicants) the boolean function should yield.",
  "bf_infoblob_petrick_statement": "The algorithm consists of two phases:<ol><li>Make terms that absorb each other easily visible through sorting (only shown if it has any effect)</li><li>Multiply the first two terms with each other until the typical sum remains.</li></ol>",
  "bf_infoblob_load_exercise": "Load exercises from the Tutorium or generate them from boolean formulas<br><br><b>Entering Formulas:</b><br>Use + for logical OR<br>Use * for logical AND<br>Use ~ for logical NOT<br><b>Examples:</b><br>a*b+a<br>a*(b+~a)<br>x0*x1+x0*~x1",
  "bf_load_exercise_from_archive": "Load exercise from archive",
  "bf_error_at_symbol": "Error at symbol",
  "cmos_error_at_symbol": "Error at symbol",
  "at_position": "at position",
  "cmos_enter_more_than_one_variable": "Please enter more than one variable",
  "bf_distributionUC": "Distribution",
  "bf_idempotenceUC": "Idempotence",
  "bf_absorptionUC": "Absorption",
  "bf_sortingUC": "Sorting",
  "bf_infoblob_functionMin": "On this page you can find different procedures for minimizing boolean expressions.",
  "bf_disjunctiveNormalForm_explanation": "The disjunctive normal form is a disjunction (combination of the terms using or operators) of all minterms (1s) of a function. Each minterm corresponds exactly to a 1 in the function, all literals must occur negated or not negated.",
  "bf_conjunctiveNormalForm_explanation": "The conjunctive normal form is a conjunction (combination of the terms using and operators) of all maxterms (0s) of a function. The 0s are not selected in maxterms (like 1s in minterms), but excluded. Each maxterm corresponds exactly to a 0 in the function, all literals must occur negated or not negated.",
  "bf_quineMCCluskeyClasses_explanation": "The Quine/McCluskey algorithm is a minimization algorithm with which the implicants of a function can be determined.",
  "bf_infoblob_quineMCCluskeyClasses_colorCoding": "All terms used in the reduction are normally crossed out in the Quine/McCluskey algorithm. If color coding is active, they are displayed in light gray instead.",
  "bf_infoblob_quineMCCluskeyClasses_01": "Normally we write the min or max terms into the individual classes. Alternatively, we can also work with 0s (for negated literals) and 1s (for non-negated literals), whereby the position of these determines which literal it is.",
  "bf_primeTerms_explanation": "Terms with a minimum number of literals covering only ones or zeros.",
  "bf_bf_primeImplicants_explanation": "Prime implicants are terms that cover only ones (with don't cares).",
  "bf_primeImplicates_explanation": "Prime implicates are terms which cover only zeros (with don't cares).",
  "bf_disjunctiveMinimalForm_explanation": "Disjunction of literals linked by conjunction, which cannot be further simplified (without violating this form) (simplified DNF).",
  "bf_conjunctiveMinimalForm_explanation": "Conjunction of literals linked by disjunction, which cannot be further simplified (without violating this form) (simplified KNF).",
  "bf_nandnorification": "NAND- / NORification",
  "bf_nandification": "NANDification",
  "bf_norification": "NORification",
  "bf_nandify_double_negation_text": "negate twice",
  "bf_nandify_nor_to_and_text": "De Morgan's Law (pull negation in)",
  "bf_nandify_redundant_and_text": "Duplicate term in AND (x = x*x)",
  "bf_norify_double_negation_text": "negate twice",
  "bf_norify_nand_to_or_text": "De Morgan's Law (pull negation in)",
  "bf_norify_redundant_or_text": "Duplicate term in OR (x = x+x)",
  "cmos_infoblob_description": "CMOS is a composition of a complementary NMOS  network (pull-down network, since connected to ground) and PMOS network (pull-up network, since connected to supply voltage).\n As a result, less energy is consumed in the fixed switching state, since PDN and PUN are complementary and thus only conduct simultaneously for a short time during switching. However, more area is required on the chip.",
  "cmos_infoblob_input_description": "Note: For OR gates '+' can be used, for AND gates '*' and for negation '~'. Variables can have arbitrary names (Attention: 'ab' is considered as one variable, not as 'a' multiplied by 'b').",
  "contactPersonHeader": "Contact",
  "herausgeber": "Publisher",
  "divWithZero": "For a division with 0 in the numerator, the result is always 0.",
  "impressum": "Imprint",
  "representedByHeader": "Represented by",
  "copyright": "Chair of Computer Science 12, FAU. All rights reserved.",
  "representedBy": "Chair of Computer Science 12 is a public law institution within the Friedrich-Alexander-Universität Erlangen-Nürnberg (FAU). According to Art. 20, 21 BayHSchG, FAU, as a state institution and self-governing body under public law, is represented externally by the President.",
  "haftungsauschlussHeader": "Disclaimer",
  "mantissaComplement": "The mantissa is negative. So we have to form the complement and set the sign bit.",
  "mantissaNormalize": "To make the mantissa start with a leading 1, we need to normalize the mantissa by applying the shift of {shift}. We also have to apply this shift to the exponent, which results in the new exponent {exponent}.",
  "mantissaNormalizeDenorm": "The result cannot be represented in the normalized representation with the shift {shift}, so we use the denormalized representation with the exponent {exponent}.",
  "newExponentDivision": "The new exponent results as \\( E_{'{neu}'} = E_1 - E_2 + BIAS = %{E1} - %{E2} + %{Bias} = %{Result} \\)",
  "newExponentMultiplication": "The new exponent results as \\( E_{'{neu}'} = E_1 + E_2 - BIAS = %{E1} + %{E2} - %{Bias} = %{Result}\\, (%{ExpBits})\\)",
  "haftungsauschlussBody": "The respective institutions are responsible for the content of other websites. All information provided on this website has been compiled and checked to the best of our knowledge and belief. However, we cannot guarantee that the information provided is up-to-date, correct, complete or available at all times. A contractual relationship with the users of the Internet offer does not come about. We are not liable for any damage caused by the use of this internet offer. This exclusion of liability does not apply if the provisions of §839 of the German Civil Code (liability for breach of official duty) are relevant. No liability is accepted for any damage caused by malware or the installation or use of software when calling up or downloading data. As a service provider, we are responsible for our own content on these pages in accordance with § 7 para.1 TMG under the general laws. According to § 8 to 10 TMG we are not obligated to monitor transmitted or stored information or to investigate circumstances that indicate illegal activity. Obligations to remove or block the use of information under the general laws remain unaffected. However, liability in this regard is only possible from the point in time at which a concrete infringement of the law becomes known. If we become aware of any such infringements, we will remove the relevant content immediately. The operator expressly reserves the right to change, supplement or delete individual web pages, web services or the entire offer without separate announcement or to cease publication temporarily or permanently.",
  "systemInBase": "System of base",
  "basis": "Base",
  "minterms": "Minterms",
  "maxterms": "Maxterms",
  "contact": "Contact",
  "impressumText": "The imprint can be found at: ",
  "and": ", and",
  "weThank": "We would like to thank the following people for their help at creating this website:",
  "Danksagung": "Acknowledgement",
  "thankProfessorTeich": "The materials on this page are based on the lecture GTI by Professor Dr.-Ing. Jürgen Teich of the Friedrich-Alexander-University (FAU). We thank him for his expertise and patronage.",
  "wintersemester": "Winter term",
  "sommersemester": "Summer term",
  "downloadSvg": "Export as SVG",
  "downloadPng": "Export as PNG",
  "formula": "Formula",
  "translate_big": "Translate",
  "divByZero": "Division by 0 is NaN.",
  "falseFormat": "Wrong format!"
}
