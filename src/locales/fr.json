{
  "fpExerciseIntro": "Entraînez-vous à l'arithmétique entre nombres à virgule flottante au format IEEE-754 à l'aide d'exercices générés",
  "fpFormatSelectionSimple": "Pour choisir votre propre format, définissez la répartition des bits entre l'exposant et la mantisse",
  "fpFormatSelection": "Pour choisir un format personnalisé, sélectionnez d'abord le nombre de bits du nombre à virgule flottante, puis définissez la répartition des bits entre les exposants et les mantisses.",
  "fpArithIntro": "Entraînez-vous à l'arithmétique entre nombres à virgule flottante dans le format IEEE-754 ou dans un format défini par l'utilisateur qui s'en inspire",
  "fpConvIntro": "Entraînez-vous à la conversion entre le système décimal et le format de nombres à virgule flottante IEEE-754 ou un format défini par l'utilisateur qui s'en inspire, à l'aide d'exercices générés",
  "polyConvIntro": "Entraînez-vous à la conversion entre des systèmes polyadiques que vous pouvez choisir librement.",
  "polyConvGenIntro": "Pratiquez la conversion entre systèmes polyadiques en résolvant les exercices générés.",
  "fpExerciseText": "On donne les nombres à virgule flottante \\( fp_1 \\) et \\( fp_2 \\) au format 16 bits à virgule flottante. Calculez le %{op1} \\( fp_1 %{op2} fp_2 \\) sans quitter la représentation binaire et redonnez le sous forme de nombre à virgule flottante:",
  "polyadicDivisionDescription": "Les chiffres avant la virgule sont obtenus à partir des chiffres du reste, en les lisant de bas en haut.",
  "polyadicMultiplicationDescription": "Les chiffres après la virgule sont obtenus à partir des chiffres du reste, en les lisant de haut en bas.",
  "numVarInput": "Nombre de Variables",
  "confirm": "Confirmer",
  "input": "Entrée",
  "varNaming": "Nommage des Variables",
  "kvDiagram": "Table de Karnaugh",
  "numeralSystem": "Système de numération",
  "polyadic": "Polyadique",
  "floatingPoint": "Virgule flottante",
  "functionMin": "Minimisation",
  "exercises": "Exercises",
  "generateEx": "Générer l'exercice",
  "generate": "Générer",
  "addition": "Addition",
  "subtraction": "Soustraction",
  "multiplication": "Multiplication",
  "division": "Division",
  "solution": "Solution",
  "ownSolution": "Propre Solution",
  "signBit": "Signe",
  "correctSolution": "Solution",
  "exponentBits": "Exposant",
  "load": "Charger",
  "fractionBits": "Mantisse",
  "attRound": "N'oubliez pas d'arrondir!",
  "attSolve": "Veuillez essayer de résoudre l'exercice au préalable!",
  "step": "Étape",
  "freeCalculation": "Calcul libre",
  "operationSelect": "Configurer le calcul",
  "firstFloatingPoint": "Premier numéro à virgule flottante",
  "secondFloatingPoint": "Deuxième numéro à virgule flottante",
  "polyFreeIntro": "Entraînez-vous à l'arithmétique polyadique avec vos propres valeurs numériques dans le système de votre choix.",
  "operand": "Operand",
  "decimal": "Décimale",
  "binary": "Binaire",
  "inputNumber": "Entrez le numéro",
  "fpformat": "Format en virgule flottante",
  "check": "Vérifier",
  "values": "Valeurs",
  "arithmetic": "Arithmétique",
  "conversion": "Conversion",
  "conversionExercise1": "Convertir: ",
  "conversionExercise2": "en un nombre à virgule flottante IEEE avec un exposant de longueur de ",
  "steps": "étapes",
  "repeatMinuend": "repeat\\ minuend",
  "doDivision": "réaliser la division",
  "doMultiplication": "réaliser la multiplication",
  "getDescription": "Imprimer",
  "approach": "Approche",
  "gti": "Fondements de l'ingénierie informatique",
  "disclaimer": "Disclaimer:<br>Il s'agit d'une approche de solution générée automatiquement par le GTI-Online-Website. Chaque sortie est complètement <u>non officielle</u> et à l'état de brouillon.<br>Nous faisons beaucoup d'efforts pour construire un outil correct et fiable pour vous. Néanmoins, il peut y avoir des défaillances dans la solution ou l'approche. Cela peut notamment dépendre de la version de votre navigateur. Veuillez vérifier avant de l'utiliser, par exemple dans un examen.",
  "example": "Exemple",
  "composition": "composition",
  "negativeSummand": "Une addition avec une valeur négative est similaire à une soustraction.",
  "negativeSubtrahend": "Une soustraction négative est similaire à une addition positive.",
  "negativeMinuendSubtrahend": "Simplification pour le cas \\( - x - y \rightarrow - (x + y) \\)",
  "addWithZero": "Une addition avec 0 donne l'autre somme",
  "subWithZero": "Une soustraction avec 0 donne l'autre valeur",
  "mulWithZero": "Une multiplication avec 0 donne toujours 0",
  "divWithZero": "Une division avec 0 au numérateur donne toujours 0.",
  "zeroDivision": "Une division par 0 est illégale!",
  "arithmeticFree": "Arithmétique libre",
  "conversionFree": "Conversion libre",
  "value": "Valeur",
  "givenValues": "valeurs des nombres transmis",
  "leftValue": "valeur gauche",
  "rightValue": "valeur de droite",
  "firstSummand": "1. sommande",
  "secondSummand": "2. sommande",
  "firstFactor": "1. facteur",
  "secondFactor": "2. facteur",
  "minuend": "minuend",
  "subtrahend": "subtrahend",
  "numerator": "numerator",
  "denominator": "dénominateur",
  "sign": "signe",
  "exponent": "exponent",
  "adjustExponents": "Les exposants des deux nombres doivent être équilibrés",
  "addExponents": "Les exposants des deux nombres doivent être additionnés.",
  "subtExponents": "Les exposants des deux nombres doivent être soustraits.",
  "diffExponent": "Différence des exposants",
  "smallerExponent": "Le plus petit exposant sera soustrait du plus grand",
  "resDiffExponent": "d'où résulte cette différence",
  "newExponent": "nouvel exposant",
  "considerExponent": "considère l'exposant",
  "mantissa": "mantissa",
  "mulMantissa": "La mantisse des deux nombres doit être multipliée",
  "solutionIsNan": "La mantisse ne peut pas être calculée car l'entrée conduit à NaN.",
  "solutionIsInf": "La mantisse ne peut pas être calculée car l'entrée mène à l'infini.",
  "solutionIsZero": "La mantisse ne peut pas être calculée car l'entrée conduit à zéro.",
  "addMantissa": "La mantisse des deux nombres doit être additionnée.",
  "divMantissa": "La mantisse des deux nombres doit être divisée.",
  "newMantissa": "Nouvelle mantisse",
  "zeroMantissa": "les deux mantisses sont égales \\( \\rightarrow \\) la nouvelle mantisse est la mantisse 0",
  "newMantissaIs": "La nouvelle mantisse est donc",
  "equalMantissa": "Les deux mantisses sont égales \\( \\rightarrow \\) l'exposant sera incrémenté la mantisse reste",
  "equalMantissaDiv": "Les deux mantisses sont égales, aucune division binaire ne sera exécutée",
  "adjustSmallerMantissa": "Ajuste la plus petite mantisse",
  "shiftMantissa": "Décale la plus petite mantisse",
  "mantissaFloat": "Mantisse à l'intérieur du flottant",
  "mantissa1float": "Le 1 initial ne fait pas partie du flottant",
  "subtTwosComplement": "La soustraction est similaire à l'addition avec le complément à deux",
  "mantissaTwosComplement": "Formation du complément à deux à partir de la mantisse",
  "switchBits": "Inverser les bits",
  "add1": "Ajouter 1",
  "normalize": "Normaliser",
  "shiftExpMant": "Le facteur de décalage de l'exposant doit être appliqué à la mantisse",
  "shift": "shift",
  "considerRepresentation": "Tenir compte de la représentation",
  "consider1comma": "La mantisse commence par un 1 dans la forme standard",
  "firstFormat": "format initial",
  "secondFormat": "format cible",
  "doConversion": "Convertir:",
  "modus": "modus",
  "to": "en",
  "TenToPower": "La conversion du système décimal en un système arbitraire se fait en deux étapes. Avant la virgule, les chiffres sont convertis à l'aide de l'algorithme de division. Après la virgule, l'algorithme de multiplication sera appliqué",
  "PowerToTen": "Un système numérique arbitraire peut être converti en système décimal en résumant tous les chiffres potentialisés.",
  "PowerToPower": "Nous convertissons un système numérique arbitraire en un autre en deux étapes via le système décimal. Dans un premier temps, le nombre original sera transféré dans le système décimal en résumant les chiffres potentialisés. Dans la deuxième étape, nous utilisons l'algorithme de division et de multiplication pour créer le nombre résultant.",
  "noValuesBeforeComma": "Il n'y a pas de valeurs devant la virgule. Par conséquent, l'algorithme de division peut être ignoré.",
  "noValuesAfterComma": "Il n'y a pas de valeur après la virgule. Par conséquent, l'algorithme de multiplication peut être ignoré.",
  "firstToToen": "1. somme des chiffres potentialisés",
  "secondToPower": "2. conversion via l'algorithme de division et de multiplication",
  "shortcutBinToHex": "Lors de la conversion du binaire en hexadécimal, les valeurs peuvent être lues directement",
  "shortcutHexToBin": "Lors de la conversion d'hexadécimal en binaire, les valeurs peuvent être lues directement",
  "divisionAlgorithm": "Algorithme de division",
  "multiplicationAlgorithm": "Algorithme de multiplication",
  "summation": "Sommation",
  "factor": "Facteur",
  "quotient": "Quotient",
  "remainder": "reste",
  "newBasis": "Base_{{nouvelle}}",
  "calcStep": "étape\\ de\\ calcul",
  "summands": "sommets",
  "polyadicExercise1": "Convertissez la valeur:",
  "polyadicExercise2": "à partir du format initial: ",
  "polyadicExercise3": "au format cible:",
  "exerciseArchive": "Archive d'exercices",
  "randomExercise": "Exercice aléatoire",
  "doCalculation": "Calculer",
  "colorCoding": "code couleur",
  "mathDistribution": "Distribution",
  "easy": "simple",
  "difficultyMiddle": "moyenne",
  "difficultyHard": "difficile",
  "feuille": "feuille",
  "goal": "Objectif",
  "difficultyUC": "Difficulté",
  "bf_infotext_or_interact_with_kv": "Ou interagir directement avec le Diagramme KV",
  "bf_infotext_kv_must_not_be_empty": "Le Diagramme KV doit contenir des 1 et des 0",
  "bf_infotest_click_on_hidden_areas_to_make_visible": "Cliquez sur les zones cachées pour les révéler",
  "bf_normal_forms": "Formes normales",
  "bf_disjunctiveNormalForm": "Forme normale disjonctive",
  "bf_conjunctiveNormalForm": "Forme normale conjonctive",
  "bf_disjunctiveMinimalForm": "Forme minimale disjonctive",
  "bf_conjunctiveMinimalForm": "Forme minimale conjonctive",
  "bf_quineMCCluskeyClasses": "Classes de méthode de Quine-Mc Cluskey",
  "bf_primeTerms": "Primeterms",
  "bf_primeImplicants": "Primo-implicants",
  "bf_primeImplicates": "primo-implicats",
  "bf_primeCoverTable": "Prime implicant chart / 'Cover Table'",
  "bf_petrickExpression": "Expression de Petrick",
  "bf_minimalForms": "Formes minimales",
  "bf_tableWithCyclicRest": "Table avec repos cyclique",
  "bf_einstelle": "Un",
  "bf_nullstelle": "Zéro",
  "bf_einstellen": "Ones",
  "bf_nullstellen": "Zéros",
  "bf_goal_determine_DNF": "déterminer la DNF",
  "bf_goal_determine_KNF": "déterminer la KNF",
  "bf_goal_determine_prime_implicants": "déterminer les primo-implicants",
  "bf_goal_determine_prime_implicates": "déterminer les primo-implicats",
  "bf_covertable_step_description_initial": "<h4>Étape initiale:</h4>Saisissez tous les termes de base dans les colonnes et tous les termes premiers (PI) dans les lignes du tableau. Si un terme premier couvre un champ, marquez cette cellule d'un X. Le coût c d'un terme premier est le nombre de ses littéraux. Plus il est élevé, plus l'implémentation en matériel est complexe (c'est-à-dire coûteuse).<br>Tip:<br>Un implicaNT premier couvre un 'ONE' exactement si tous les littéraux du primeterm apparaissent également de la même manière dans le terme de base.",
  "bf_covertable_step_description_core_found": "<h4>Core found:</h4>Le seul primeterm qui couvre la colonne {columnName} est le terme {rowName}. Par conséquent, ce primeterme doit absolument apparaître dans notre fonction résultante! Marquez la ligne comme une 'core' (Kern) et rayez la colonne.",
  "bf_covertable_step_description_cross_column_bc_covered": "<h4>Colonne déjà couverte:</h4>La colonne {columnName} est déjà couverte par le primeterm {rowName}. Supprimez la colonne",
  "bf_covertable_step_description_cross_row_bc_covered": "<h4>Row already covered:</h4>Tous les X de la ligne {rowName} sont déjà couverts. Rayez la ligne",
  "bf_covertable_step_description_row_domination": "<h4>Row dominance / Reihendominanz:</h4>La ligne {dominatorName} domine la ligne {dominatedName}; c'est-à-dire que la rangée {dominatorName} a des marqueurs partout où la rangée {dominatedName} en a aussi (et peut-être plus!). => croise la ligne dominée {dominatedName}. <br>Notez que la dominance de rangée n'est applicable, que parce que la rangée {dominatorName} coûte moins que, ou la même que {dominatedName}; ou parce qu'il n'existe aucune autre rangée qui couvre les marqueurs supplémentaires de {dominatorName} et dont le coût est inférieur à {dominatorName} - {dominatedName}.",
  "bf_covertable_step_description_column_domination": "<h4>Column dominance / Spaltendominanz:</h4> La colonne {dominatorName} domine la colonne {dominatedName}; c'est-à-dire que la colonne {dominatorName} a des marqueurs partout où la colonne {dominatedName} en a aussi (et peut-être plus!). => Traverser la colonne dominante {dominatorName} <br>Contrairement à la dominance de ligne, la dominance de colonne ne nécessite pas du tout de considérer les coûts.",
  "bf_covertable_step_description_cyclique_rest": "<h4>Repos cyclique:</h4> Aucune règle de l'algorithme des tables premières n'est applicable. On parle alors d'un 'repos cyclique' (ger : 'Zyklischer Rest'). <br>En établissant l'expression de Petrick (ger: Petrick Ausdruck) pour la table de repos, on est toujours capable de déterminer une forme minimale de la fonction originale.",
  "bf_infoblob_random_exercise_selection": "La difficulté indique le nombre de termes individuels d'un certain type (par exemple, les termes mineurs, les primo-implicants) que la fonction booléenne doit produire.",
  "bf_infoblob_petrick_statement": "L'algorithme se compose de deux phases:<ol><li>Faire en sorte que les termes qui s'absorbent les uns les autres soient facilement visibles grâce à un tri (affiché uniquement s'il a un effet quelconque)</li><li>Multiplier les deux premiers termes entre eux jusqu'à ce que la somme typique subsiste.</li></ol>",
  "bf_distributionUC": "Distribution",
  "bf_idempotenceUC": "Idempotence",
  "bf_absorptionUC": "Absorption",
  "bf_sortingUC": "Triage"
}