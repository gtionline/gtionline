{
  "complementExample": "Complement",
  "shiftZero": "Zéro après le décalage",
  "doubleNegative": "Negative",
  "denormalized": "Denormaliser",
  "fpExerciseIntro": "Entraînez-vous à l'arithmétique entre nombres à virgule flottante au format IEEE-754 à l'aide d'exercices générés",
  "fpFormatSelectionSimple": "Pour choisir votre propre format, définissez la répartition des bits entre l'exposant et la mantisse",
  "fpFormatSelection": "Pour choisir un format personnalisé, sélectionnez d'abord le nombre de bits du nombre à virgule flottante, puis définissez la répartition des bits entre les exposants et les mantisses.",
  "fpArithIntro": "Entraînez-vous à l'arithmétique entre nombres à virgule flottante dans le format IEEE-754 ou dans un format défini par l'utilisateur qui s'en inspire",
  "fpConvIntro": "Entraînez-vous à la conversion entre le système décimal et le format de nombres à virgule flottante IEEE-754 ou un format défini par l'utilisateur qui s'en inspire, à l'aide d'exercices générés",
  "polyConvIntro": "Entraînez-vous à la conversion entre des systèmes polyadiques que vous pouvez choisir librement.",
  "polyConvGenIntro": "Pratiquez la conversion entre systèmes polyadiques en résolvant les exercices générés.",
  "fpExerciseText": "On donne les nombres à virgule flottante \\( fp_1 \\) et \\( fp_2 \\) au format 16 bits à virgule flottante. Calculez \\( fp_1 {op2} fp_2 \\) ({op1}) sans quitter la représentation binaire et redonnez le sous forme de nombre à virgule flottante:",
  "polyadicDivisionDescription": "Les chiffres avant la virgule sont obtenus à partir des chiffres du reste, en les lisant de bas en haut.",
  "polyadicMultiplicationDescription": "Les chiffres après la virgule sont obtenus à partir des chiffres du reste, en les lisant de haut en bas.",
  "numVarInput": "Nombre de Variables",
  "confirm": "Confirmer",
  "input": "Entrée",
  "disclaimerFooter": "Aucune garantie n'est donnée quant à l'exactitude du matériel mis à disposition sur ce site.",
  "varNaming": "Nommage des Variables",
  "kvDiagram": "Table de Karnaugh",
  "numeralSystem": "Système de numération",
  "polyadic": "Polyadique",
  "floatingPoint": "Virgule flottante",
  "functionMin": "Minimisation",
  "exercises": "Exercises",
  "newMantissaSignBit": "En raison du complément, nous comptons avec un bit de signe :",
  "generateEx": "Générer l'exercice",
  "generate": "Générer",
  "addition": "Addition",
  "subtraction": "Soustraction",
  "multiplication": "Multiplication",
  "division": "Division",
  "solution": "Solution",
  "ownSolution": "Propre Solution",
  "signBit": "Signe",
  "correctSolution": "Solution",
  "exponentBits": "Exposant",
  "load": "Charger",
  "fractionBits": "Mantisse",
  "attRound": "N'oubliez pas d'arrondir!",
  "attSolve": "Veuillez essayer de résoudre l'exercice au préalable!",
  "step": "Étape",
  "freeCalculation": "Calcul libre",
  "operationSelect": "Configurer le calcul",
  "firstFloatingPoint": "Premier numéro à virgule flottante",
  "secondFloatingPoint": "Deuxième numéro à virgule flottante",
  "polyFreeIntro": "Entraînez-vous à l'arithmétique polyadique avec vos propres valeurs numériques dans le système de votre choix.",
  "operand": "Operand",
  "decimal": "Décimale",
  "binary": "Binaire",
  "inputNumber": "Entrez le numéro",
  "fpformat": "Format en virgule flottante",
  "check": "Vérifier",
  "values": "Valeurs",
  "arithmetic": "Arithmétique",
  "conversion": "Conversion",
  "conversionExercise1": "Convertir: ",
  "conversionExercise2": "en un nombre à virgule flottante IEEE avec un exposant de longueur de ",
  "steps": "étapes",
  "repeatMinuend": "repeat\\ minuend",
  "doDivision": "réaliser la division",
  "doMultiplication": "réaliser la multiplication",
  "getDescription": "Imprimer",
  "approach": "Approche",
  "gti": "Fondements de l'ingénierie informatique",
  "disclaimer": "Disclaimer:<br>Il s'agit d'une approche de solution générée automatiquement par le GTI-Online-Website. Chaque sortie est complètement <u>non officielle</u> et à l'état de brouillon.<br>Nous faisons beaucoup d'efforts pour construire un outil correct et fiable pour vous. Néanmoins, il peut y avoir des défaillances dans la solution ou l'approche. Cela peut notamment dépendre de la version de votre navigateur. Veuillez vérifier avant de l'utiliser, par exemple dans un examen.",
  "example": "Exemple",
  "composition": "composition",
  "negativeSummand": "Une addition avec une valeur négative est similaire à une soustraction.",
  "negativeSubtrahend": "Une soustraction négative est similaire à une addition positive.",
  "negativeMinuendSubtrahend": "Simplification pour le cas \\( - x - y \rightarrow - (x + y) \\)",
  "addWithZero": "Une addition avec 0 donne l'autre somme",
  "subWithZero": "Une soustraction avec 0 donne l'autre valeur",
  "mulWithZero": "Une multiplication avec 0 donne toujours 0",
  "divWithZero": "Une division avec 0 au numérateur donne toujours 0.",
  "zeroDivision": "Une division par 0 est illégale!",
  "arithmeticFree": "Arithmétique libre",
  "conversionFree": "Conversion libre",
  "value": "Valeur",
  "givenValues": "valeurs des nombres transmis",
  "leftValue": "valeur gauche",
  "rightValue": "valeur de droite",
  "firstSummand": "1. sommande",
  "secondSummand": "2. sommande",
  "firstFactor": "1. facteur",
  "secondFactor": "2. facteur",
  "minuend": "minuend",
  "subtrahend": "subtrahend",
  "numerator": "numerator",
  "denominator": "dénominateur",
  "sign": "signe",
  "exponent": "exposant",
  "adjustExponents": "Les exposants des deux nombres doivent être équilibrés",
  "addExponents": "Les exposants des deux nombres doivent être additionnés.",
  "subtExponents": "Les exposants des deux nombres doivent être soustraits.",
  "diffExponent": "Différence des exposants",
  "smallerExponent": "Le plus petit exposant sera soustrait du plus grand.",
  "resDiffExponent": "D'où résulte cette différence",
  "newExponent": "nouvel exposant",
  "considerExponent": "considère l'exposant",
  "mantissa": "mantisse",
  "mulMantissa": "La mantisse des deux nombres doit être multipliée",
  "solutionIsNan": "La mantisse ne peut pas être calculée car l'entrée conduit à NaN.",
  "solutionIsInf": "La mantisse ne peut pas être calculée car l'entrée mène à l'infini.",
  "solutionIsZero": "La mantisse ne peut pas être calculée car l'entrée conduit à zéro.",
  "addMantissa": "La mantisse des deux nombres doit être additionnée.",
  "divMantissa": "La mantisse des deux nombres doit être divisée.",
  "newMantissa": "Nouvelle mantisse",
  "zeroMantissa": "les deux mantisses sont égales \\( \\rightarrow \\) la nouvelle mantisse est la mantisse 0",
  "newMantissaIs": "La nouvelle mantisse est donc",
  "equalMantissa": "Les deux mantisses sont égales \\( \\rightarrow \\) l'exposant sera incrémenté la mantisse reste",
  "equalMantissaDiv": "Les deux mantisses sont égales, aucune division binaire ne sera exécutée",
  "adjustSmallerMantissa": "Ajuste la mantisse",
  "shiftMantissa": "Décale la mantisse",
  "mantissaFloat": "Mantisse à l'intérieur du flottant",
  "mantissa1float": "La position initial ne fait pas partie du flottant",
  "subtTwosComplement": "La soustraction est similaire à l'addition avec le complément à deux",
  "mantissaTwosComplement": "Formation du complément à deux à partir de la mantisse",
  "switchBits": "Inverser les bits",
  "add1": "Ajouter 1",
  "normalize": "Normaliser",
  "shiftExpMant": "Le facteur de décalage de l'exposant doit être appliqué à la mantisse",
  "shift": "shift",
  "considerRepresentation": "Tenir compte de la représentation",
  "consider1comma": "La mantisse commence par un 1 dans la forme standard (et un 0 dans la représentation dénormalisée).",
  "firstFormat": "format initial",
  "secondFormat": "format cible",
  "doConversion": "Convertir:",
  "modus": "modus",
  "to": "en",
  "TenToPower": "La conversion du système décimal en un système arbitraire se fait en deux étapes. Avant la virgule, les chiffres sont convertis à l'aide de l'algorithme de division. Après la virgule, l'algorithme de multiplication sera appliqué",
  "PowerToTen": "Un système numérique arbitraire peut être converti en système décimal en résumant tous les chiffres potentialisés.",
  "PowerToPower": "Nous convertissons un système numérique arbitraire en un autre en deux étapes via le système décimal. Dans un premier temps, le nombre original sera transféré dans le système décimal en résumant les chiffres potentialisés. Dans la deuxième étape, nous utilisons l'algorithme de division et de multiplication pour créer le nombre résultant.",
  "noValuesBeforeComma": "Il n'y a pas de valeurs devant la virgule. Par conséquent, l'algorithme de division peut être ignoré.",
  "noValuesAfterComma": "Il n'y a pas de valeur après la virgule. Par conséquent, l'algorithme de multiplication peut être ignoré.",
  "firstToTen": "1. somme des chiffres potentialisés",
  "secondToPower": "2. conversion via l'algorithme de division et de multiplication",
  "shortcutBinToHex": "Lors de la conversion du binaire en hexadécimal, les valeurs peuvent être lues directement",
  "shortcutHexToBin": "Lors de la conversion d'hexadécimal en binaire, les valeurs peuvent être lues directement",
  "divisionAlgorithm": "Algorithme de division",
  "multiplicationAlgorithm": "Algorithme de multiplication",
  "summation": "Sommation",
  "factor": "Facteur",
  "quotient": "Quotient",
  "remainder": "reste",
  "newBasis": "Base_{'{nouvelle}'}",
  "calcStep": "étape\\ de\\ calcul",
  "summands": "sommets",
  "polyadicExercise1": "Convertissez la valeur:",
  "polyadicExercise2": "à partir du format initial: ",
  "polyadicExercise3": "au format cible:",
  "exerciseArchive": "Archive d'exercices",
  "randomExercise": "Exercice aléatoire",
  "doCalculation": "Calculer",
  "colorCoding": "Code couleur",
  "mathDistribution": "Distribution",
  "easy": "simple",
  "difficultyMiddle": "moyenne",
  "difficultyHard": "difficile",
  "sheet": "feuille",
  "goal": "Objectif",
  "difficultyUC": "Difficulté",
  "bf_infotext_or_interact_with_kv": "Ou interagir directement avec le Diagramme KV",
  "bf_infotext_kv_must_not_be_empty": "Le Diagramme KV doit contenir des 1 et des 0",
  "bf_infotest_click_on_hidden_areas_to_make_visible": "Cliquez sur les zones cachées pour les révéler",
  "bf_normal_forms": "Formes normales",
  "bf_disjunctiveNormalForm": "Forme normale disjonctive",
  "bf_conjunctiveNormalForm": "Forme normale conjonctive",
  "bf_disjunctiveMinimalForm": "Forme minimale disjonctive",
  "bf_conjunctiveMinimalForm": "Forme minimale conjonctive",
  "bf_quineMCCluskeyClasses": "Classes de méthode de Quine-Mc Cluskey",
  "bf_primeTerms": "Primeterms",
  "bf_primeImplicants": "Primo-implicants",
  "bf_primeImplicates": "Primo-implicats",
  "bf_primeCoverTable": "Prime implicant chart / 'Cover Table'",
  "bf_petrickExpression": "Expression de Petrick",
  "bf_minimalForms": "Formes minimales",
  "bf_tableWithCyclicRest": "Table avec repos cyclique",
  "bf_einstelle": "Un",
  "bf_nullstelle": "Zéro",
  "bf_einstellen": "Ones",
  "bf_nullstellen": "Zéros",
  "bf_goal_determine_DNF": "déterminer la DNF",
  "bf_goal_determine_KNF": "déterminer la KNF",
  "bf_goal_determine_prime_implicants": "déterminer les primo-implicants",
  "bf_goal_determine_prime_implicates": "déterminer les primo-implicats",
  "bf_covertable_step_description_initial": "<h4>Étape initiale:</h4>Saisissez tous les termes de base dans les colonnes et tous les termes premiers (PI) dans les lignes du tableau. Si un terme premier couvre un {ifMinTermsEinstelleElseNullstelle}, marquez cette cellule d'un X. Le coût c d'un terme premier est le nombre de ses littéraux. Plus il est élevé, plus l'implémentation en matériel est complexe (c'est-à-dire coûteuse).<br>Tip:<br>Un implicaNT premier couvre un 'ONE' exactement si tous les littéraux du primeterm apparaissent également de la même manière dans le terme de base.",
  "bf_covertable_step_description_core_found": "<h4>Core found:</h4>Le seul primeterm qui couvre la colonne {columnName} est le terme {rowName}. Par conséquent, ce primeterme doit absolument apparaître dans notre fonction résultante! Marquez la ligne comme une 'core' (Kern) et rayez la colonne.",
  "bf_covertable_step_description_cross_column_bc_covered": "<h4>Colonne déjà couverte:</h4>La colonne {columnName} est déjà couverte par le primeterm {rowName}. Supprimez la colonne.",
  "bf_covertable_step_description_cross_row_bc_covered": "<h4>Row already covered:</h4>Tous les X de la ligne {rowName} sont déjà couverts. Rayez la ligne.",
  "bf_covertable_step_description_row_domination": "<h4>Row dominance / Reihendominanz:</h4>La ligne {dominatorName} domine la ligne {dominatedName}; c'est-à-dire que la rangée {dominatorName} a des marqueurs partout où la rangée {dominatedName} en a aussi (et peut-être plus!). => croise la ligne dominée {dominatedName}. <br>Notez que la dominance de rangée n'est applicable, que parce que la rangée {dominatorName} coûte moins que, ou la même que {dominatedName}; ou parce qu'il n'existe aucune autre rangée qui couvre les marqueurs supplémentaires de {dominatorName} et dont le coût est inférieur à {dominatorName} - {dominatedName}.",
  "bf_covertable_step_description_column_domination": "<h4>Column dominance / Spaltendominanz:</h4> La colonne {dominatorName} domine la colonne {dominatedName}; c'est-à-dire que la colonne {dominatorName} a des marqueurs partout où la colonne {dominatedName} en a aussi (et peut-être plus!). => Traverser la colonne dominante {dominatorName} <br>Contrairement à la dominance de ligne, la dominance de colonne ne nécessite pas du tout de considérer les coûts.",
  "bf_covertable_step_description_cyclic_rest": "<h4>Repos cyclique:</h4> Aucune règle de l'algorithme des tables premières n'est applicable. On parle alors d'un 'repos cyclique' (ger : 'Zyklischer Rest'). <br>En établissant l'expression de Petrick (ger: Petrick Ausdruck) pour la table de repos, on est toujours capable de déterminer une forme minimale de la fonction originale.",
  "bf_infoblob_random_exercise_selection": "La difficulté indique le nombre de termes individuels d'un certain type (par exemple, les termes mineurs, les primo-implicants) que la fonction booléenne doit produire.",
  "bf_infoblob_petrick_statement": "L'algorithme se compose de deux phases:<ol><li>Faire en sorte que les termes qui s'absorbent les uns les autres soient facilement visibles grâce à un tri (affiché uniquement s'il a un effet quelconque)</li><li>Multiplier les deux premiers termes entre eux jusqu'à ce que la somme typique subsiste.</li></ol>",
  "bf_distributionUC": "Distribution",
  "bf_idempotenceUC": "Idempotence",
  "bf_absorptionUC": "Absorption",
  "bf_sortingUC": "Triage",
  "contactPersonHeader": "Contact",
  "contact": "Contact",
  "copyright": "Chaire d'informatique 12, FAU. Tous droits réservés.",
  "herausgeber": "Éditeur",
  "impressum": "Mentions légales",
  "representedByHeader": "Représenté par",
  "representedBy": "La chaire d'informatique 12 est une institution de droit public au sein de la Friedrich-Alexander-Universität Erlangen-Nürnberg (FAU). Conformément aux articles 20 et 21 de la BayHSchG, la FAU, en tant qu'établissement public et collectivité autonome de droit public, est représentée à l'extérieur par son président.",
  "haftungsauschlussHeader": "Clause de non-responsabilité",
  "mantissaComplement": "La mantisse est négative. Il faut donc former le complément et placer le bit de signe.",
  "mantissaNormalize": "Pour que la mantisse commence par un 1, nous devons normaliser la mantisse en appliquant le décalage de {shift}. Nous devons également appliquer ce décalage à l'exposant, ce qui donne le nouvel exposant {exposant}.",
  "mantissaNormalizeDenorm" : "Le résultat ne peut pas être affiché en représentation normalisée avec le décalage {shift}, c'est pourquoi nous utilisons la représentation dénormalisée avec l'exposant {exponent}",
  "newExponentDivision": "Le nouvel exposant est obtenu par \\( E_{'{neu}'} = E_1 - E_2 + BIAS = {E1} - {E2} + {Bias} = {Result} \\)",
  "newExponentMultiplication": "Le nouvel exposant est obtenu par \\( E_{'{neu}'} = E_1 + E_2 - BIAS = {E1} + {E2} - {Bias} = {Result}\\, ({ExpBits})\\)",
  "haftungsauschlussBody": "Les contenus d'autres offres web relèvent de la responsabilité des institutions concernées. Nous avons élaboré et vérifié en toute conscience toutes les informations mises à disposition sur ce site Internet. Nous ne pouvons toutefois pas garantir l'actualité, l'exactitude, l'exhaustivité et la disponibilité des informations mises à disposition à tout moment. Aucune relation contractuelle n'est établie avec les utilisateurs de l'offre Internet. Nous ne sommes pas responsables des dommages causés par l'utilisation de cette offre Internet. Cette exclusion de responsabilité ne s'applique pas dans la mesure où les dispositions de l'article 839 du code civil (responsabilité en cas de manquement à une obligation officielle) sont pertinentes. Nous déclinons toute responsabilité pour les éventuels dommages causés par des logiciels malveillants lors de l'appel ou du téléchargement de données ou de l'installation ou de l'utilisation de logiciels. En tant que prestataire de services, nous sommes responsables, conformément au § 7 alinéa 1 de la loi allemande sur les télémédias (TMG), de nos propres contenus sur ces pages selon les lois générales. Conformément aux § 8 à 10 de la TMG, nous ne sommes toutefois pas tenus, en tant que prestataire de services, de surveiller les informations externes transmises ou enregistrées ou de rechercher des circonstances indiquant une activité illégale. Les obligations de supprimer ou de bloquer l'utilisation d'informations conformément aux lois générales restent inchangées. Une responsabilité à cet égard n'est toutefois possible qu'à partir du moment où une violation concrète de la loi est connue. Dès la prise de connaissance d'une telle violation de la loi, nous supprimerons immédiatement ces contenus. L'exploitant se réserve expressément le droit de modifier, de compléter, de supprimer ou de suspendre temporairement ou définitivement la publication de certaines pages web, de certains services web ou de l'ensemble de l'offre sans préavis particulier.",
  "startTraining": "Allons-y",
  "sequentialCircuit": "Exemple de circuit séquentiel comprenant deux D-flipflops et des multiplexeurs.",
  "enter_cmos": "Veuillez entrer votre formule CMOS.",
  "conversionExercise": "Exercices de conversion",
  "homePageText": "L'objectif de GTI-Online est d'approfondir la connaissance des sujets sélectionnés appris dans le cours et l'exercice correspondant. Sélectionnez dans le menu un sujet et commencez à vous entraîner.",
  "cmos_infoblob_description": "Le CMOS est une composition d'un réseau complémentaire NMOS (réseau pull-down, puisque connecté à la masse) et PMOS (réseau pull-up, puisque connecté à la tension d'alimentation).\n Par conséquent, moins d'énergie est consommée dans l'état de commutation fixe, puisque PDN et PUN sont complémentaires et ne conduisent donc simultanément que pendant un court moment lors de la commutation. Cependant, une plus grande surface est nécessaire sur la puce.",
  "bf_bf_primeImplicants_explanation": "Les primitifs sont des primitifs qui ne couvrent que des uns (avec des indifférents).",
  "bf_conjunctiveMinimalForm_explanation": "Conjonction de littéraux liés par disjonction, qui ne peut être simplifiée davantage (sans violer cette forme) (KNF simplifiée).",
  "bf_primeTerms_explanation": "Termes avec un nombre minimum de littéraux couvrant uniquement des uns ou des zéros.",
  "bf_primeImplicates_explanation": "Les primo-implicates sont des primitives qui ne couvrent que des zéros (avec des indifférences).",
  "bf_infoblob_functionMin": "Sur cette page, vous trouverez différentes procédures pour minimiser les expressions booléennes.",
  "bf_disjunctiveNormalForm_explanation": "La forme normale disjonctive est une disjonction (combinaison des termes utilisant ou opérateurs) de tous les mintermes (1) d'une fonction. Chaque minterme correspond exactement à un 1 dans la fonction, tous les littéraux doivent apparaître niés ou non niés.",
  "bf_infoblob_quineMCCluskeyClasses_01": "Normalement, nous écrivons les termes minimum et maximum dans les différentes classes. Il est également possible de travailler avec des 0 (pour les littéraux niés) et des 1 (pour les littéraux non niés), la position de ces derniers déterminant de quel littéral il s'agit.",
  "bf_conjunctiveNormalForm_explanation": "La forme normale conjonctive est une conjonction (combinaison des termes utilisant et opérateurs) de tous les maxtermes (0s) d'une fonction. Les 0 ne sont pas sélectionnés dans les maxterms (comme les 1 dans les minterms), mais exclus. Chaque maxterme correspond exactement à un 0 dans la fonction, tous les littéraux doivent apparaître niés ou non niés.",
  "bf_quineMCCluskeyClasses_explanation": "L'algorithme de Quine/McCluskey est un algorithme de minimisation qui permet de déterminer les primetermes d'une fonction.",
  "bf_infoblob_quineMCCluskeyClasses_colorCoding": "Tous les termes utilisés dans la réduction sont normalement barrés dans l'algorithme de Quine/McCluskey. Si le codage couleur est actif, ils sont affichés en gris clair à la place.",
  "bf_disjunctiveMinimalForm_explanation": "Disjonction de littéraux liés par une conjonction, qui ne peut être simplifiée davantage (sans violer cette forme) (DNF simplifiée).",
  "octal": "Nombre octal",
  "quaternary": "Nombre quaternaire",
  "representation": "Représentation dans le format initial",
  "number": "nombre",
  "novenary": "Nombre nonal",
  "ternary": "Nombre ternaire",
  "senary": "Nombre hexaire",
  "quinary": "Nombre de quintal",
  "septenary": "Système heptal",
  "hex": "Hexadécimal",
  "cmos_infoblob_input_description": "Note : On peut utiliser '+' pour les portes OU, '*' pour les portes ET et '~' pour la négation. Les variables peuvent avoir des noms arbitraires (Attention : 'ab' est considéré comme une seule variable, et non comme 'a' mutiplié par 'b').",
  "hexadecimal": "Nombre hexadécimal",
  "systemInBase": "Système à la base",
  "basis": "Base",
  "minterms": "Termes minimaux",
  "maxterms": "Termes maximaux",
  "impressumText": "Vous trouverez les mentions légales sous :",
  "and": " et",
  "weThank": "Nous remercions les personnes suivantes pour leur aide à la création de ce site:",
  "Danksagung": "Remerciements",
  "thankProfessorTeich": "Le matériel de cette page est basé sur le cours GTI du professeur Dr. Jürgen Teich de l'université Friedrich-Alexander-Universität (FAU). Nous le remercions pour son expertise et son parrainage.",
  "wintersemester": "Semestre d'hiver",
  "sommersemester": "Semestre d'été",
  "downloadSvg": "Exporter en SVG",
  "downloadPng": "Exporter en PNG",
  "formula": "Formule",
  "divByZero": "La division par 0 donne NaN.",
  "falseFormat": "Mauvais format"
}
