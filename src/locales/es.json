{
  "complementExample": "Complemento",
  "shiftZero": "Cero después del desplazamiento",
  "doubleNegative": "Negativo",
  "denormalized": "Denormalización",
  "fpExerciseIntro": "Practique aritmética entre números de punto flotante en formato IEEE-754 utilizando ejercicios generados",
  "fpFormatSelectionSimple": "Para seleccionar un formato personalizado, especifica la distribución de bits entre los exponentes y la mantisa",
  "fpFormatSelection": "Para seleccionar su propio formato, selecciona primero el número de bits del número en coma flotante y luego especifique la distribución de bits entre los exponentes y la mantisa",
  "fpArithIntro": "Practique la aritmética entre números de punto flotante en el formato según IEEE-754 o un formato autodefinido basado en él",
  "fpConvIntro": "Practique la conversión entre el sistema decimal y el formato de números de punto flotante según IEEE-754 o un formato autodefinido basado en él, utilizando ejercicios generados",
  "polyConvIntro": "Practique la conversión entre sistemas poliádicos que puedes elegir libremente.",
  "polyConvGenIntro": "Practique la conversión entre sistemas poliádicos resolviendo los ejercicios generados.",
  "numVarInput": "Número de variables",
  "confirm": "Confirmar",
  "input": "Entrada",
  "varNaming": "Nombramiento variable",
  "kvDiagram": "Mapa de Karnaugh",
  "numeralSystem": "Sistema de numeración",
  "polyadic": "Poliádico",
  "floatingPoint": "Coma Flotante",
  "functionMin": "Minimización",
  "exercises": "Ejercicios",
  "generateEx": "Generar Ejercicio",
  "generate": "Generar",
  "addition": "Adición",
  "subtraction": "Sustracción",
  "multiplication": "Multiplicación",
  "division": "División",
  "solution": "Solución",
  "ownSolution": "Solución propia",
  "signBit": "Bit de signo",
  "correctSolution": "Solución",
  "exponentBits": "Exponente",
  "fractionBits": "Fracción",
  "attRound": "¡No olvide redondear!",
  "attSolve": "¡Por favor, intente resolver el ejercicio de antemano!",
  "step": "Paso",
  "freeCalculation": "Cálculo libre",
  "operationSelect": "Configurar la computación",
  "firstFloatingPoint": "Primer número de punto flotante",
  "secondFloatingPoint": "Segundo número de punto flotante",
  "operand": "Operativo",
  "decimal": "Decimal",
  "binary": "Binario",
  "inputNumber": "Introduce el número",
  "fpformat": "Formato de punto flotante",
  "check": "Comprobar",
  "values": "Valores",
  "arithmetic": "Aritmética",
  "conversion": "Conversión",
  "conversionExercise1": "Convertir: ",
  "conversionExercise2": "en un número de punto flotante IEEE con una longitud de exponente de ",
  "steps": "pasos",
  "repeatMinuend": "repite\\ minuendo",
  "doDivision": "Realice una división",
  "doMultiplication": "Realice una multiplicación",
  "getDescription": "Imprimir",
  "approach": "Procedimiento",
  "gti": "Fundamentos de la informática técnica",
  "disclaimer": "Descargo de responsabilidad:<br> Este es un enfoque de solución generado automáticamente por el sitio web de GTI-Online. Todos los resultados son completamente no oficiales y están en estado de borrador. Estamos haciendo muchos esfuerzos para construir una herramienta correcta y fiable para usted. Independientemente de ello, puede haber fallos en la solución o en el planteamiento. Esto puede depender especialmente de la versión de su navegador.",
  "example": "Ejemplo",
  "composition": "Composición",
  "negativeSummand": "Una suma con valor negativo es similar a una resta",
  "negativeSubtrahend": "Un sustraendo negativo es similar a un sumando positivo",
  "negativeMinuendSubtrahend": "Simplificación para el caso \\( - x - y \\rightarrow - (x + y) \\)",
  "addWithZero": "Una suma con 0 da como resultado el otro sumando",
  "subWithZero": "Una resta con 0 da como resultado el otro valor",
  "mulWithZero": "Una multiplicación con 0 da como resultado siempre 0",
  "divWithZero": "Una división con 0 en el numerador da como resultado siempre 0",
  "zeroDivision": "¡Una división por 0 es ilegal!",
  "arithmeticFree": "Aritmética libre",
  "conversionFree": "Conversión Libre",
  "value": "Valor",
  "givenValues": "Valores de los números transmitidos",
  "leftValue": "El valor de la izquierda",
  "rightValue": "El valor de la derecha",
  "firstSummand": "1. Sumario",
  "secondSummand": "2. Sumario",
  "firstFactor": "1. Factor",
  "secondFactor": "2. Factor",
  "minuend": "Minucioso",
  "subtrahend": "Restando",
  "numerator": "Numerador",
  "denominator": "Denominador",
  "sign": "Firma",
  "exponent": "Exponente",
  "adjustExponents": "Los exponentes de ambos números deben estar equilibrados.",
  "addExponents": "Hay que sumar los exponentes de ambos números.",
  "subtExponents": "Hay que restar los exponentes de ambos números.",
  "diffExponent": "Diferencia de los exponentes",
  "smallerExponent": "El exponente menor se restará del mayor.",
  "resDiffExponent": "De ahí que esta diferencia resulte",
  "newExponent": "Nuevo exponente",
  "considerExponent": "Considere el exponente",
  "mantissa": "Mantisa",
  "mulMantissa": "Hay que multiplicar la mantisa de ambos números.",
  "solutionIsNan": "La mantisa no se puede calcular porque la entrada lleva a NaN.",
  "solutionIsInf": "La mantisa no se puede calcular porque la entrada lleva al infinito",
  "solutionIsZero": "La mantisa no se puede calcular porque la entrada lleva a cero.",
  "addMantissa": "Hay que sumar la mantisa de ambos números.",
  "divMantissa": "Hay que dividir la mantisa de ambos números",
  "newMantissa": "Nueva mantisa",
  "zeroMantissa": "Ambas mantisas son iguales \\( \\rightarrow \\) la nueva mantisa es la mantisa 0",
  "newMantissaIs": "Por lo tanto la nueva mantisa es",
  "equalMantissa": "Ambas mantisas son iguales \\( \\rightarrow \\) el exponente se incrementará la mantisa permanece",
  "equalMantissaDiv": "Ambas mantisas son iguales, no se ejecutará la división binaria",
  "adjustSmallerMantissa": "Ajuste la mantisa más pequeña",
  "shiftMantissa": "Desplace la mantisa más pequeña",
  "mantissaFloat": "Mantisa dentro del float",
  "mantissa1float": "El 1 inicial no forma parte del float",
  "subtTwosComplement": "La resta es similar a la suma con el complemento a dos",
  "mantissaTwosComplement": "Formación del complemento a dos a partir de la mantisa",
  "switchBits": "Invierta los bits",
  "add1": "Añada  1",
  "normalize": "Normalice",
  "shiftExpMant": "El factor de desplazamiento del exponente debe aplicarse a la mantisa.",
  "shift": "Desplazamiento",
  "considerRepresentation": "Considere la representación",
  "consider1comma": "La mantisa comienza con un 1 en la forma estándar.",
  "ternary": "Número ternario",
  "quaternary": "Número cuaternario",
  "quinary": "Número quintal",
  "senary": "Número hexal",
  "septenary": "Número heptal",
  "octal": "Número octal",
  "novenary": "Número nonal",
  "hexadecimal": "Número hexadecimal",
  "hex": "Hexadecimal",
  "number": "Número",
  "modus": "Modus",
  "summation": "Summation",
  "factor": "Factor",
  "quotient": "Cociente",
  "polyadicExercise2": "del formato inicial:",
  "polyadicExercise3": "al formato de destino:",
  "cmos_infoblob_input_description": "Nota: Para OR se puede usar ' ', para AND '*' y para negación '~'. \nLas variables pueden tener nombres arbitrarios (Atención: 'ab' se considera como una variable, no como 'a' multiplicada por 'b').",
  "contactPersonHeader": "Contacto",
  "herausgeber": "Editorial",
  "impressum": "Pie de imprenta",
  "representedByHeader": "Representado por",
  "representedBy": "La Cátedra de Informática 12 es una institución de derecho público de la Friedrich-Alexander-Universität Erlangen-Nürnberg (FAU). De acuerdo con los artículos 20 y 21 de la BayHSchG, la FAU, como institución estatal y organismo autónomo de derecho público, está representada externamente por el Presidente.",
  "haftungsauschlussHeader": "Descargo de responsabilidad",
  "mantissaComplement": "La mantisa es negativa. Así que tenemos que formar el complemento y poner el bit de signo.",
  "mantissaNormalize": "Para que la mantisa comience con un 1 a la izquierda, necesitamos normalizar la mantisa aplicando el desplazamiento de {shift}. También tenemos que aplicar este desplazamiento al exponente, lo que da como resultado el nuevo exponente {exponente}.",
  "newExponentDivision": "El nuevo exponente resulta como \\( E_{'{neu}'} = E_1 - E_2 + BIAS = %{E1} - %{E2} + %{Bias} = %{Result} \\)",
  "newExponentMultiplication": "El nuevo exponente resulta como \\( E_{'{neu}'} = E_1 + E_2 - BIAS = %{E1} + %{E2} - %{Bias} = %{Result}\\, (%{ExpBits})\\)",
  "haftungsauschlussBody": "Las instituciones respectivas son responsables del contenido de otros sitios web. Toda la información proporcionada en este sitio web ha sido recopilada y comprobada según nuestro leal saber y entender. Sin embargo, no podemos garantizar que la información proporcionada esté actualizada, sea correcta, completa o esté disponible en todo momento. No se establece una relación contractual con los usuarios de la oferta de Internet. No nos hacemos responsables de los daños causados por el uso de este sitio web. Esta exclusión de responsabilidad no se aplica si son pertinentes las disposiciones del artículo 839 del Código Civil alemán (responsabilidad por incumplimiento del deber oficial). No se acepta ninguna responsabilidad por los daños causados por programas maliciosos o por la instalación o el uso de programas informáticos al llamar o descargar datos. Como proveedor de servicios, somos responsables de nuestros propios contenidos en estas páginas de acuerdo con la legislación general según el artículo 7 (1) de la Ley de Telemedia alemana (TMG). Sin embargo, de acuerdo con los artículos 8 a 10 de la TMG, no estamos obligados, como proveedores de servicios, a controlar la información de terceros transmitida o almacenada, ni a investigar las circunstancias que indiquen una actividad ilegal. Las obligaciones de eliminar o bloquear el uso de la información de acuerdo con las leyes generales no se ven afectadas por esto. Sin embargo, la responsabilidad a este respecto sólo es posible a partir del momento en que se conoce una infracción concreta de la ley. Si tenemos conocimiento de tales infracciones, eliminaremos el contenido correspondiente inmediatamente. El operador se reserva expresamente el derecho a modificar, complementar o eliminar páginas web individuales, servicios web o la oferta completa sin previo aviso o a suspender la publicación de forma temporal o permanente.",
  "bf_absorptionUC": "Absorción",
  "bf_einstelle": "Un",
  "bf_einstellen": "Ones",
  "bf_distributionUC": "Distribución",
  "bf_goal_determine_DNF": "Determinar el DNF",
  "bf_goal_determine_KNF": "Determinar el KNF",
  "bf_goal_determine_prime_implicants": "Determinar los implicantes primos",
  "bf_idempotenceUC": "Idempotencia",
  "bf_nullstelle": "Cero",
  "bf_nullstellen": "Ceros",
  "bf_petrickExpression": "Método de Petrick",
  "bf_minimalForms": "Formas mínimas",
  "bf_tableWithCyclicRest": "Mesa con reposo cíclico",
  "colorCoding": "Código de colores",
  "difficultyHard": "Difícil",
  "difficultyUC": "Dificultad",
  "easy": "Fácil",
  "difficultyMiddle": "Medio",
  "doCalculation": "Calcule",
  "goal": "Destino",
  "load": "Cargar",
  "mathDistribution": "Distribución",
  "sheet": "Hoja",
  "startTraining": "Vamos",
  "newMantissaSignBit": "Debido al complemento, calculamos con un bit de signo:",
  "disclaimerFooter": "No se garantiza la exactitud del material proporcionado en este sitio web.",
  "sequentialCircuit": "Ejemplo de un circuito secuencial compuesto por dos D-flipflops y multiplexores.",
  "polyadicMultiplicationDescription": "Los decimales resultan de los dígitos del resto leyéndolos de arriba a abajo.",
  "polyadicDivisionDescription": "Los dígitos que preceden al punto decimal se derivan de los dígitos del resto leyéndolos de abajo a arriba.",
  "enter_cmos": "Por favor, introduzca su fórmula CMOS.",
  "conversionExercise": "Ejercicios de conversión",
  "exerciseArchive": "Archivo de ejercicios",
  "homePageText": "El objetivo de GTI-Online es profundizar en los conocimientos de los temas seleccionados aprendidos en la clase y en el ejercicio correspondiente. Seleccione en el menú un tema y empiece a practicar.",
  "fpExerciseText": "Sean los números de punto flotante \\( fp_1 \\) y \\( fp_2 \\) dados en formato de punto flotante de 16 bits. Calcule el %{op1} \\( fp_1 %{op2} fp_2 \\) sin salir de la representación binaria y déselo de nuevo como un número de punto flotante:",
  "bf_sortingUC": "Clasificación ",
  "polyFreeIntro": "Practique la aritmética poliádica con sus propios valores numéricos en el sistema que desee.",
  "randomExercise": "Ejercicio aleatorio",
  "cmos_infoblob_description": "CMOS es una composición de una red complementaria NMOS (red pull-down, ya que está conectada a tierra) y una red PMOS (red pull-up, ya que está conectada a la tensión de alimentación).\n Como resultado, se consume menos energía en el estado de conmutación fijo, ya que PDN y PUN son complementarias y, por tanto, sólo conducen simultáneamente durante un breve periodo de tiempo durante la conmutación. Sin embargo, se requiere más área en el chip.",
  "bf_bf_primeImplicants_explanation": "Los implicantes primos son términos primos que cubren sólo unos (con don't cares).",
  "bf_conjunctiveMinimalForm": "Forma mínima conjuntiva",
  "bf_conjunctiveMinimalForm_explanation": "Conjunción de literales unidos por disyunción, que no puede simplificarse más (sin violar esta forma) (KNF simplificado).",
  "bf_conjunctiveNormalForm": "Forma normal conjuntiva",
  "bf_normal_forms": "Formas normales",
  "bf_primeTerms": "Términos primos",
  "bf_primeTerms_explanation": "Términos con un número mínimo de literales que cubren sólo unos o ceros.",
  "bf_primeImplicates_explanation": "Los implicados primos son términos primos que cubren sólo ceros (con don't cares).",
  "bf_primeImplicants": "Implicantes primos",
  "bf_primeCoverTable": "Tabla de Cobertura",
  "bf_infotext_kv_must_not_be_empty": "El diagrama KV debe contener unos y ceros",
  "bf_infotext_or_interact_with_kv": "O interactúe directamente con el Diagrama KV",
  "bf_quineMCCluskeyClasses": "Clases de Quine MC Cluskey",
  "bf_infoblob_functionMin": "En esta página puede encontrar diferentes procedimientos para minimizar las expresiones booleanas.",
  "bf_goal_determine_prime_implicates": "Determine los implicados primos",
  "bf_disjunctiveNormalForm_explanation": "La forma normal disyuntiva es una disyunción (combinación de los términos utilizando operadores o) de todos los minitérminos (1s) de una función. Cada minitérmino corresponde exactamente a un 1 en la función, todos las literales deben ocurrir negados o no negados.",
  "bf_infoblob_quineMCCluskeyClasses_01": "Normalmente, escribimos los mínimos o máximos en las clases individuales. Alternativamente, también podemos trabajar con 0s (para las literales negados) y 1s (para las literales no negados), por lo que la posición de éstos determina de qué literal se trata.",
  "bf_primeImplicates": "Implicados primos",
  "bf_infotest_click_on_hidden_areas_to_make_visible": "Haz clic en las zonas ocultas para revelarlas",
  "bf_infoblob_random_exercise_selection": "La dificultad indica cuántos términos individuales de algún tipo (por ejemplo, minitérminos, implicantes primos) debe producir la función booleana.",
  "bf_infoblob_petrick_statement": "El algoritmo consta de dos fases:<ol><li>Haga que los términos que se absorben entre sí sean fácilmente visibles mediante la ordenación (sólo se muestra si tiene algún efecto).</li><li>Multiplique los dos primeros términos entre sí hasta que quede la suma típica.</li></ol>",
  "bf_disjunctiveNormalForm": "Forma normal disyuntiva",
  "bf_disjunctiveMinimalForm": "Forma mínima disyuntiva",
  "bf_conjunctiveNormalForm_explanation": "La forma normal conjuntiva es una conjunción (combinación de los términos usando AND operadores) de todos los maxitérminos (0s) de una función. Los 0s no se seleccionan en los maxitérminos (como los 1s en los minitérminos), sino que se excluyen. Cada maxitérmino corresponde exactamente a un 0 en la función, todos las literales deben ocurrir negados o no negados.",
  "bf_covertable_step_description_core_found": "<h4>Núcleo encontrado:</h4>El único término primo que cubre la columna {columnName} es el término {rowName}. Por lo tanto, ¡este término primo debe aparecer definitivamente en nuestra función resultante! Marque la fila como \"núcleo\" (Kern) y tache la columna.",
  "bf_covertable_step_description_cross_row_bc_covered": "<h4>Fila ya cubierta:</h4>Todas las X de la fila {rowName} ya están cubiertas. Tache la fila.",
  "bf_covertable_step_description_initial": "<h4>Paso inicial:</h4>T Introduce todos los términos base en las columnas y todos los términos primos (PI) en las filas de la tabla. Si un término primo cubre un {ifMinTermsEinstelleElseNullstelle}, marque esa celda con una X. El coste c de un primo es el número de sus literales. Cuanto mayor sea, más compleja (es decir, costosa) será la implementación en hardware. <br>Consejo:<br> Un implicante primo cubre un 'UNO' exactamente si todos las literales del término primo también ocurren de la misma manera en el término base.",
  "bf_quineMCCluskeyClasses_explanation": "El algoritmo de Quine/McCluskey es un algoritmo de minimización con el que se pueden determinar los términos primos de una función.",
  "bf_infoblob_quineMCCluskeyClasses_colorCoding": "Todos los términos utilizados en la reducción están normalmente tachados en el algoritmo Quine/McCluskey. Si la codificación por colores está activa, se muestran en gris claro en su lugar.",
  "bf_covertable_step_description_cross_column_bc_covered": "<h4>Columna ya cubierta:</h4> La columna {columnName} ya está siendo cubierta por término primo {rowName}. Tacha la columna",
  "bf_disjunctiveMinimalForm_explanation": "Disyunción de literales unidos por la conjunción, que no puede simplificarse más (sin violar esta forma) (DNF simplificado).",
  "bf_covertable_step_description_column_domination": "<h4>Dominio de columna:</h4>La columna {dominatorName} domina la columna {dominatedName}; es decir, la columna {dominatorName} tiene marcadores allí donde la columna {dominatedName} también los tiene (¡y posiblemente más!). => Cruzar la columna dominante {dominatorName}<br>A diferencia de lo que ocurre con el dominio de filas, el dominio de columnas no requiere que se consideren los costes en absoluto.",
  "bf_covertable_step_description_row_domination": "<h4>Dominio de fila:</h4>La fila {dominatorName} domina la fila {dominatedName}; es decir, la fila {dominatorName} tiene marcadores donde la fila {dominatedName} también los tiene (¡y posiblemente más!). => cruza la fila dominada {dominatedName}. <br>Tenga en cuenta que la dominación de la fila sólo es aplicable, porque la fila {dominatorName} cuesta menos que, o lo mismo que {dominatedName}; o porque no hay ninguna otra fila que cubra los marcadores adicionales de {dominatorName} y cuesta menos que {dominatorName} - {dominatedName}.",
  "bf_covertable_step_description_cyclic_rest": "<h4>Resto cíclico:</h4> Ninguna regla del algoritmo de la tabla de primos es aplicable. Esto se denomina \"resto cíclico\" (ger: \"Zyklischer Rest\"). Al establecer la expresión de Petrick (ger: Petrick Ausdruck) para la tabla de reposo, uno todavía es capaz de determinar una forma mínima de la función original.",
  "PowerToPower": "Convertimos un sistema numérico arbitrario en otro en dos pasos a través del sistema decimal. Al principio, el número original se transfiere al sistema decimal resumiendo los dígitos potenciados. En el segundo paso, utilizamos el algoritmo de división y multiplicación para crear el número resultante.",
  "PowerToTen": "Un sistema numérico arbitrario puede convertirse al sistema decimal resumiendo todos los dígitos potenciados.",
  "calcStep": "Paso\\ de\\ cálculo",
  "divisionAlgorithm": "Algoritmo de división",
  "newBasis": "Base_{'{nueva}'}",
  "noValuesAfterComma": "No hay valores después de la coma. Por lo tanto, se puede omitir el algoritmo de multiplicación.",
  "polyadicExercise1": "Convierta el valor de",
  "representation": "Representación en formato original",
  "secondToPower": "2. Conversión mediante el algoritmo de división y multiplicación",
  "shortcutHexToBin": "En la conversión de hexadecimal a binario, los valores se pueden leer directamente.",
  "summands": "Sumandos",
  "multiplicationAlgorithm": "Algoritmo de multiplicación",
  "secondFormat": "Formato del objetivo",
  "shortcutBinToHex": "En la conversión de binario a hexadecimal, los valores se pueden leer directamente.",
  "firstToTen": "1. Suma de los dígitos potenciados",
  "firstFormat": "Formato inicial",
  "doConversion": "Convierta:",
  "to": "a",
  "TenToPower": "La conversión del sistema decimal a uno arbitrario se realiza en dos pasos. Antes de la coma, los dígitos se convierten con el uso del algoritmo de la división. Después de la coma, se aplicará el algoritmo de multiplicación.",
  "remainder": "Resto",
  "noValuesBeforeComma": "No hay valores delante de la coma. Por lo tanto, se puede omitir el algoritmo de división.",
  "systemInBase": "Sistema de base",
  "basis": "Base",
  "minterms": "Minitérminos",
  "maxterms": "Maxitérminos",
  "impressumText": "Puede encontrar el pie de imprenta en:",
  "and": " y",
  "weThank": "Nos gustaría agradecer a las siguientes personas su ayuda en la creación de este sitio web:",
  "Danksagung": "Agradecimiento",
  "thankProfessorTeich": "Los materiales de esta página se basan en la lección de la GTI impartida por el profesor Dr.-Ing. Jürgen Teich de la Friedrich-Alexander-Universität (FAU). Le agradecemos su experiencia y patrocinio.",
  "wintersemester": "Semestre de invierno",
  "sommersemester": "Semestre de verano",
  "downloadSvg": "Exportar como SVG",
  "downloadPng": "Exportar como PNG",
  "formula": "Fórmula",
  "divByZero": "La división por 0 da NaN"
}
