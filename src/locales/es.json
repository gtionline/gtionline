{
  "fpExerciseIntro": "Practicar aritmética entre números de punto flotante en formato IEEE-754 utilizando tareas generadas",
  "fpFormatSelectionSimple": "Para seleccionar un formato personalizado, especifica la distribución de bits entre los exponentes y la mantisa",
  "fpFormatSelection": "Para seleccionar su propio formato, seleccione primero el número de bits del número en coma flotante y luego especifique la distribución de bits entre los exponentes y la mantisa",
  "fpArithIntro": "Practique la aritmética entre números de punto flotante en el formato según IEEE-754 o un formato autodefinido basado en él",
  "fpConvIntro": "Practique la conversión entre el sistema decimal y el formato de números de punto flotante según IEEE-754 o un formato autodefinido basado en él, utilizando ejercicios generados",
  "polyConvIntro": "Practica la conversión entre sistemas poliádicos que puedes elegir libremente.",
  "polyConvGenIntro": "Practique la conversión entre sistemas poliádicos resolviendo los ejercicios generados.",
  "numVarInput": "Número de variables",
  "confirm": "Confirmar",
  "input": "Entrada",
  "varNaming": "Nombramiento variable",
  "kvDiagram": "Mapa de Karnaugh",
  "numeralSystem": "Sistema de numeración",
  "polyadic": "Poliádico",
  "floatingPoint": "Coma Flotante",
  "functionMin": "Minimización",
  "exercises": "Ejercicios",
  "generateEx": "Generar Ejercicio",
  "generate": "Generar",
  "addition": "Adición",
  "subtraction": "Sustracción",
  "multiplication": "Multiplicación",
  "division": "División",
  "solution": "Solución",
  "ownSolution": "Solución propia",
  "signBit": "Bit de signo",
  "correctSolution": "Solución",
  "exponentBits": "Exponente",
  "fractionBits": "Significando",
  "attRound": "¡No te olvides de redondear!",
  "attSolve": "¡Por favor, intente resolver el ejercicio de antemano!",
  "step": "Paso",
  "freeCalculation": "Cálculo libre",
  "operationSelect": "Configurar la computación",
  "firstFloatingPoint": "Primer número de punto flotante",
  "secondFloatingPoint": "Segundo número de punto flotante",
  "operand": "Operand",
  "decimal": "Decimal",
  "binary": "Binario",
  "inputNumber": "Introduce el número",
  "fpformat": "Formato de punto flotante",
  "check": "Comprobar",
  "values": "valore",
  "arithmetic": "Aritmética",
  "conversion": "Conversión",
  "conversionExercise1": "Convertir: ",
  "conversionExercise2": "en un número de punto flotante IEEE con una longitud de exponente de ",
  "steps": "pasos",
  "repeatMinuend": "repeat\\ minuend",
  "doDivision": "realiza una división",
  "doMultiplication": "realiza una multiplicación",
  "getDescription": "Imprimir",
  "approach": "Procedimiento",
  "gti": "Fundamentos de la informática técnica",
  "disclaimer": "Disclaimer:<br>This is an automatically generated solution approach by the GTI-Online-Website. Every output is completely <u>unofficial</u> and in the drafts state.<br>We are making lots of efforts to build a correct and reliable tool for you. Regardless, there may be failures in the solution or approach. That can especially depend on your browser version. Please review before using it for instance in an exam.",
  "example": "Ejemplo",
  "composition": "composición",
  "negativeSummand": "Una suma con valor negativo es similar a una resta",
  "negativeSubtrahend": "Un sustraendo negativo es similar a un sumando positivo",
  "negativeMinuendSubtrahend": "Simplificación para el caso \\( - x - y \\rightarrow - (x + y) \\)",
  "addWithZero": "Una suma con 0 da como resultado el otro sumando",
  "subConCero": "Una resta con 0 da como resultado el otro valor",
  "mulConCero": "Una multiplicación con 0 da como resultado siempre 0",
  "divWithZero": "Una división con 0 en el numerador da como resultado siempre 0",
  "zeroDivision": "¡Una división por 0 es ilegal!",
  "arithmeticFree": "Aritmética libre",
  "conversionFree": "Conversión Libre",
  "value": "valor",
  "givenValues": "valores de los números transmitidos",
  "leftValue": "el valor de la izquierda",
  "rightValue": "el valor de la derecha",
  "firstSummand": "1. sumario",
  "secondSummand": "2. sumario",
  "firstFactor": "1. factor",
  "secondFactor": "2. factor",
  "minuend": "minucioso",
  "subtrahend": "restando",
  "numerator": "numerador",
  "denominator": "denominador",
  "sign": "firma",
  "exponent": "exponente",
  "adjustExponents": "Los exponentes de ambos números deben estar equilibrados.",
  "addExponents": "Hay que sumar los exponentes de ambos números.",
  "subtExponents": "Hay que restar los exponentes de ambos números.",
  "diffExponent": "diferencia de los exponentes",
  "smallerExponent": "El exponente menor se restará del mayor",
  "resDiffExponent": "de ahí que esta diferencia resulte",
  "newExponent": "nuevo exponente",
  "considerExponent": "considere el exponente",
  "mantissa": "mantisa",
  "mulMantissa": "Hay que multiplicar la mantisa de ambos números.",
  "solutionIsNan": "La mantisa no se puede calcular porque la entrada lleva a NaN.",
  "solutionIsInf": "La mantisa no se puede calcular porque la entrada lleva al infinito",
  "solutionIsZero": "La mantisa no se puede calcular porque la entrada lleva a cero.",
  "addMantissa": "Hay que sumar la mantisa de ambos números.",
  "divMantisa": "Hay que dividir la mantisa de ambos números",
  "newMantissa": "nueva mantisa",
  "zeroMantissa": "ambas mantisas son iguales \\( \\rightarrow \\) la nueva mantisa es la mantisa 0",
  "newMantissaIs": "Por lo tanto la nueva mantisa es",
  "equalMantissa": "Ambas mantisas son iguales \\( \\rightarrow \\) el exponente se incrementará la mantisa permanece",
  "equalMantissaDiv": "Ambas mantisas son iguales, no se ejecutará la división binaria",
  "adjustSmallerMantissa": "Ajustar la mantisa más pequeña",
  "shiftMantissa": "Desplazar la mantisa más pequeña",
  "mantissaFloat": "Mantisa dentro del float",
  "mantissa1float": "El 1 inicial no forma parte del float",
  "subtTwosComplemento": "La resta es similar a la suma con el complemento a dos",
  "mantissaTwosComplement": "Formación del complemento a dos a partir de la mantisa",
  "switchBits": "invert bits",
  "add1": "add 1",
  "normalize": "normalize",
  "shiftExpMant": "The exponent's shift factor must be applied to the mantissa.",
  "shift": "shift",
  "considerRepresentation": "consider representation",
  "consider1comma": "The mantissa begins with an 1 in the standard form.",
  "ternary": "ternary",
  "quaternary": "quaternary",
  "quinary": "quinary",
  "senary": "senary",
  "septenary": "septenary",
  "octal": "octal",
  "novenary": "novenary",
  "hexadecimal": "hexadecimal",
  "hex": "hexadecimal",
  "number": "number",
  "representation": "representation in original format",
  "firstFormat": "Initial format",
  "secondFormat": "target format",
  "doConversion": "Convert:",
  "modus": "modus",
  "to": "to",
  "TenToPower": "The conversion from the decimal system to an arbitrary one goes in two steps. Before the comma, the digits were converted with the use of the division algorithm. After the comma, the multiplication algorithm will be applied.",
  "PowerToTen": "An arbitrary number system can be converted to the decimal system by summarizing all potentiated digits.",
  "PowerToPower": "We convert an arbitrary number system into another within two steps via the decimal system. At first, the original number will be transferred into the decimal system be summarizing the potentiated digits. In the second step, we use the division- and multiplication algorithm to create the resulting number.",
  "noValuesBeforeComma": "There are no values in front of the comma. Therefore, the division algorithm can be skipped.",
  "noValuesAfterComma": "There are no values after the comma. Therefore, the multiplication algorithm can be skipped.",
  "firstToTen": "1. Summation of the potentiated digits",
  "secondToPower": "2. Conversion via division- and multiplication algorithm",
  "shortcutBinToHex": "At the conversion from binary to hexadecimal, the values can be read directly.",
  "shortcutHexToBin": "At the conversion from hexadecimal to binary, the values can be read directly.",
  "divisionAlgorithm": "Division algorithm",
  "multiplicationAlgorithm": "Multiplication algorithm",
  "summation": "Summation",
  "factor": "factor",
  "quotient": "quotient",
  "remainder": "remainder",
  "newBasis": "new basis",
  "calcStep": "calculation\\ step",
  "summands": "summands",
  "polyadicExercise1": "Convert the value:",
  "polyadicExercise2": "from the initial format: ",
  "polyadicExercise3": "to the target format:",
  "cmos_infoblob_input_description": "Nota: Para OR se puede usar ' ', para AND '*' y para negación '~'. \nLas variables pueden tener nombres arbitrarios (Atención: 'ab' se considera como una variable, no como 'a' multiplicada por 'b')."
}
