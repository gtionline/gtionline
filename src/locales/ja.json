{"complementExample": "相補計算", "shiftZero": "シフト後の仮数ゼロ", "doubleNegative": "ネガティヴ", "denormalized": "非正規化", "fpExerciseIntro": "IEEE-754に準拠した浮動小数点演算を自動生成されたタスクで練習することができます。", "fpFormatSelectionSimple": "指数部と仮数部のビット数を選択します。", "fpFormatSelection": "浮動小数点数のビット幅を定義し、指数部と仮数部のビット数を選択します。", "fpArithIntro": "IEEE-754またはそれに基づく自己定義フォーマットによる浮動小数点演算を実践する。", "fpConvIntro": "10進法とIEEE-754またはそれに基づく自己定義フォーマットによる浮動小数点数フォーマットとの変換を、作成した演習問題で練習することができます。", "sequentialCircuit": "2つのD-フリップフロップと複数のマルチプレクサで構成されるスイッチング機構の例。", "polyadicDivisionDescription": "小数点の前の桁は、余りの桁を下から上に読んで導きます。", "polyadicMultiplicationDescription": "小数点以下は、余りの桁を上から下へ読むと出てきます。", "homePageText": "このサイトでは、「コンピュータ工学の基礎（GTI）」の講義から厳選したトピックと、関連する演習の知識を深めることができます。", "startTraining": "レッツゴー", "polyFreeIntro": "自分の好きな方式の数値で多項式計算の練習をする。", "polyConvGenIntro": "生成された練習問題で多項式間の変換を練習する。", "polyConvIntro": "自由に選べる多項式間の変換練習をする。", "numVarInput": "変数数", "conversionExercise": "変換タスク", "impressum": "インプレッサ", "copyright": "FAUコンピュータサイエンス学科長。無断転載を禁じます。", "herausgeber": "出版社", "disclaimerFooter": "本ウェブサイトで提供される資料の正確性については、いかなる保証もいたしません。", "representedByHeader": "代表者名", "contactPersonHeader": "お問い合わせ先", "representedBy": "コンピュータサイエンス12番教室は、フリードリヒ・アレクサンダー大学エアランゲン・ニュルンベルク校（FAU）内の公法上の機関です。BayHSchGの第20条および第21条に従い、FAUは、公的機関に属する自治団体として、学長が対外的な代表を務めています。", "haftungsauschlussHeader": "免責事項", "haftungsauschlussBody": "他のウェブサイトの内容については、それぞれの機関が責任を負います。本ウェブサイトで提供されるすべての情報は、当社が知り、信じる限りにおいて、編集・確認されたものです。しかしながら、当社は、提供する情報が最新であること、正確であること、完全であること、または常に利用可能であることを保証するものではありません。インターネット提供の利用者との契約関係は生じない。本ウェブサイトをご利用になったことにより生じるいかなる損害についても、当社は一切責任を負いません。この免責は、ドイツ民法典第839条（公序良俗違反に対する責任）の規定が関連する限り、適用されません。データの呼び出しやダウンロードを行う際に、マルウェアやソフトウェアのインストールや使用によって生じた損害については、当社は一切の責任を負いません。サービス提供者である当社は、一般法第7条第1項TMG（ドイツ・テレメディア法）に基づき、これらのページにおける当社自身のコンテンツに責任を負います。ただし、ドイツ連邦共和国政令第8条から10条に基づき、当社はサービス提供者として、送信または保存された第三者の情報を監視したり、違法行為を示唆する状況を調査したりする義務はありません。一般的な法律に従って情報の削除や使用を阻止する義務は影響を受けません。ただし、この点に関する責任は、具体的な侵害の事実を知った時点からしか生じません。該当する法令違反が判明した場合、当社は直ちにこのコンテンツを削除します。運営者は、個別の通知なしに、個々のウェブページ、ウェブサービスまたは提供物全体を変更、補足または削除する権利、あるいは一時的または恒久的に公開を停止する権利を明示的に留保します。", "confirm": "確認", "varNaming": "変数の命名", "kvDiagram": "CT図", "numeralSystem": "ナンバーシステム", "polyadic": "ポリアディック", "floatingPoint": "浮動小数点数", "functionMin": "関数最小化", "exercises": "演習", "generateEx": "タスクの生成", "generate": "生成する", "addition": "追加", "subtraction": "引き算", "multiplication": "乗算", "division": "事業部", "ownSolution": "独自のソリューション", "signBit": "符号ビット", "correctSolution": "かいけつほうほう", "solution": "解決方法", "exponentBits": "指数", "fractionBits": "マンティス", "attRound": "ラウンドをお忘れなく", "attSolve": "事前に自主的に課題を解いてみてください", "step": "ステップ", "freeCalculation": "無料計算", "operationSelect": "手術の選択", "firstFloatingPoint": "最初の浮動小数点数", "secondFloatingPoint": "2番目の浮動小数点数", "operand": "オペランド", "decimal": "10進数", "binary": "2進数", "inputNumber": "番号を入力する", "fpformat": "浮動小数点演算のフォーマット", "check": "チェック", "values": "価値観", "load": "ショップ", "arithmetic": "算術", "conversion": "変換", "conversionExercise1": "変換してください。 ", "conversionExercise2": "の指数長を持つIEEE浮動小数点数値に変換する。 ", "steps": "ステップス", "repeatMinuend": "リピート\\ミニエンド", "doDivision": "パフォーム部門", "doMultiplication": "乗算を行う", "getDescription": "プリント", "approach": "かいけつほうほう", "gti": "コンピュータ工学の基礎", "disclaimer": "免責事項<br>：これは、GTI Onlineのウェブサイトを通じて自動的に生成されたソリューションパスです</br>。<br>また、この解決策は<u>非公式な</u>ものであり、正確性を保証するものではありません。<br>私たちは、お客様のために信頼性の高い正しいツールを開発するために、多大な労力を費やしています。とはいえ、解答経路や解答自体に誤りがある場合もある。また、ブラウザのバージョンによっても異なる場合があります。試験などで使用する際は、事前に解答を確認してください。</br></br>", "example": "例", "composition": "構成", "negativeSummand": "負の値を持つ加算は、減算と同様に扱われる。", "negativeSubtrahend": "負の下辺は正の上辺と同じ効果があります。", "negativeMinuendSubtrahend": "の場合の簡便法\\( - x - y \\rightarrow - (x + y) \\)", "addWithZero": "0を使った足し算では、もう一方の和が変化することはない。", "subWithZero": "0の引き算は、最小値を変更しません。", "divWithZero": "分子に0を含む除算があった場合、結果は0となる。", "mulWithZero": "0を掛けると、結果は常に0になります。", "zeroDivision": "0による除算は不可能です", "arithmeticFree": "自由な算数", "conversionFree": "無償変換", "value": "価値", "givenValues": "送信番号の値", "leftValue": "残数", "rightValue": "ナンバーライト", "firstSummand": "1.加算", "secondSummand": "2.2.Summand", "firstFactor": "ファクター1", "secondFactor": "ファクター2", "numerator": "カウンター", "denominator": "分母", "minuend": "ミニエンド", "subtrahend": "サブラヘンド", "sign": "サイン", "exponent": "指数", "adjustExponents": "両数値の指数を調整する必要があります。", "addExponents": "両方の数値の指数を足し合わせる必要があります。", "subtExponents": "両方の数値の指数を引き算する必要があります。", "diffExponent": "差分指数", "smallerExponent": "小さい方の指数は常に大きい方の指数から減算されます。", "resDiffExponent": "したがって、その差は", "newExponentDivision": "新しい指数は次のように与えられます。 \\( E_{'{new}'} = E_1 - E_2 + BIAS = %{E1} - %{E2} + %{Bias} = %{Result} \\)", "newExponentMultiplication": "新しい指数は、次のように与えられます。\\( E_{'{neu}'} = E_1 + E_2 - BIAS = %{E1} + %{E2} - %{Bias} = %{Result}\\, (%{ExpBits})\\)", "considerExponent": "注釈 指数", "fpExerciseText": "浮動小数点数\\(fp_1\\)と\\(fp_2\\)を16bit浮動小数点形式で与えましょう。2進表現のままで%{op1} \\( fp_1 %{op2} fp_2 \\) を計算し、結果を再び浮動小数点数で与えます。", "mantissa": "マンティス", "solutionIsNan": "結果は確実にNaNなので仮数を計算する必要はない。", "solutionIsInf": "結果は確実に無限大なので、仮数を計算する必要はありません。", "solutionIsZero": "結果は確実に0なので、仮数を計算する必要はありません。", "mulMantissa": "両方の数値のマンティサを掛け合わせる必要があります。", "addMantissa": "両方の数字のマンティサを足す必要があります。", "divMantissa": "両数値のマンティサスを分割する必要があります。", "newMantissa": "新しい仮数", "zeroMantissa": "仮数は同一である \\( \\rightarrow \\) 新仮数は0仮数である", "newMantissaIs": "そこで、次のように計算します。", "newMantissaSignBit": "補数の関係で、符号ビットで計算する。", "equalMantissa": "仮数は同じで、指数を1増やしただけ( ˶ˆ꒳ˆ˵ )", "equalMantissaDiv": "2つのマンティサは等しいので、2進法の除算は行いません。仮数は%{Mantissa}とする。", "adjustSmallerMantissa": "仮数を調整する", "shiftMantissa": "仮数部のシフト", "mantissaFloat": "浮動小数点数の仮数", "mantissaNormalize": "仮数が先頭の1から始まるようにするには、{shift}のシフトを適用して仮数を正規化する必要があります。また、このシフトを指数に適用して、新しい指数{exponent}を得る必要があります。", "mantissaNormalizeDenorm": "その結果は、シフト{shift}を用いた正規化表現では表現できないので、指数{exponent}を用いた非正規化表現を用いる。", "mantissaDenormalize": "シフトをかけると負の指数になるので、結果を表示するには、非正規化表現を使わなければならない。そのため、指数を完全に0にし、先頭の1も含めて仮数を指数分だけシフトさせる。仮数には先行するゼロを仮定する。", "mantissa1float": "最後に、仮数の先頭桁を削除して、IEEE-754表現の仮数ビットを得る。したがって、仮数ビットは", "mantissaComplement": "仮数は負とする。そこで、補数を形成し、符号ビットを設定する必要があります。", "subtTwosComplement": "引き算は、2の補数による加算に対応する", "mantissaTwosComplement": "仮数から2の補数を形成する。", "switchBits": "ビットを反転させる", "add1": "1加算", "normalize": "ノーマライズ", "shiftExpMant": "指数のシフトファクターは、マンティサスに適用する必要があります。", "shift": "シフト", "considerRepresentation": "注釈表示", "consider1comma": "仮数は標準表現では常に小数点の前の1（非正規化された場合は0）で始まる。", "ternary": "三元数", "quaternary": "第四世代数", "quinary": "クインタルナンバー", "senary": "六角番号", "septenary": "ヘプタールシステム", "octal": "8進数", "novenary": "ノナル数", "hexadecimal": "16進数", "hex": "十六進法", "input": "入力", "number": "番号", "representation": "出力フォーマットの再現性", "firstFormat": "出力フォーマット", "secondFormat": "対象フォーマット", "doConversion": "変換を行う。", "modus": "モデュス", "to": "まで", "TenToPower": "10進法から他の多進法に変換する場合、小数点の前に除算アルゴリズムが、小数点の後に乗算アルゴリズムが適用されます。", "PowerToTen": "任意のシステムの10進法への変換は、指数化された桁を合計することで行われます。", "PowerToPower": "ある数体系から別の数体系への変換は、2つのステップで行われる。まず、原始系の数字を足し算して10進数に移します。そして、この10進数は、小数点以下の桁を逐次除算し、小数点以下の桁を逐次乗算することで目的系に変換される。", "noValuesBeforeComma": "小数点以下の数値がない。除算アルゴリズムは省略可能", "noValuesAfterComma": "小数点以下の数値がない。乗算のアルゴリズムは省略可能", "firstToTen": "1. 指数化された数字を合計する", "secondToPower": "2.除算・乗算アルゴリズムによる変換", "shortcutBinToHex": "バイナリから16進数に変換する場合、値を直接読み取ることができます。", "shortcutHexToBin": "16進数から2進数に変換する場合、値を直接読み取ることができる。", "divisionAlgorithm": "整数部（除算アルゴリズム）", "multiplicationAlgorithm": "小数点以下の桁数（乗算アルゴリズム）", "summation": "加算する", "factor": "ファクター", "quotient": "商", "remainder": "休息", "newBasis": "Base_{'{new}'}を使用します。", "calcStep": "計算ステップ", "summands": "スマンド", "polyadicExercise1": "を変換する。", "polyadicExercise3": "にしています。 ", "exerciseArchive": "タスクアーカイブ", "randomExercise": "ランダムタスク", "doCalculation": "計算する", "colorCoding": "色分けについて", "mathDistribution": "ディストリビューター", "easy": "徒に", "difficultyMiddle": "巫女", "difficultyHard": "ヘビー", "sheet": "シート", "goal": "目的地", "difficultyUC": "難易度", "bf_infotext_or_interact_with_kv": "またはKV図と直接対話する", "bf_infotext_kv_must_not_be_empty": "KVダイアグラムは1と0を含むこと", "bf_infotest_click_on_hidden_areas_to_make_visible": "隠れた部分をクリックすると、その部分が表示されます", "bf_normal_forms": "正規形", "bf_disjunctiveNormalForm": "選言的正規形", "bf_conjunctiveNormalForm": "接続型正規形", "bf_disjunctiveMinimalForm": "選言的最小形式", "bf_conjunctiveMinimalForm": "接続可能な最小形態", "bf_quineMCCluskeyClasses": "クワイン・マクルスキークラス", "bf_primeTerms": "プリムテルム", "bf_primeImplicants": "プリムプリカンツ", "bf_primeImplicates": "プリムプリケート", "bf_primeCoverTable": "オーバーラップテーブル", "bf_petrickExpression": "ペトロール表現", "bf_minimalForms": "ミニマムフォーム", "bf_tableWithCyclicRest": "巡回残差表", "bf_einstelle": "エントリーポイント", "bf_nullstelle": "ゼロ", "bf_einstellen": "勤務地", "bf_nullstellen": "ゼロ", "bf_goal_determine_DNF": "DNFを決定する", "bf_goal_determine_KNF": "KNFを決定する", "bf_goal_determine_prime_implicants": "素因数分解を行う", "bf_goal_determine_prime_implicates": "プライムインプリケートの決定", "bf_covertable_step_description_initial": "<h4>最初の手順：</h4>すべての基本語（{ifMinTermsSetElseNull}）を列に、すべての主要語（PI）を行に、テーブルに入力します。ifMinTermsEinstelleElseNullstelle}を素項が覆っている場合、そのセルに×印をつける。コストcはすべての素項（{ifMinTermsEinstellenElseNullstelle}）を合計したものである。素数項のコストcは、そのリテラルの数である。数字が大きくなるほど、ハードウェアで実装する際のコストが高くなる。<br>ヒント：<br>プリムプリカントは、プリム項のすべてのリテラルがベース項にも同じように出現する場合に、ON桁を正確にカバー</br>します。</br>", "bf_covertable_step_description_core_found": "<h4>Core found:</h4>{ifMinTermsElseNull}をカバーする唯一の素性項。{columnName}は{rowName}の項である。だから、この素性項は、スイッチング関数に絶対に登場しなければならないのです行をコアとマークし、列をクロスする。", "bf_covertable_step_description_cross_column_bc_covered": "<h4>Column already covered:</h4>{ifMinTermsSetElseNullSets}{columnName}は、素性項{rowName}によってすでにカバーされています。欄を消してください。", "bf_covertable_step_description_cross_row_bc_covered": "<h4>Row already fully covered:</h4>行{rowName}のすべてのXはすでにカバーされています。列を消してください。", "bf_covertable_step_description_row_domination": "線分支配<h4>：</h4>線分{dominatorName}は線分{dominatedName}を支配する。すなわち、線分{dominatedName}にもマーカーがあるところ（あるいはもっとあるかもしれないところ）に{dominatorName}はマーカーを有する。=&gt; 支配された行{dominatedName}を削除します。<br>行の優位性は、行{dominatorName}のコストが{dominatedName}よりも低いか同じであるか、または{dominatorName}の追加桁をカバーし、{dominatorName} - {dominatedName}よりも低いコストの他の行が存在しない場合にのみ適用できることに留意してください。</br>", "bf_covertable_step_description_column_domination": "カラムの優位性<h4>：</h4>カラム {dominatorName} はカラム {dominatedName} を優位に保ちます。つまり、カラム {dominatedName} にもマーカーがある場所（あるいはそれ以上）には {dominatorName} にもマーカーがあるということです。=&gt; 支配する列 {dominatorName} を削除します。<br>行の</br>支配とは<br>対照的に</br>、<br>列の支配ではコストを考慮する必要は全くありません (/â-½ï¼¼</br>) 。", "bf_covertable_step_description_cyclic_rest": "<h4>周期的余り：</h4>オーバーラップテーブルのルールは適用されない。これを「周期的余り」という。<br>切り替え関数の最小形式を決定できるようにするために、ペトリック式をリストアップすることが可能であり、それによって、まだクロスアウトされていない行と列のみが入力されることになる。</br>", "bf_infoblob_random_exercise_selection": "選択された難易度は、一種類の項（mintermsやprime implicantsなど）をいくつ含むべきかを決定します。", "bf_infoblob_petrick_statement": "このアルゴリズムは、2つのフェーズで構成されています。<ol><li>できるだけ多くのものを吸収できるように用語を並べ替えてください。</li><li>項を掛け合わせる。</li></ol>", "bf_distributionUC": "流通", "bf_idempotenceUC": "イデムポテンツ", "bf_absorptionUC": "吸収量", "bf_sortingUC": "ソート", "bf_infoblob_functionMin": "関数最小化のさまざまな手順を練習する", "bf_disjunctiveNormalForm_explanation": "分離正規形とは、ある関数のすべてのminterms（1s）の論理和（veroderung）である。各mintermは関数内のちょうど1つの1に対応する。すべてのリテラルはその中で否定されるか、否定されないかでなければならない。", "bf_conjunctiveNormalForm_explanation": "結合正規形は、関数のすべての項（0）を結合したものである。maxtermsでは0は（mintermsの1のように）選択されず、除外される。各maxtermは関数内のちょうど1つの0に対応する。すべてのリテラルはその中で否定されるか、否定されないかでなければならない。", "bf_quineMCCluskeyClasses_explanation": "Quine/McCluskey法は、関数の素項を決定する最小化法である。", "bf_infoblob_quineMCCluskeyClasses_colorCoding": "Quine/McCluskeyの手順では、通常、縮小された用語には取り消し線が引かれている。色分けが有効な場合は、代わりにライトグレーで表示されます。 ", "bf_infoblob_quineMCCluskeyClasses_01": "通常、個々のクラスでmin-やmaxtermsを書く。また、0（否定されたリテラル）と1（否定されないリテラル）を使って、これらの位置によってどちらのリテラルであるかを決定することもできます。", "bf_primeTerms_explanation": "最小限のリテラル数で、1または0のみをカバーする条件。 ", "bf_bf_primeImplicants_explanation": "プリミティブは、1つの位置だけをカバーするプリミティブです（クロッピングあり）。 ", "bf_primeImplicates_explanation": "プライムインプリケートとは、ゼロだけをカバーする（空孔を持つ）素数項である。 ", "bf_disjunctiveMinimalForm_explanation": "接続詞で結ばれたリテラルのディスジャンクション。これは（この形式に反しない限り）これ以上単純化できない（単純化DNF）。", "bf_conjunctiveMinimalForm_explanation": "ディスジャンクションで結ばれたリテラル同士の接続。これをさらに（本形式に反しない範囲で）簡略化することはできない（簡略化KNF）。", "cmos_infoblob_description": "CMOSは、相補的なNMOSスイッチングネットワーク（プルダウンネットワーク、グランドに接続）とPMOSスイッチングネットワーク（プルアップネットワーク、電源電圧に接続）を組み合わせたものである。その結果、PDNとPUNは相補的であるため、スイッチング時に短時間しか同時に導通しないため、固定スイッチング状態での消費電力は少なくなります。しかし、チップ上でより多くの面積を必要とします。", "cmos_infoblob_input_description": "注）ORゲートには「＋」、ANDゲートには「*」、否定には「~」を使用することができる。変数は任意の名前を持つことができる（注意：入力の'ab'は変数として解釈され、'a'と'b'の合成とはみなされない）。", "enter_cmos": "CMOSの入力を行ってください。", "polyadicExercise2": "を初期フォーマットから変更しました。", "newExponent": "新指数", "systemInBase": "ベースへのシステム", "basis": "ベース", "minterms": "ミンテルム", "maxterms": "マックスターム", "contact": "お問い合わせ先", "impressumText": "下に刻印があります。 ", "and": "と", "weThank": "本サイトの作成にあたり、以下の方々にご協力いただきました。", "Danksagung": "謝辞", "thankProfessorTeich": "本ページの資料は、フリードリヒ・アレクサンダー大学（FAU）のJörgen Teich教授による講演「GTI」をもとに作成されています。彼の専門知識と愛顧に感謝します。", "wintersemester": "冬学期", "sommersemester": "夏学期", "downloadSvg": "SVGの書き出し", "downloadPng": "PNGの書き出し", "formula": "式", "divByZero": "0で割るとNaNになります。", "falseFormat": "フォーマットが違う"}