{"complementExample": "Cálculo complementar", "shiftZero": "Mantissa zero após o turno", "doubleNegative": "Negativ", "denormalized": "Desnormalização", "fpExerciseIntro": "Praticar aritmética de ponto flutuante de acordo com IEEE-754 utilizando tarefas geradas automaticamente.", "fpFormatSelectionSimple": "Seleccionar o número de bits para o expoente e para a mantissa.", "fpFormatSelection": "Definir a largura do bit do número do ponto flutuante e depois seleccionar o número de bits para o expoente e a mantissa.", "fpArithIntro": "Prática de aritmética de ponto flutuante de acordo com IEEE-754 ou um formato auto-definido com base nele.", "fpConvIntro": "Praticar a conversão entre o sistema decimal e o formato do número de ponto flutuante de acordo com IEEE-754 ou um formato auto-definido com base nele utilizando exercícios gerados.", "sequentialCircuit": "Exemplo de um mecanismo de comutação constituído por dois D-flipflops e vários multiplexadores.", "polyadicDivisionDescription": "Os dígitos antes do ponto decimal são derivados dos dígitos dos restantes, lendo-os de baixo para cima.", "polyadicMultiplicationDescription": "As casas decimais resultam dos dígitos dos restantes, lendo-os de cima para baixo.", "homePageText": "Neste sítio web pode aprofundar os seus conhecimentos sobre temas seleccionados da palestra Fundamentos de Engenharia Informática (GTI) e do exercício associado.", "startTraining": "Vamos", "polyFreeIntro": "Pratique a aritmética poliádica com os seus próprios valores numéricos no seu sistema desejado.", "polyConvGenIntro": "Praticar a conversão entre sistemas poliádicos utilizando exercícios gerados.", "polyConvIntro": "Pratique a conversão entre sistemas poliádicos, que pode escolher livremente.", "numVarInput": "Número de variáveis", "conversionExercise": "Tarefas de conversão", "impressum": "Impressum", "copyright": "Cátedra de Informática 12, FAU. Todos os direitos reservados.", "herausgeber": "Editora", "disclaimerFooter": "Não é dada qualquer garantia quanto à exactidão do material fornecido neste website.", "representedByHeader": "Representado por", "contactPersonHeader": "Contacto", "representedBy": "A cadeira de Informática 12 é uma instituição de direito público no âmbito da Friedrich-Alexander-UniversitÃ¤t Erlangen-Nürnberg (FAU). Em conformidade com os artigos 20 e 21 da BayHSchG, a FAU, como instituição estatal e organismo autónomo de direito público, é representada externamente pelo Presidente.", "haftungsauschlussHeader": "Declaração de exoneração de responsabilidade", "haftungsauschlussBody": "As respectivas instituições são responsáveis pelo conteúdo de outros sítios web. Toda a informação fornecida neste sítio web foi compilada e verificada com o melhor dos nossos conhecimentos e crenças. No entanto, não podemos garantir que a informação fornecida esteja sempre actualizada, correcta, completa ou disponível. Uma relação contratual com os utilizadores da oferta da Internet não se concretiza. Não somos responsáveis por quaisquer danos causados pela utilização deste website. Esta exclusão de responsabilidade não se aplica na medida em que as disposições do Â§839 do Código Civil Alemão (responsabilidade por violação do dever oficial) sejam relevantes. Não seremos responsáveis por quaisquer danos causados por malware ou pela instalação ou utilização de software ao chamar ou descarregar dados. Como prestador de serviços, somos responsáveis pelo nosso próprio conteúdo nestas páginas, de acordo com Â§ 7 para. 1 TMG (Lei de Telemedia alemã) ao abrigo das leis gerais. No entanto, de acordo com Â§ 8 a 10 TMG, não somos obrigados, como prestador de serviços, a monitorizar informações transmitidas ou armazenadas por terceiros ou a investigar circunstâncias que indiquem actividade ilegal. As obrigações de remover ou bloquear a utilização da informação de acordo com as leis gerais permanecem inalteradas. No entanto, a responsabilidade a este respeito só é possível a partir do momento em que se tem conhecimento de uma infracção concreta. Se tivermos conhecimento de violações legais correspondentes, removeremos imediatamente este conteúdo. O operador reserva-se expressamente o direito de alterar, complementar ou eliminar páginas web individuais, serviços web ou toda a oferta sem aviso prévio em separado, ou de cessar temporária ou permanentemente a publicação.", "confirm": "Confirme", "varNaming": "Nomear as variáveis", "kvDiagram": "Diagrama CT", "numeralSystem": "Sistemas de números", "polyadic": "Poliádico", "floatingPoint": "Números de pontos flutuantes", "functionMin": "Minimização da função", "exercises": "Exercícios", "generateEx": "Gerar tarefa", "generate": "Gerar", "addition": "Adição", "subtraction": "Subtracção", "multiplication": "Multiplicação", "division": "Divisão", "ownSolution": "Solução própria", "signBit": "Bit de sinal", "correctSolution": "forma de resolução", "solution": "Solução", "exponentBits": "Exponente", "fractionBits": "Mantisse", "attRound": "Não se esqueça das rondas!", "attSolve": "Por favor, tente resolver a tarefa de forma independente de antemão!", "step": "Etapa", "freeCalculation": "Cálculo gratuito", "operationSelect": "Selecção cirúrgica", "firstFloatingPoint": "Primeiro número de ponto flutuante", "secondFloatingPoint": "Segundo número de ponto flutuante", "operand": "Operand", "decimal": "Número decimal", "binary": "Número binário", "inputNumber": "Introduzir número", "fpformat": "Formato de Ponto Flutuante", "check": "Verifique", "values": "Valores", "load": "Loja", "arithmetic": "Aritmética", "conversion": "Conversão", "conversionExercise1": "Convert: ", "conversionExercise2": "num número de ponto flutuante IEEE de um expoente de ", "steps": "Passos", "repeatMinuend": "Repetir minuend", "doDivision": "Divisão Perform", "doMultiplication": "Efectuar multiplicação", "getDescription": "Imprimir", "approach": "forma de resolução", "gti": "Fundamentos da Engenharia Informática", "disclaimer": "Aviso<br>:Este é um caminho de solução gerado automaticamente através do website GTI Online. Não podemos garantir a correcção e a solução sugerida é, portanto, <u>não-oficial</u>.<br>Fazemos um grande esforço para desenvolver uma ferramenta fiável e correcta para si. No entanto, o caminho da solução ou a solução em si pode conter erros. Isto também pode estar relacionado com certas versões do navegador. Por favor verifique a solução antes de a utilizar num exame, por exemplo.</br></br>", "example": "Exemplo", "composition": "Composição", "negativeSummand": "Uma adição com um valor negativo é tratada como uma subtracção.", "negativeSubtrahend": "Uma subtraenda negativa tem o mesmo efeito que uma soma positiva.", "negativeMinuendSubtrahend": "Simplificação para o caso \\\\ ( - x - y {\\i1}rightarrow - (x + y) {\\i})", "addWithZero": "Numa adição com 0, a outra soma não é alterada.", "subWithZero": "A subtracção com 0 não altera o minuend", "divWithZero": "Se houver uma divisão com 0 no numerador, o resultado é 0.", "mulWithZero": "Quando se multiplica por 0, o resultado é sempre 0.", "zeroDivision": "Uma divisão por 0 não é possível!", "arithmeticFree": "Aritmética livre", "conversionFree": "Conversão livre", "value": "Valor", "givenValues": "Valores dos números transmitidos", "leftValue": "Número restante", "rightValue": "Direito ao número", "firstSummand": "1. Summand", "secondSummand": "2. Summand", "firstFactor": "Fator 1", "secondFactor": "Fator 2", "numerator": "Contador", "denominator": "Denominador", "minuend": "Minuend", "subtrahend": "Subtrahend", "sign": "Assine", "exponent": "Exponente", "adjustExponents": "Os expoentes de ambos os números devem ser ajustados.", "addExponents": "Os expoentes de ambos os números devem ser somados.", "subtExponents": "Os expoentes de ambos os números devem ser subtraídos.", "diffExponent": "Expoente da diferença", "smallerExponent": "O expoente menor é sempre subtraído do expoente maior.", "resDiffExponent": "Portanto, a diferença é", "newExponentDivision": "O novo expoente é dado como \\( E_{'{novo}'} = E_1 - E_2 + BIAS = %{E1} - %{E2} + %{Bias} = %{Resultado} \\)", "newExponentMultiplication": "O novo expoente é dado como \\( E_{'{novo}'} = E_1 + E_2 - BIAS = %{E1} + %{E2} - %{Bias} = %{Resultado}, (%{ExpBits})})", "considerExponent": "Nota expoente", "fpExerciseText": "Deixar os números de ponto flutuante \\( fp_1 \\) e fp_2 \\) serem dados em formato de ponto flutuante de 16 bits. Calcular a %{op1} {op2} fp_1 %{op2} fp_2 } sem deixar a representação binária e dar o resultado novamente como um número de ponto flutuante:", "mantissa": "Mantisse", "solutionIsNan": "A mantissa não tem de ser calculada porque o resultado é certamente NaN.", "solutionIsInf": "A mantissa não tem de ser calculada porque o resultado é certamente infinito.", "solutionIsZero": "A mantissa não tem de ser calculada porque o resultado é certamente 0.", "mulMantissa": "As mantissas de ambos os números devem ser multiplicadas.", "addMantissa": "As mantissas de ambos os números devem ser somadas.", "divMantissa": "As mantissas de ambos os números devem ser divididas.", "newMantissa": "Nova mantissa", "zeroMantissa": "Mantissas são idênticas (\"rightarrow\") nova mantissa é 0-mantissa", "newMantissaIs": "Por isso calculamos", "newMantissaSignBit": "Por causa do complemento, calculamos com um bit de sinal:", "equalMantissa": "As mantissas são idênticas, o expoente de direito é aumentado em 1; a mantissa permanece a mesma", "equalMantissaDiv": "As duas mantissas são iguais, pelo que não é realizada nenhuma divisão binária. A mantissa é %{Mantissa}.", "adjustSmallerMantissa": "Ajustar a mantissa", "shiftMantissa": "Mudar a mantissa", "mantissaFloat": "Mantissa na bóia", "mantissaNormalize": "Para que a mantissa comece com um 1, precisamos de normalizar a mantissa, aplicando o turno de {shift}. Precisamos também de aplicar esta mudança ao expoente, resultando no novo expoente {expoente}.", "mantissaNormalizeDenorm": "O resultado não pode ser representado na representação normalizada com o deslocamento {deslocamento}, por isso usamos a representação desnormalizada com o expoente {expoente}.", "mantissaDenormalize": "Uma vez que recebemos um expoente negativo após a aplicação do turno, temos de utilizar a representação desnormalizada para exibir o resultado. Para tal, fixamos o expoente completamente em 0 e deslocamos a nossa mantissa incluindo o expoente principal pela quantidade do expoente. Assume-se que a mantissa é um zero inicial.", "mantissa1float": "Finalmente, removemos o dígito principal da mantissa para obter os pedaços de mantissa da representação IEEE-754. Os pedaços de mantissa são, portanto:", "mantissaComplement": "A mantissa é negativa. Portanto, temos de formar o complemento e definir o bit do sinal.", "subtTwosComplement": "A subtracção corresponde à adição com o complemento dos dois", "mantissaTwosComplement": "Formação do complemento de dois a partir de mantissa", "switchBits": "Bocados invertidos", "add1": "1 adieren", "normalize": "Normalizar", "shiftExpMant": "O factor de mudança do expoente deve ser aplicado às mantissas.", "shift": "Shift", "considerRepresentation": "Representação de notas", "consider1comma": "A mantissa começa sempre com um 1 antes do ponto decimal na representação padrão (e um 0 se desnormalizada).", "ternary": "Número do ternário", "quaternary": "Número do Quaternário", "quinary": "Número Quintal", "senary": "Número hexal", "septenary": "Sistema Heptal", "octal": "Número de octal", "novenary": "Número Nonal", "hexadecimal": "Número hexadecimal", "hex": "Hexadecimal", "input": "Entrada", "number": "Número", "representation": "Reprodução no formato de saída", "firstFormat": "Formato de saída", "secondFormat": "Formato alvo", "doConversion": "Efectuar conversão:", "modus": "Modus", "to": "para", "TenToPower": "Ao converter-se do sistema decimal para outro sistema polídico, o algoritmo de divisão é aplicado antes do ponto decimal e o algoritmo de multiplicação após o ponto decimal.", "PowerToTen": "A conversão de qualquer sistema para o sistema decimal é feita através da soma dos dígitos exponenciados.", "PowerToPower": "A conversão de um número de um sistema de números em outro sistema de números realiza-se em duas etapas. Primeiro, o número do sistema original é transferido para o sistema decimal, somando-o. Depois, este número decimal é convertido no sistema de destino por divisão sucessiva dos dígitos antes do ponto decimal e multiplicação sucessiva dos dígitos após o ponto decimal.", "noValuesBeforeComma": "Sem valores antes da vírgula decimal. O algoritmo de divisão pode ser omitido", "noValuesAfterComma": "Sem valores após a vírgula decimal. O algoritmo de multiplicação pode ser omitido", "firstToTen": "1. somando os dígitos exponenciados", "secondToPower": "2. conversão por meio de divisão e algoritmo de multiplicação", "shortcutBinToHex": "Ao converter de binário para hexadecimal, os valores podem ser lidos directamente.", "shortcutHexToBin": "Ao converter de hexadecimais para binários, os valores podem ser lidos directamente.", "divisionAlgorithm": "Parte inteira (algoritmo de divisão)", "multiplicationAlgorithm": "Lugares decimais (algoritmo de multiplicação)", "summation": "Somar", "factor": "Factor", "quotient": "Quociente", "remainder": "Descanso", "newBasis": "Base_{'{novo}'}", "calcStep": "Etapa de cálculo", "summands": "Summands", "polyadicExercise1": "Converta o", "polyadicExercise3": "num ", "exerciseArchive": "Arquivo de tarefas", "randomExercise": "Tarefa aleatória", "doCalculation": "Calcular", "colorCoding": "Codificação por cores", "mathDistribution": "Distribuierung", "easy": "simplesmente", "difficultyMiddle": "médio", "difficultyHard": "pesado", "sheet": "Folha", "goal": "Destino", "difficultyUC": "Dificuldade", "bf_infotext_or_interact_with_kv": "Ou interagir directamente com o diagrama KV", "bf_infotext_kv_must_not_be_empty": "O diagrama KV deve conter uns e zeros", "bf_infotest_click_on_hidden_areas_to_make_visible": "Clique sobre as áreas ocultas para as revelar", "bf_normal_forms": "Formulários normais", "bf_disjunctiveNormalForm": "Forma disjuntiva normal", "bf_conjunctiveNormalForm": "Forma Conjuntiva Normal", "bf_disjunctiveMinimalForm": "Forma mínima disjuntiva", "bf_conjunctiveMinimalForm": "Forma Conjuntiva mínima", "bf_quineMCCluskeyClasses": "Aulas de Quine McCluskey", "bf_primeTerms": "Primterme", "bf_primeImplicants": "Primimplikanten", "bf_primeImplicates": "Primimplikate", "bf_primeCoverTable": "Tabela de sobreposição", "bf_petrickExpression": "Expressão Petrick", "bf_minimalForms": "Minimalformen", "bf_tableWithCyclicRest": "Tabela do resto cíclico", "bf_einstelle": "Ponto de entrada", "bf_nullstelle": "Zero", "bf_einstellen": "Lugares de emprego", "bf_nullstellen": "Zeros", "bf_goal_determine_DNF": "Determinar DNF", "bf_goal_determine_KNF": "Determinar KNF", "bf_goal_determine_prime_implicants": "Determinar os principais implantes", "bf_goal_determine_prime_implicates": "Determinar o prime implica", "bf_covertable_step_description_initial": "<h4>Passo inicial:</h4>Introduzir todos os termos base ({ifMinTermsSetElseNull}) em colunas e todos os termos principais (PI) em filas na tabela. Se um termo principal cobrir um {ifMinTermsEinstelleElseNullstelle}, marcar essa célula com um X. O custo c é a soma de todos os termos base ({ifMinTermsEinstellenElseNullstelle}). O custo c de um termo primo é o número dos seus literais. Quanto maior for o número, mais caro é implementá-lo no hardware. <br>Dica:<br>Uma primimplicaNT cobre um dígito ON exactamente quando todos os literais do primimplicativo também ocorrem da mesma forma no termo base</br>.</br>", "bf_covertable_step_description_core_found": "<h4>Core found:</h4>O único termo principal que cobre o {ifMinTermsElseNull} {columnName} é o termo {rowName}. Por isso, este termo primordial deve aparecer absolutamente na nossa função de comutação! Marcar a fila como núcleo e riscar a coluna.", "bf_covertable_step_description_cross_column_bc_covered": "<h4>Coluna já coberta:</h4>O {ifMinTermsSetElseNullSets} {columnName} já está coberto pelo termo principal {rowName}. Riscar a coluna.", "bf_covertable_step_description_cross_row_bc_covered": "<h4>Fila já totalmente coberta:</h4>Todos os X da fila {rowName} já estão cobertos. Riscar a fila.", "bf_covertable_step_description_row_domination": "Dominância da linha<h4>:</h4>A linha {dominatorName} domina a linha {dominatedName}, ou seja, {dominatorName} tem marcadores em todo o lado onde a linha {dominatorName} também tem marcadores (e talvez até mais). =&gt; Eliminar a linha dominada {dominatedName}. <br>Note-se que o domínio da linha só é aplicável porque a linha {dominatorName} custa menos ou o mesmo que {dominatorName}; ou porque não há outra linha que cubra os dígitos adicionais de {dominatorName} e custa menos que {dominatorName} - {dominatorName}.</br>", "bf_covertable_step_description_column_domination": "Dominância da coluna<h4>:</h4>A coluna {dominatorName} domina a coluna {dominatedName}, ou seja, {dominatorName} tem marcadores em todo o lado onde a coluna {dominatorName} também tem marcadores (e talvez até mais). =&gt; Eliminar a coluna dominante {dominatorName} Em<br>contraste com a</br>dominância<br>em linha</br>, a<br>dominância em coluna não precisa de ter em conta os custos (/â-½ï¼¼)</br>.", "bf_covertable_step_description_cyclic_rest": "<h4>Restante cíclico:</h4>Nenhuma regra da tabela de sobreposição é aplicável. Isto é referido como um \"remanescente cíclico\".<br>A fim de poder determinar uma forma mínima da função de comutação, é possível listar a expressão Petrick, em que apenas são introduzidas linhas e colunas que ainda não tenham sido riscadas.</br>", "bf_infoblob_random_exercise_selection": "A dificuldade seleccionada determina quantos termos de um tipo (por exemplo, minterms, principais implantes) a função de comutação deve conter.", "bf_infoblob_petrick_statement": "O algoritmo consiste em duas fases:<ol><li>Reorganizar os termos de modo a que o máximo possível seja absorvido.</li><li>Multiplicar os termos.</li></ol>", "bf_distributionUC": "Distribuição", "bf_idempotenceUC": "Idempotenz", "bf_absorptionUC": "Absorção", "bf_sortingUC": "Ordenação", "bf_infoblob_functionMin": "Praticar os diferentes procedimentos para a minimização da função", "bf_disjunctiveNormalForm_explanation": "A forma disjuntiva normal é uma disjunção (veroderung) de todos os minterms (1s) de uma função. Cada termo mineiro corresponde exactamente a um 1 na função; todos os literais devem ser negados ou não negados na função.", "bf_conjunctiveNormalForm_explanation": "A forma conjuntiva normal é uma conjunção de todos os termos (0s) de uma função. Os 0s não são seleccionados em maxterms (como os 1s em minterms), mas excluídos. Cada maxterm corresponde exactamente a um 0 na função; todos os literais devem ser negados ou não negados na função.", "bf_quineMCCluskeyClasses_explanation": "O método Quine/McCluskey é um método de minimização com o qual os principais termos de uma função podem ser determinados.", "bf_infoblob_quineMCCluskeyClasses_colorCoding": "Os termos reduzidos são normalmente marcados por strikethrough no procedimento Quine/McCluskey. Quando a codificação por cores está activa, são em vez disso cinzento claro. ", "bf_infoblob_quineMCCluskeyClasses_01": "Normalmente, escrevemos os min- ou maxterms nas aulas individuais. Alternativamente, também podemos trabalhar com 0s (para literais negados) e 1s (para literais não negados), em que a posição destes determina qual é literal.", "bf_primeTerms_explanation": "Termos com um número mínimo de literais, cobrindo apenas um ou zeros. ", "bf_bf_primeImplicants_explanation": "PrimimplicaNts são primatas que cobrem apenas UMA posição (com recorte). ", "bf_primeImplicates_explanation": "Prime implícitos são termos primos que cobrem apenas zeros (com vagas). ", "bf_disjunctiveMinimalForm_explanation": "Disjunção dos literais ligados por conjunção. Isto não pode ser mais simplificado (sem violar este formulário) (DNF simplificado).", "bf_conjunctiveMinimalForm_explanation": "Conjunção de literais ligados por disjunção. Isto não pode ser mais simplificado (sem violar este formulário) (KNF simplificada).", "cmos_infoblob_description": "CMOS é uma composição de uma rede complementar de comutação NMOS (rede pull-down, como ligada à terra) e rede de comutação PMOS (rede pull-up, como ligada à tensão de alimentação). Como resultado, é consumida menos energia no estado de comutação fixa, uma vez que o PDN e o PUN são complementares e, portanto, só conduzem simultaneamente por um curto período de tempo durante a comutação. No entanto, é necessária mais área no chip.", "cmos_infoblob_input_description": "Nota: Para OU portões '+' pode ser usado, para E portões '*' e para negação '~'. As variáveis podem ter qualquer nome (Atenção: a entrada 'ab' é interpretada como uma variável e não como um composto de 'a' e 'b').", "enter_cmos": "Por favor, introduza a sua entrada CMOS.", "polyadicExercise2": "a partir do formato inicial:", "newExponent": "Novo expoente", "systemInBase": "Sistema para a base", "basis": "Base", "minterms": "Minterme", "maxterms": "Maxterme", "contact": "Contacto", "impressumText": "Encontrará a impressão em baixo: ", "and": " e", "weThank": "Gostaríamos de agradecer às seguintes pessoas pela sua ajuda na criação deste website:", "Danksagung": "Agradecimentos", "thankProfessorTeich": "Os materiais desta página baseiam-se na palestra GTI do Professor Dr.-Ing. Jürgen Teich of the Friedrich-Alexander-UniversitÃ¤t (FAU). Agradecemos-lhe a sua perícia e o seu patrocínio.", "wintersemester": "Wintersemestre", "sommersemester": "Semestre de Verão", "downloadSvg": "Exportar SVG", "downloadPng": "Exportação PNG", "formula": "Fórmula", "divByZero": "A divisão por 0 dá NaN.", "falseFormat": "Formato errado"}