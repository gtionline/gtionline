// Generated by PEG.js v0.11.0-master.f69239d, https://pegjs.org/

function peg$subclass(child, parent) {
  function C() { this.constructor = child; }
  C.prototype = parent.prototype;
  child.prototype = new C();
}

function peg$SyntaxError(message, expected, found, location) {
  this.message = message;
  this.expected = expected;
  this.found = found;
  this.location = location;
  this.name = 'SyntaxError';

  // istanbul ignore next
  if (typeof Error.captureStackTrace === 'function') {
    Error.captureStackTrace(this, peg$SyntaxError);
  }
}

peg$subclass(peg$SyntaxError, Error);

peg$SyntaxError.buildMessage = function (expected, found) {
  const DESCRIBE_EXPECTATION_FNS = {
    literal(expectation) {
      return `"${literalEscape(expectation.text)}"`;
    },

    class(expectation) {
      const escapedParts = expectation.parts.map((part) => (Array.isArray(part)
        ? `${classEscape(part[0])}-${classEscape(part[1])}`
        : classEscape(part)));

      return `[${expectation.inverted ? '^' : ''}${escapedParts}]`;
    },

    any() {
      return 'any character';
    },

    end() {
      return 'end of input';
    },

    other(expectation) {
      return expectation.description;
    },

    not(expectation) {
      return `not ${describeExpectation(expectation.expected)}`;
    },
  };

  function hex(ch) {
    return ch.charCodeAt(0).toString(16).toUpperCase();
  }

  function literalEscape(s) {
    return s
      .replace(/\\/g, '\\\\')
      .replace(/"/g, '\\"')
      .replace(/\0/g, '\\0')
      .replace(/\t/g, '\\t')
      .replace(/\n/g, '\\n')
      .replace(/\r/g, '\\r')
      .replace(/[\x00-\x0F]/g, (ch) => `\\x0${hex(ch)}`)
      .replace(/[\x10-\x1F\x7F-\x9F]/g, (ch) => `\\x${hex(ch)}`);
  }

  function classEscape(s) {
    return s
      .replace(/\\/g, '\\\\')
      .replace(/\]/g, '\\]')
      .replace(/\^/g, '\\^')
      .replace(/-/g, '\\-')
      .replace(/\0/g, '\\0')
      .replace(/\t/g, '\\t')
      .replace(/\n/g, '\\n')
      .replace(/\r/g, '\\r')
      .replace(/[\x00-\x0F]/g, (ch) => `\\x0${hex(ch)}`)
      .replace(/[\x10-\x1F\x7F-\x9F]/g, (ch) => `\\x${hex(ch)}`);
  }

  function describeExpectation(expectation) {
    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
  }

  function describeExpected(expected) {
    const descriptions = expected.map(describeExpectation);
    let i; let
      j;

    descriptions.sort();

    if (descriptions.length > 0) {
      for (i = 1, j = 1; i < descriptions.length; i++) {
        if (descriptions[i - 1] !== descriptions[i]) {
          descriptions[j] = descriptions[i];
          j++;
        }
      }
      descriptions.length = j;
    }

    switch (descriptions.length) {
      case 1:
        return descriptions[0];

      case 2:
        return `${descriptions[0]} or ${descriptions[1]}`;

      default:
        return `${descriptions.slice(0, -1).join(', ')
        }, or ${
          descriptions[descriptions.length - 1]}`;
    }
  }

  function describeFound(found) {
    return found ? `"${literalEscape(found)}"` : 'end of input';
  }

  return `Expected ${describeExpected(expected)} but ${describeFound(found)} found.`;
};

function peg$parse(input, options) {
  options = options !== undefined ? options : {};

  const peg$FAILED = {};

  const peg$startRuleFunctions = { Function: peg$parseFunction };
  let peg$startRuleFunction = peg$parseFunction;

  const peg$c0 = '=';
  const peg$c1 = '^';
  const peg$c2 = 'xor';
  const peg$c3 = '<=>';
  const peg$c4 = 'xnor';
  const peg$c5 = 'nor';
  const peg$c6 = '+';
  const peg$c7 = '|';
  const peg$c8 = 'or';
  const peg$c9 = 'nand';
  const peg$c10 = '*';
  const peg$c11 = '&';
  const peg$c12 = 'and';
  const peg$c13 = '!';
  const peg$c14 = '~';
  const peg$c15 = 'not';
  const peg$c16 = '0';
  const peg$c17 = '1';
  const peg$c18 = '(';
  const peg$c19 = ')';

  const peg$r0 = /^[a-zA-Z]/;
  const peg$r1 = /^[0-9]/;
  const peg$r2 = /^[ \t\r\n]/;

  const peg$e0 = peg$literalExpectation('=', false);
  const peg$e1 = peg$literalExpectation('^', false);
  const peg$e2 = peg$literalExpectation('xor', false);
  const peg$e3 = peg$literalExpectation('<=>', false);
  const peg$e4 = peg$literalExpectation('xnor', false);
  const peg$e5 = peg$literalExpectation('nor', false);
  const peg$e6 = peg$literalExpectation('+', false);
  const peg$e7 = peg$literalExpectation('|', false);
  const peg$e8 = peg$literalExpectation('or', false);
  const peg$e9 = peg$literalExpectation('nand', false);
  const peg$e10 = peg$literalExpectation('*', false);
  const peg$e11 = peg$literalExpectation('&', false);
  const peg$e12 = peg$literalExpectation('and', false);
  const peg$e13 = peg$literalExpectation('!', false);
  const peg$e14 = peg$literalExpectation('~', false);
  const peg$e15 = peg$literalExpectation('not', false);
  const peg$e16 = peg$literalExpectation('0', false);
  const peg$e17 = peg$literalExpectation('1', false);
  const peg$e18 = peg$classExpectation([['a', 'z'], ['A', 'Z']], false, false);
  const peg$e19 = peg$classExpectation([['0', '9']], false, false);
  const peg$e20 = peg$literalExpectation('(', false);
  const peg$e21 = peg$literalExpectation(')', false);
  const peg$e22 = peg$classExpectation([' ', '\t', '\r', '\n'], false, false);

  const peg$f0 = function (name, expression) {
    return makeFunction(name ? name[0].toString() : null, expression);
  };
  const peg$f1 = function (head, tail) {
    if (tail.length > 0) {
      return makeOperation(BooleanOperation.XOR, [head].concat(tail.map((x) => x[1])), false);
    }
    return head;
  };
  const peg$f2 = function (head, tail) {
    if (tail.length > 0) {
      return makeOperation(BooleanOperation.XNOR, [head].concat(tail.map((x) => x[1])), false);
    }
    return head;
  };
  const peg$f3 = function (head, tail) {
    if (tail.length > 0) {
      return makeOperation(BooleanOperation.NOR, [head].concat(tail.map((x) => x[1])), false);
    }
    return head;
  };
  const peg$f4 = function (head, tail) {
    if (tail.length > 0) {
      return makeOperation(BooleanOperation.OR, [head].concat(tail.map((x) => x[1])), false);
    }
    return head;
  };
  const peg$f5 = function (head, tail) {
    if (tail.length > 0) {
      return makeOperation(BooleanOperation.NAND, [head].concat(tail.map((x) => x[1])), false);
    }
    return head;
  };
  const peg$f6 = function (head, tail) {
    if (tail.length > 0) {
      return makeOperation(BooleanOperation.AND, [head].concat(tail.map((x) => x[1])), false);
    }

    return head;
  };
  const peg$f7 = function (term) {
    return makeOperation(BooleanOperation.NOT, term, false);
  };
  const peg$f8 = function (term) {
    term.hasParentheses = true;
    return term;
  };
  const peg$f9 = function (value) {
    return makeLiteral(value);
  };
  const peg$f10 = function (characters) {
    return makeVariable(characters[0].join('') + characters[1].join(''));
  };

  let peg$currPos = 0;
  let peg$savedPos = 0;
  const peg$posDetailsCache = [{ line: 1, column: 1 }];
  const peg$expected = [];
  const peg$silentFails = 0;

  let peg$result;

  if ('startRule' in options) {
    if (!(options.startRule in peg$startRuleFunctions)) {
      throw new Error(`Can't start parsing from rule "${options.startRule}".`);
    }

    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
  }

  function text() {
    return input.substring(peg$savedPos, peg$currPos);
  }

  function offset() {
    return peg$savedPos;
  }

  function range() {
    return [peg$savedPos, peg$currPos];
  }

  function location() {
    return peg$computeLocation(peg$savedPos, peg$currPos);
  }

  function expected(description, location) {
    location = location !== undefined
      ? location
      : peg$computeLocation(peg$savedPos, peg$currPos);

    throw peg$buildStructuredError(
      [peg$otherExpectation(description)],
      input.substring(peg$savedPos, peg$currPos),
      location,
    );
  }

  function error(message, location) {
    location = location !== undefined
      ? location
      : peg$computeLocation(peg$savedPos, peg$currPos);

    throw peg$buildSimpleError(message, location);
  }

  function peg$literalExpectation(text, ignoreCase) {
    return { type: 'literal', text, ignoreCase };
  }

  function peg$classExpectation(parts, inverted, ignoreCase) {
    return {
      type: 'class', parts, inverted, ignoreCase,
    };
  }

  function peg$anyExpectation() {
    return { type: 'any' };
  }

  function peg$endExpectation() {
    return { type: 'end' };
  }

  function peg$otherExpectation(description) {
    return { type: 'other', description };
  }

  function peg$computePosDetails(pos) {
    let details = peg$posDetailsCache[pos];
    let p;

    if (details) {
      return details;
    }
    p = pos - 1;
    while (!peg$posDetailsCache[p]) {
      p--;
    }

    details = peg$posDetailsCache[p];
    details = {
      line: details.line,
      column: details.column,
    };

    while (p < pos) {
      if (input.charCodeAt(p) === 10) {
        details.line++;
        details.column = 1;
      } else {
        details.column++;
      }

      p++;
    }

    peg$posDetailsCache[pos] = details;

    return details;
  }

  const peg$VALIDFILENAME = typeof options.filename === 'string' && options.filename.length > 0;
  function peg$computeLocation(startPos, endPos) {
    const loc = {};

    if (peg$VALIDFILENAME) loc.filename = options.filename;

    const startPosDetails = peg$computePosDetails(startPos);
    loc.start = {
      offset: startPos,
      line: startPosDetails.line,
      column: startPosDetails.column,
    };

    const endPosDetails = peg$computePosDetails(endPos);
    loc.end = {
      offset: endPos,
      line: endPosDetails.line,
      column: endPosDetails.column,
    };

    return loc;
  }

  function peg$begin() {
    peg$expected.push({ pos: peg$currPos, variants: [] });
  }

  function peg$expect(expected) {
    const top = peg$expected[peg$expected.length - 1];

    if (peg$currPos < top.pos) { return; }

    if (peg$currPos > top.pos) {
      top.pos = peg$currPos;
      top.variants = [];
    }

    top.variants.push(expected);
  }

  function peg$end(invert) {
    const expected = peg$expected.pop();
    const top = peg$expected[peg$expected.length - 1];
    let variants = expected.variants;

    if (top.pos !== expected.pos) { return; }

    if (invert) {
      variants = variants.map((e) => (e.type === 'not' ? e.expected : { type: 'not', expected: e }));
    }

    Array.prototype.push.apply(top.variants, variants);
  }

  function peg$buildSimpleError(message, location) {
    return new peg$SyntaxError(message, null, null, location);
  }

  function peg$buildStructuredError(expected, found, location) {
    return new peg$SyntaxError(
      peg$SyntaxError.buildMessage(expected, found),
      expected,
      found,
      location,
    );
  }

  function peg$buildError() {
    const expected = peg$expected[0];
    const failPos = expected.pos;

    return peg$buildStructuredError(
      expected.variants,
      failPos < input.length ? input.charAt(failPos) : null,
      failPos < input.length
        ? peg$computeLocation(failPos, failPos + 1)
        : peg$computeLocation(failPos, failPos),
    );
  }

  function peg$parseFunction() {
    let s0; let s1; let s2; let
      s3;

    const rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    };

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$parseVariable();
    if (s2 !== peg$FAILED) {
      rule$expects(peg$e0);
      if (input.charCodeAt(peg$currPos) === 61) {
        s3 = peg$c0;
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        s2 = [s2, s3];
        s1 = s2;
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 === peg$FAILED) {
      s1 = null;
    }
    s2 = peg$parseXorTerm();
    if (s2 !== peg$FAILED) {
      peg$savedPos = s0;
      s0 = peg$f0(s1, s2);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseXorTerm() {
    let s0; let s1; let s2; let s3; let s4; let
      s5;

    const rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    };

    s0 = peg$currPos;
    s1 = peg$parseXnorTerm();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      rule$expects(peg$e1);
      if (input.charCodeAt(peg$currPos) === 94) {
        s4 = peg$c1;
        peg$currPos++;
      } else {
        s4 = peg$FAILED;
      }
      if (s4 === peg$FAILED) {
        rule$expects(peg$e2);
        if (input.substr(peg$currPos, 3) === peg$c2) {
          s4 = peg$c2;
          peg$currPos += 3;
        } else {
          s4 = peg$FAILED;
        }
      }
      if (s4 !== peg$FAILED) {
        s5 = peg$parseXnorTerm();
        if (s5 !== peg$FAILED) {
          s4 = [s4, s5];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        rule$expects(peg$e1);
        if (input.charCodeAt(peg$currPos) === 94) {
          s4 = peg$c1;
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
        }
        if (s4 === peg$FAILED) {
          rule$expects(peg$e2);
          if (input.substr(peg$currPos, 3) === peg$c2) {
            s4 = peg$c2;
            peg$currPos += 3;
          } else {
            s4 = peg$FAILED;
          }
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parseXnorTerm();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      peg$savedPos = s0;
      s0 = peg$f1(s1, s2);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseXnorTerm() {
    let s0; let s1; let s2; let s3; let s4; let
      s5;

    const rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    };

    s0 = peg$currPos;
    s1 = peg$parseNorTerm();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      rule$expects(peg$e3);
      if (input.substr(peg$currPos, 3) === peg$c3) {
        s4 = peg$c3;
        peg$currPos += 3;
      } else {
        s4 = peg$FAILED;
      }
      if (s4 === peg$FAILED) {
        rule$expects(peg$e4);
        if (input.substr(peg$currPos, 4) === peg$c4) {
          s4 = peg$c4;
          peg$currPos += 4;
        } else {
          s4 = peg$FAILED;
        }
      }
      if (s4 !== peg$FAILED) {
        s5 = peg$parseNorTerm();
        if (s5 !== peg$FAILED) {
          s4 = [s4, s5];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        rule$expects(peg$e3);
        if (input.substr(peg$currPos, 3) === peg$c3) {
          s4 = peg$c3;
          peg$currPos += 3;
        } else {
          s4 = peg$FAILED;
        }
        if (s4 === peg$FAILED) {
          rule$expects(peg$e4);
          if (input.substr(peg$currPos, 4) === peg$c4) {
            s4 = peg$c4;
            peg$currPos += 4;
          } else {
            s4 = peg$FAILED;
          }
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parseNorTerm();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      peg$savedPos = s0;
      s0 = peg$f2(s1, s2);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseNorTerm() {
    let s0; let s1; let s2; let s3; let s4; let
      s5;

    const rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    };

    s0 = peg$currPos;
    s1 = peg$parseOrTerm();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      rule$expects(peg$e5);
      if (input.substr(peg$currPos, 3) === peg$c5) {
        s4 = peg$c5;
        peg$currPos += 3;
      } else {
        s4 = peg$FAILED;
      }
      if (s4 !== peg$FAILED) {
        s5 = peg$parseOrTerm();
        if (s5 !== peg$FAILED) {
          s4 = [s4, s5];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        rule$expects(peg$e5);
        if (input.substr(peg$currPos, 3) === peg$c5) {
          s4 = peg$c5;
          peg$currPos += 3;
        } else {
          s4 = peg$FAILED;
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parseOrTerm();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      peg$savedPos = s0;
      s0 = peg$f3(s1, s2);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseOrTerm() {
    let s0; let s1; let s2; let s3; let s4; let
      s5;

    const rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    };

    s0 = peg$currPos;
    s1 = peg$parseNandTerm();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      rule$expects(peg$e6);
      if (input.charCodeAt(peg$currPos) === 43) {
        s4 = peg$c6;
        peg$currPos++;
      } else {
        s4 = peg$FAILED;
      }
      if (s4 === peg$FAILED) {
        rule$expects(peg$e7);
        if (input.charCodeAt(peg$currPos) === 124) {
          s4 = peg$c7;
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
        }
        if (s4 === peg$FAILED) {
          rule$expects(peg$e8);
          if (input.substr(peg$currPos, 2) === peg$c8) {
            s4 = peg$c8;
            peg$currPos += 2;
          } else {
            s4 = peg$FAILED;
          }
        }
      }
      if (s4 !== peg$FAILED) {
        s5 = peg$parseNandTerm();
        if (s5 !== peg$FAILED) {
          s4 = [s4, s5];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        rule$expects(peg$e6);
        if (input.charCodeAt(peg$currPos) === 43) {
          s4 = peg$c6;
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
        }
        if (s4 === peg$FAILED) {
          rule$expects(peg$e7);
          if (input.charCodeAt(peg$currPos) === 124) {
            s4 = peg$c7;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
          }
          if (s4 === peg$FAILED) {
            rule$expects(peg$e8);
            if (input.substr(peg$currPos, 2) === peg$c8) {
              s4 = peg$c8;
              peg$currPos += 2;
            } else {
              s4 = peg$FAILED;
            }
          }
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parseNandTerm();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      peg$savedPos = s0;
      s0 = peg$f4(s1, s2);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseNandTerm() {
    let s0; let s1; let s2; let s3; let s4; let
      s5;

    const rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    };

    s0 = peg$currPos;
    s1 = peg$parseAndTerm();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      rule$expects(peg$e9);
      if (input.substr(peg$currPos, 4) === peg$c9) {
        s4 = peg$c9;
        peg$currPos += 4;
      } else {
        s4 = peg$FAILED;
      }
      if (s4 !== peg$FAILED) {
        s5 = peg$parseAndTerm();
        if (s5 !== peg$FAILED) {
          s4 = [s4, s5];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        rule$expects(peg$e9);
        if (input.substr(peg$currPos, 4) === peg$c9) {
          s4 = peg$c9;
          peg$currPos += 4;
        } else {
          s4 = peg$FAILED;
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parseAndTerm();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      peg$savedPos = s0;
      s0 = peg$f5(s1, s2);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseAndTerm() {
    let s0; let s1; let s2; let s3; let s4; let
      s5;

    const rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    };

    s0 = peg$currPos;
    s1 = peg$parseNotTerm();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      rule$expects(peg$e10);
      if (input.charCodeAt(peg$currPos) === 42) {
        s4 = peg$c10;
        peg$currPos++;
      } else {
        s4 = peg$FAILED;
      }
      if (s4 === peg$FAILED) {
        rule$expects(peg$e11);
        if (input.charCodeAt(peg$currPos) === 38) {
          s4 = peg$c11;
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
        }
        if (s4 === peg$FAILED) {
          rule$expects(peg$e12);
          if (input.substr(peg$currPos, 3) === peg$c12) {
            s4 = peg$c12;
            peg$currPos += 3;
          } else {
            s4 = peg$FAILED;
          }
        }
      }
      if (s4 !== peg$FAILED) {
        s5 = peg$parseNotTerm();
        if (s5 !== peg$FAILED) {
          s4 = [s4, s5];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        rule$expects(peg$e10);
        if (input.charCodeAt(peg$currPos) === 42) {
          s4 = peg$c10;
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
        }
        if (s4 === peg$FAILED) {
          rule$expects(peg$e11);
          if (input.charCodeAt(peg$currPos) === 38) {
            s4 = peg$c11;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
          }
          if (s4 === peg$FAILED) {
            rule$expects(peg$e12);
            if (input.substr(peg$currPos, 3) === peg$c12) {
              s4 = peg$c12;
              peg$currPos += 3;
            } else {
              s4 = peg$FAILED;
            }
          }
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parseNotTerm();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      peg$savedPos = s0;
      s0 = peg$f6(s1, s2);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseNotTerm() {
    let s0; let s1; let s2; let
      s3;

    const rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    };

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parseWhitespace();
    while (s2 !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$parseWhitespace();
    }
    rule$expects(peg$e13);
    if (input.charCodeAt(peg$currPos) === 33) {
      s2 = peg$c13;
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
    }
    if (s2 === peg$FAILED) {
      rule$expects(peg$e14);
      if (input.charCodeAt(peg$currPos) === 126) {
        s2 = peg$c14;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
      }
      if (s2 === peg$FAILED) {
        rule$expects(peg$e15);
        if (input.substr(peg$currPos, 3) === peg$c15) {
          s2 = peg$c15;
          peg$currPos += 3;
        } else {
          s2 = peg$FAILED;
        }
      }
    }
    if (s2 !== peg$FAILED) {
      s3 = peg$parsePrimaryTerm();
      if (s3 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f7(s3);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$parsePrimaryTerm();
    }

    return s0;
  }

  function peg$parsePrimaryTerm() {
    let s0; let s1; let s2; let
      s3;

    const rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    };

    s0 = peg$parseVariable();
    if (s0 === peg$FAILED) {
      s0 = peg$parseLiteral();
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseLeftParenthesis();
        if (s1 !== peg$FAILED) {
          s2 = peg$parseXorTerm();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseRightParenthesis();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f8(s2);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }
    }

    return s0;
  }

  function peg$parseLiteral() {
    let s0; let s1; let s2; let s3; let
      s4;

    const rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    };

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parseWhitespace();
    while (s2 !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$parseWhitespace();
    }
    rule$expects(peg$e16);
    if (input.charCodeAt(peg$currPos) === 48) {
      s2 = peg$c16;
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
    }
    if (s2 === peg$FAILED) {
      rule$expects(peg$e17);
      if (input.charCodeAt(peg$currPos) === 49) {
        s2 = peg$c17;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
      }
    }
    if (s2 !== peg$FAILED) {
      s3 = [];
      s4 = peg$parseWhitespace();
      while (s4 !== peg$FAILED) {
        s3.push(s4);
        s4 = peg$parseWhitespace();
      }
      peg$savedPos = s0;
      s0 = peg$f9(s2);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseVariable() {
    let s0; let s1; let s2; let s3; let s4; let s5; let
      s6;

    const rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    };

    s0 = peg$currPos;
    s1 = peg$currPos;
    peg$begin();
    s2 = peg$parseOperators();
    peg$end(true);
    if (s2 === peg$FAILED) {
      s1 = undefined;
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseWhitespace();
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parseWhitespace();
      }
      s3 = peg$currPos;
      s4 = [];
      rule$expects(peg$e18);
      if (peg$r0.test(input.charAt(peg$currPos))) {
        s5 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s5 = peg$FAILED;
      }
      if (s5 !== peg$FAILED) {
        while (s5 !== peg$FAILED) {
          s4.push(s5);
          rule$expects(peg$e18);
          if (peg$r0.test(input.charAt(peg$currPos))) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
          }
        }
      } else {
        s4 = peg$FAILED;
      }
      if (s4 !== peg$FAILED) {
        s5 = [];
        rule$expects(peg$e19);
        if (peg$r1.test(input.charAt(peg$currPos))) {
          s6 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s6 = peg$FAILED;
        }
        while (s6 !== peg$FAILED) {
          s5.push(s6);
          rule$expects(peg$e19);
          if (peg$r1.test(input.charAt(peg$currPos))) {
            s6 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
          }
        }
        s4 = [s4, s5];
        s3 = s4;
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        s4 = [];
        s5 = peg$parseWhitespace();
        while (s5 !== peg$FAILED) {
          s4.push(s5);
          s5 = peg$parseWhitespace();
        }
        peg$savedPos = s0;
        s0 = peg$f10(s3);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseLeftParenthesis() {
    let s0; let s1; let s2; let s3; let
      s4;

    const rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    };

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parseWhitespace();
    while (s2 !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$parseWhitespace();
    }
    rule$expects(peg$e20);
    if (input.charCodeAt(peg$currPos) === 40) {
      s2 = peg$c18;
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
    }
    if (s2 !== peg$FAILED) {
      s3 = [];
      s4 = peg$parseWhitespace();
      while (s4 !== peg$FAILED) {
        s3.push(s4);
        s4 = peg$parseWhitespace();
      }
      s1 = [s1, s2, s3];
      s0 = s1;
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseRightParenthesis() {
    let s0; let s1; let s2; let s3; let
      s4;

    const rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    };

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parseWhitespace();
    while (s2 !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$parseWhitespace();
    }
    rule$expects(peg$e21);
    if (input.charCodeAt(peg$currPos) === 41) {
      s2 = peg$c19;
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
    }
    if (s2 !== peg$FAILED) {
      s3 = [];
      s4 = peg$parseWhitespace();
      while (s4 !== peg$FAILED) {
        s3.push(s4);
        s4 = peg$parseWhitespace();
      }
      s1 = [s1, s2, s3];
      s0 = s1;
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseWhitespace() {
    let s0; let
      s1;

    const rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    };

    s0 = [];
    rule$expects(peg$e22);
    if (peg$r2.test(input.charAt(peg$currPos))) {
      s1 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      while (s1 !== peg$FAILED) {
        s0.push(s1);
        rule$expects(peg$e22);
        if (peg$r2.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
        }
      }
    } else {
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseOperators() {
    let s0;

    const rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    };

    rule$expects(peg$e12);
    if (input.substr(peg$currPos, 3) === peg$c12) {
      s0 = peg$c12;
      peg$currPos += 3;
    } else {
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      rule$expects(peg$e8);
      if (input.substr(peg$currPos, 2) === peg$c8) {
        s0 = peg$c8;
        peg$currPos += 2;
      } else {
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        rule$expects(peg$e2);
        if (input.substr(peg$currPos, 3) === peg$c2) {
          s0 = peg$c2;
          peg$currPos += 3;
        } else {
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          rule$expects(peg$e15);
          if (input.substr(peg$currPos, 3) === peg$c15) {
            s0 = peg$c15;
            peg$currPos += 3;
          } else {
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            rule$expects(peg$e4);
            if (input.substr(peg$currPos, 4) === peg$c4) {
              s0 = peg$c4;
              peg$currPos += 4;
            } else {
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              rule$expects(peg$e9);
              if (input.substr(peg$currPos, 4) === peg$c9) {
                s0 = peg$c9;
                peg$currPos += 4;
              } else {
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                rule$expects(peg$e5);
                if (input.substr(peg$currPos, 3) === peg$c5) {
                  s0 = peg$c5;
                  peg$currPos += 3;
                } else {
                  s0 = peg$FAILED;
                }
              }
            }
          }
        }
      }
    }

    return s0;
  }

  const BooleanOperation = options.BooleanOperation;
  const makeFunction = options.makeBooleanFunction;
  const makeOperation = options.makeBooleanOperation;
  const makeVariable = options.makeBooleanVariable;
  const makeLiteral = options.makeBooleanLiteral;

  peg$begin();
  peg$result = peg$startRuleFunction();

  if (peg$result !== peg$FAILED && peg$currPos === input.length) {
    return peg$result;
  }
  if (peg$result !== peg$FAILED && peg$currPos < input.length) {
    peg$expect(peg$endExpectation());
  }

  throw peg$buildError();
}

export {
  peg$SyntaxError as SyntaxError,
  peg$parse as parse,
};

export default {
  SyntaxError: peg$SyntaxError,
  parse: peg$parse,
};
