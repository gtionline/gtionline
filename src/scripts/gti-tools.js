/* eslint-disable */

'use strict';

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (let i = 0; i < props.length; i++) {
    let descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    let arr2
    let i
    for (i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
    return arr2;
  }
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

// Generated by PEG.js v0.11.0-master.f69239d, https://pegjs.org/
function peg$subclass(child, parent) {
  function C() {
    this.constructor = child;
  }

  C.prototype = parent.prototype;
  child.prototype = new C();
}

function peg$SyntaxError(message, expected, found, location) {
  this.message = message;
  this.expected = expected;
  this.found = found;
  this.location = location;
  this.name = "SyntaxError"; // istanbul ignore next

  if (typeof Error.captureStackTrace === "function") {
    Error.captureStackTrace(this, peg$SyntaxError);
  }
}

peg$subclass(peg$SyntaxError, Error);

peg$SyntaxError.buildMessage = function (expected, found) {
  const DESCRIBE_EXPECTATION_FNS = {
    literal: function literal(expectation) {
      return "\"" + literalEscape(expectation.text) + "\"";
    },
    "class": function _class(expectation) {
      const escapedParts = expectation.parts.map(function (part) {
        return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
      });
      return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
    },
    any: function any() {
      return "any character";
    },
    end: function end() {
      return "end of input";
    },
    other: function other(expectation) {
      return expectation.description;
    },
    not: function not(expectation) {
      return "not " + describeExpectation(expectation.expected);
    }
  };

  function hex(ch) {
    return ch.charCodeAt(0).toString(16).toUpperCase();
  }

  function literalEscape(s) {
    return s.replace(/\\/g, "\\\\").replace(/"/g, "\\\"").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function (ch) {
      return "\\x0" + hex(ch);
    }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
      return "\\x" + hex(ch);
    });
  }

  function classEscape(s) {
    return s.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function (ch) {
      return "\\x0" + hex(ch);
    }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
      return "\\x" + hex(ch);
    });
  }

  function describeExpectation(expectation) {
    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
  }

  function describeExpected(expected) {
    const descriptions = expected.map(describeExpectation);
    let i, j;
    descriptions.sort();

    if (descriptions.length > 0) {
      for (i = 1, j = 1; i < descriptions.length; i++) {
        if (descriptions[i - 1] !== descriptions[i]) {
          descriptions[j] = descriptions[i];
          j++;
        }
      }

      descriptions.length = j;
    }

    switch (descriptions.length) {
      case 1:
        return descriptions[0];

      case 2:
        return descriptions[0] + " or " + descriptions[1];

      default:
        return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
    }
  }

  function describeFound(found) {
    return found ? "\"" + literalEscape(found) + "\"" : "end of input";
  }

  return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
};

function numToChar(num) {
  if (0 <= num && num <= 9) {
    return String.fromCharCode(num + '0'.charCodeAt(0));
  }

  if (10 <= num && num <= 35) {
    return String.fromCharCode(num + 'A'.charCodeAt(0));
  }

  return '';
}

const Number =
  /*#__PURE__*/
  function () {
    function Number(base, representation) {
      const off = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      const isNegative = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

      _classCallCheck(this, Number);

      this.offset = off;
      this.isNegative = isNegative;
      this.base = base;
      this.arr = null;
      this.stringRepresentation = null;

      this._checkArray(representation);

      this.arr = _toConsumableArray(representation);

      this._normalizeOffset();

      this._optimizeArray();

      this.stringRepresentation = this._constructString(this.arr);
    }

    _createClass(Number, [{
      key: "_normalizeOffset",
      value: function _normalizeOffset() {
        while (this.offset < 0) {
          this.arr.push(0);
          this.offset++;
        }
      }
    }, {
      key: "_optimizeArray",
      value: function _optimizeArray() {
        while (this.arr.length > this.offset + 1 && this.arr[0] === 0) {
          this.arr.splice(0, 1);
        }

        while (this.offset > 0 && this.arr[this.arr.length - 1] === 0) {
          this.arr.splice(this.arr.length - 1, 1);
          this.offset--;
        }
      }
    }, {
      key: "_checkArray",
      value: function _checkArray(arr) {
        for (let i = 0; i < arr.length; i++) {
          if (arr[i] < 0 || this.base <= arr[i]) {
            return false;
          }
        }

        return true;
      }
    }, {
      key: "_constructString",
      value: function _constructString(arr) {
        let result = "";
        for (let i = 0; i < arr.length; i++) {
          result += numToChar(arr[i]);

          if (this.offset !== 0 && arr.length - 1 - i === this.offset) {
            result += '.';
          }
        }

        if (this.isNegative) {
          result = '-' + result;
        }

        return result;
      }
    }]);

    return Number;
  }();

const ComparisonBaseN =
  /*#__PURE__*/
  function () {
    function ComparisonBaseN(n1, n2) {
      _classCallCheck(this, ComparisonBaseN);

      if (n1.base !== n2.base) {
        console.log("ComparisonBaseN(Number, Number): Base of n1(".concat(n1.base, ") and base of n2(").concat(n2.base, ") not compatible."));
      }

      this.result = this._compare(n1, n2);
    }

    _createClass(ComparisonBaseN, [{
      key: "_compare",
      value: function _compare(n1, n2) {
        if (n1.arr.length === 1 && n2.arr.length === 1 && n1.arr[0] === 0 && n1.arr[0] === 0) {
          return 0;
        }

        if (n1.isNegative && !n2.isNegative) {
          return -1;
        }

        if (!n1.isNegative && n2.isNegative) {
          return 1;
        }

        const mult = n1.isNegative && n2.isNegative ? -1 : 1;

        if (n1.arr.length - n1.offset > n2.arr.length - n2.offset) {
          return mult;
        }

        if (n1.arr.length - n1.offset < n2.arr.length - n2.offset) {
          return mult * -1;
        }

        let i = 0;

        while (i < n1.arr.length || i < n2.arr.length) {
          const a = i < n1.arr.length ? n1.arr[i] : 0;
          const b = i < n2.arr.length ? n2.arr[i] : 0;

          if (a > b) {
            return mult;
          }

          if (b > a) {
            return mult * -1;
          }

          i++;
        }

        return 0;
      }
    }, {
      key: "getResult",
      value: function getResult() {
        return this.result;
      }
    }]);

    return ComparisonBaseN;
  }();

const Algorithm =
  /*#__PURE__*/
  function () {
    function Algorithm() {
      _classCallCheck(this, Algorithm);

      this.start = null;
      this.curr = null;
    }

    _createClass(Algorithm, [{
      key: "step",
      value: function step(name) {
        if (this.curr == null) {
          this.start = new Step(name);
          this.curr = this.start;
          return this;
        }

        this.curr.next = new Step(name);
        this.curr = this.curr.next;
        return this;
      }
    }, {
      key: "saveVariable",
      value: function saveVariable(name, value) {
        this.curr.addDataPoint(name, value);
        return this;
      }
    }]);

    return Algorithm;
  }();

const Step =
/*#__PURE__*/
function () {
  function Step(name) {
    _classCallCheck(this, Step);

    this.name = name;
    this.data = {};
    this.next = null;
  }

  _createClass(Step, [{
    key: "addDataPoint",
    value: function addDataPoint(name, value) {
      this.data[name] = value;
    }
  }]);

  return Step;
}();

const SubtractionBaseN =
/*#__PURE__*/
function () {
  function SubtractionBaseN(n1, n2) {
    _classCallCheck(this, SubtractionBaseN);

    if (n1.base !== n2.base) {
      console.log("Subtraction(Number, Number): Base of n1(".concat(n1.base, ") and base of n2(").concat(n2.base, ") not compatible."));
      process.exit(1);
    }

    this.watcher = null;
    this.result = this._subtract(n1, n2);
  }

  _createClass(SubtractionBaseN, [{
    key: "_subtract",
    value: function _subtract(n1, n2) {
      this.watcher = new Algorithm();

      if (!n1.isNegative && n2.isNegative || n1.isNegative && !n2.isNegative) {
        const addition = new AdditionBaseN(n1, Number(n2.base, n2.arr, n2.offset, !n2.isNegative));
        this.watcher = this.watcher.step("OperatorSwitch").saveVariable("addition", addition.watcher);
        return addition.getResult();
      }

      const base = n1.base;
      const comp = new ComparisonBaseN(Number(n1.base, n1.arr, n1.offset, false), Number(n2.base, n2.arr, n2.offset, false)).getResult();
      let isNegative;
      let op1;
      let op2;

      if (comp >= 0) {
        // |n1| >= |n2|
        op1 = n1;
        op2 = n2;
        isNegative = n1.isNegative && n2.isNegative;
      } else {
        op1 = n2;
        op2 = n1;
        isNegative = !(n1.isNegative && n2.isNegative);
      }

      this.watcher.step("GetSign").saveVariable('compareValue', comp).saveVariable('signN1', n1.isNegative).saveVariable('signN2', n2.isNegative).saveVariable('isNegative', isNegative);

      const op1Arr = _toConsumableArray(op1.arr);

      const op2Arr = _toConsumableArray(op2.arr);

      const offset = Math.max(op1.offset, op2.offset);

      if (op1.offset < offset) {
        op1Arr.push.apply(op1Arr, _toConsumableArray(Array(offset - op1.offset).fill(0)));
      }

      if (op2.offset < offset) {
        op2Arr.push.apply(op2Arr, _toConsumableArray(Array(offset - op2.offset).fill(0)));
      }

      const length = Math.max(op1Arr.length, op2Arr.length);

      if (op1Arr.length < length) {
        op1Arr.unshift.apply(op1Arr, _toConsumableArray(Array(length - op1Arr.length).fill(0)));
      }

      if (op2Arr.length < length) {
        op2Arr.unshift.apply(op2Arr, _toConsumableArray(Array(length - op2Arr.length).fill(0)));
      }

      let overflow = [];
      let _final = [];
      overflow.unshift(0);

      for (let i = length - 1; i >= 0; i--) {
        const m = op1Arr[i] - op2Arr[i] - overflow[0];

        _final.unshift((m + base) % base);

        if (m < 0) {
          overflow.unshift(1);
        } else {
          overflow.unshift(0);
        }
      }

      const result = Number(base, _final, offset, isNegative);
      this.watcher.step("Subtraction").saveVariable('op1', op1).saveVariable('op2', op2).saveVariable('op1Arr', _toConsumableArray(op1Arr)).saveVariable('op2Arr', _toConsumableArray(op2Arr)).saveVariable('carryArr', [].concat(overflow)).saveVariable('resultArr', [].concat(_final)).saveVariable('result', result);
      return Number(base, _final, offset, isNegative);
    }
  }, {
    key: "getResult",
    value: function getResult() {
      return this.result;
    }
  }]);

  return SubtractionBaseN;
}();

const AdditionBaseN =
/*#__PURE__*/
function () {
  function AdditionBaseN(n1, n2) {
    _classCallCheck(this, AdditionBaseN);

    if (n1.base !== n2.base) {
      console.log("Addition(Number, Number): Base of n1(".concat(n1.base, ") and base of n2(").concat(n2.base, ") not compatible."));
    }

    this.watcher = null;
    this.result = this._add(n1, n2);
  }

  _createClass(AdditionBaseN, [{
    key: "_add",
    value: function _add(n1, n2) {
      this.watcher = new Algorithm();

      if (!n1.isNegative && n2.isNegative) {
        // Subtract abs(n2) from n1.
        const subtraction = new SubtractionBaseN(n1, Number(n2.base, n2.arr, n2.offset));
        this.watcher = this.watcher.step("OperatorSwitch").saveVariable("subtraction", subtraction.watcher);
        return subtraction.getResult();
      }

      if (n1.isNegative && !n2.isNegative) {
        // Subtract abs(n1) from n2.
        const _subtraction = new SubtractionBaseN(n2, Number(n1.base, n1.arr, n1.offset)).getResult();

        this.watcher = this.watcher.step("OperatorSwitch").saveVariable("subtraction", _subtraction.watcher);
        return _subtraction;
      }

      const base = n1.base; // If both n1 and n2 are negative the result must also be negative.

      const isNegative = n1.isNegative && n2.isNegative;
      this.watcher.step("GetSign").saveVariable('signN1', n1.isNegative).saveVariable('signN2', n2.isNegative).saveVariable('isNegative', isNegative);

      const n1Arr = _toConsumableArray(n1.arr);

      const n2Arr = _toConsumableArray(n2.arr);

      const offset = Math.max(n1.offset, n2.offset);

      if (n1.offset < offset) {
        n1Arr.push.apply(n1Arr, _toConsumableArray(Array(offset - n1.offset).fill(0)));
      }

      if (n2.offset < offset) {
        n2Arr.push.apply(n2Arr, _toConsumableArray(Array(offset - n2.offset).fill(0)));
      }

      const length = Math.max(n1Arr.length, n2Arr.length);

      if (n1Arr.length < length) {
        n1Arr.unshift.apply(n1Arr, _toConsumableArray(Array(length - n1Arr.length).fill(0)));
      }

      if (n2Arr.length < length) {
        n2Arr.unshift.apply(n2Arr, _toConsumableArray(Array(length - n2Arr.length).fill(0)));
      }

      let overflow = [];
      let _final = [];
      overflow.unshift(0);

      for (let i = length - 1; i >= 0; i--) {
        const m = n1Arr[i] + n2Arr[i] + overflow[0];

        _final.unshift(m % base);

        overflow.unshift(Math.floor(m / base));
      }

      if (overflow[0] > 0) {
        _final.unshift(overflow[0]);
      }

      const result = new Number(base, _final, offset, isNegative);
      this.watcher.step("Addition").saveVariable('op1', n1).saveVariable('op2', n2).saveVariable('op1Arr', _toConsumableArray(n1Arr)).saveVariable('op2Arr', _toConsumableArray(n2Arr)).saveVariable('carryArr', [].concat(overflow)).saveVariable('resultArr', [].concat(_final)).saveVariable('result', result);
      return new Number(base, _final, offset, isNegative);
    }
  }, {
    key: "getResult",
    value: function getResult() {
      return this.result;
    }
  }]);

  return AdditionBaseN;
}();

const MultiplicationBaseN =
/*#__PURE__*/
function () {
  function MultiplicationBaseN(n1, n2) {
    _classCallCheck(this, MultiplicationBaseN);

    if (n1.base !== n2.base) {
      console.log("MultiplicationBaseN(Number, Number): Base of n1(".concat(n1.base, ") and base of n2(").concat(n2.base, ") are not compatible."));
    }

    this.watcher = null;
    this.result = this._multiply(n1, n2);
  }

  _createClass(MultiplicationBaseN, [{
    key: "_multiply",
    value: function _multiply(n1, n2) {
      this.watcher = new Algorithm();
      const base = n1.base;
      const isNegative = n1.isNegative && !n2.isNegative || n2.isNegative && !n1.isNegative;
      this.watcher.step("GetSign").saveVariable('signN1', n1.isNegative).saveVariable('signN2', n2.isNegative).saveVariable('isNegative', isNegative);
      let cur = new Number(base, [0], 0, false);
      const initalOffset = n1.offset - (n2.arr.length - 1 - n2.offset);
      this.watcher.step("MultInital").saveVariable('num1', n1).saveVariable('num2', n2);

      for (let i = 0; i < n2.arr.length; i++) {
        const num = new Number(base, n1.arr, i + initalOffset, false);
        const toAdd = new MultiplicationBaseNSingleDigit(num, n2.arr[i]).getResult();
        this.watcher.step("MultStep".concat(i.toString())).saveVariable('cur', cur).saveVariable('toAdd', toAdd);
        cur = new AdditionBaseN(cur, toAdd).getResult();
      }

      this.watcher.step("MultFinal").saveVariable('cur', cur);
      const result = new Number(base, cur.arr, cur.offset, isNegative);
      this.watcher.step("Result").saveVariable('result', result);
      return result;
    }
  }, {
    key: "getResult",
    value: function getResult() {
      return this.result;
    }
  }]);

  return MultiplicationBaseN;
}();

const MultiplicationBaseNSingleDigit =
/*#__PURE__*/
function () {
  function MultiplicationBaseNSingleDigit(n, d) {
    _classCallCheck(this, MultiplicationBaseNSingleDigit);

    if (d < 0 || d >= n.base) {
      console.log("MultiplicationBaseNSingleDigit(Number, Digit): Base of n(".concat(n.base, ") and d(").concat(d, ") are not compatible."));
    }

    this.result = this._multiply(n, d);
  }

  _createClass(MultiplicationBaseNSingleDigit, [{
    key: "_multiply",
    value: function _multiply(n, d) {
      const offset = n.offset;
      const base = n.base;
      const isNegative = n.isNegative;
      let overflow = [0];
      let _final = [];

      for (let i = n.arr.length - 1; i >= 0; i--) {
        const m = d * n.arr[i] + overflow[0];

        _final.unshift(m % base);

        overflow.unshift(Math.floor(m / base));
      }

      _final.unshift(overflow[0]);

      return new Number(base, _final, offset, isNegative);
    }
  }, {
    key: "getResult",
    value: function getResult() {
      return this.result;
    }
  }]);

  return MultiplicationBaseNSingleDigit;
}();

function numToChar$1(num) {
  if (0 <= num && num <= 9) {
    return String.fromCharCode(num + '0'.charCodeAt());
  }

  if (10 <= num && num <= 35) {
    return String.fromCharCode(num + 'A'.charCodeAt());
  }

  return '';
}

const NumberBaseNComplement =
/*#__PURE__*/
function () {
  function NumberBaseNComplement(base, digitNum, representation) {
    const off = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    const negate = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

    _classCallCheck(this, NumberBaseNComplement);

    this.base = base;
    this.offset = off;
    this.digitNum = digitNum;
    this.stringRepresentation = null;

    this._checkArray(representation);

    this.arr = _toConsumableArray(representation);

    this._normalizeOffset();

    this._normalizeArray();

    if (negate) {
      this.arr = this.getFlipedArray(); // Add one

      for (let i = this.arr.length - 1; i >= 0; i--) {
        if (this.arr[i] !== this.base - 1) {
          this.arr[i] += 1;
          break;
        } else {
          this.arr[i] = 0;
        }
      }

      this._normalizeOffset();

      this._normalizeArray();
    }

    this.stringRepresentation = this._constructString(this.arr);
  }

  _createClass(NumberBaseNComplement, [{
    key: "_normalizeOffset",
    value: function _normalizeOffset() {
      while (this.offset < 0) {
        this.arr.push(0);
        this.offset++;
      }
    }
  }, {
    key: "_normalizeArray",
    value: function _normalizeArray() {
      // Delete zeros from right.
      while (this.offset > 0 && this.arr[this.arr.length - 1] === 0) {
        this.arr.splice(this.arr.length - 1, 1);
        this.offset--;
      } // Bring array to the right size.


      if (this.arr.length > this.digitNum + this.offset) {
        this.arr.splice(0, this.arr.length - (this.digitNum + this.offset));
      } else {
        let _this$arr;

        (_this$arr = this.arr).unshift.apply(_this$arr, _toConsumableArray(Array(this.digitNum + this.offset - this.arr.length).fill(0)));
      }
    }
  }, {
    key: "_checkArray",
    value: function _checkArray(arr) {
      for (let i = 0; i < arr.length; i++) {
        if (arr[i] < 0 || this.base <= arr[i]) {
          return false;
        }
      }

      return true;
    }
  }, {
    key: "_constructString",
    value: function _constructString(arr) {
      let result = "";

      for (let i = 0; i < arr.length; i++) {
        result += numToChar$1(arr[i]);

        if (i === this.digitNum - 1 && this.offset > 0) {
          result += '.';
        }
      }

      return result;
    }
  }, {
    key: "getFlipedArray",
    value: function getFlipedArray() {
      let result = [];

      for (let i = 0; i < this.arr.length; i++) {
        result.push(this.base - 1 - this.arr[i]);
      }

      return result;
    }
  }, {
    key: "isNegative",
    value: function isNegative() {
      return this.arr[0] >= Math.ceil(this.base / 2);
    }
  }, {
    key: "translate",
    value: function translate(newDigitNum) {
      if (newDigitNum <= this.digitNum) {
        return new NumberBaseNComplement(this.base, newDigitNum, _toConsumableArray(this.arr).splice(0, this.digitNum - newDigitNum), this.offset);
      } // Sign extend.


      const sign = this.isNegative() ? this.base - 1 : 0;

      let arrCopy = _toConsumableArray(this.arr);

      arrCopy.unshift.apply(arrCopy, _toConsumableArray(Array(newDigitNum - this.digitNum).fill(sign)));
      return new NumberBaseNComplement(this.base, newDigitNum, arrCopy, this.offset);
    }
  }]);

  return NumberBaseNComplement;
}();

const AdditionBaseNComplement =
/*#__PURE__*/
function () {
  function AdditionBaseNComplement(n1, n2) {
    _classCallCheck(this, AdditionBaseNComplement);

    if (n1.base !== n2.base) {
      console.log("AdditionBaseNComplement(Number, Number): Base of n1(".concat(n1.base, ") and base of n2(").concat(n2.base, ") not compatible."));
      process.exit(1);
    }

    if (n1.digitNum !== n2.digitNum) {
      console.log("AdditionBaseNComplement(Number, Number): DigitNum of n1(".concat(n1.digitNum, ") and digitNum of n2(").concat(n2.digitNum, ") not compatible."));
      process.exit(1);
    }

    this.producedOverflow = false;
    this.watcher = null;
    this.result = this._add(n1, n2);
  }

  _createClass(AdditionBaseNComplement, [{
    key: "_add",
    value: function _add(n1, n2) {
      this.watcher = new Algorithm();
      const base = n1.base;
      const digitNum = n1.digitNum;

      let n1Arr = _toConsumableArray(n1.arr);

      let n2Arr = _toConsumableArray(n2.arr);

      const offset = Math.max(n1.offset, n2.offset);

      if (n1.offset < offset) {
        n1Arr.push.apply(n1Arr, _toConsumableArray(Array(offset - n1.offset).fill(0)));
      }

      if (n2.offset < offset) {
        n2Arr.push.apply(n2Arr, _toConsumableArray(Array(offset - n2.offset).fill(0)));
      }

      let overflow = [];
      let _final = [];
      overflow.unshift(0);

      for (let i = n1Arr.length - 1; i >= 0; i--) {
        const m = n1Arr[i] + n2Arr[i] + overflow[0];

        _final.unshift(m % base);

        overflow.unshift(Math.floor(m / base));
      }

      if (overflow[0] > 0) {
        _final.unshift(overflow[0]);
      }

      const result = new NumberBaseNComplement(base, digitNum, _final, offset);
      const overflowPossible = n1.isNegative() && n2.isNegative() || !n1.isNegative() && !n2.isNegative();
      const signChanged = overflowPossible && n1.isNegative() && !result.isNegative() || !n1.isNegative() && result.isNegative();
      this.producedOverflow = overflow[0] > 0 && signChanged;
      this.watcher.step("Addition").saveVariable('op1', n1).saveVariable('op2', n2).saveVariable('op1Arr', _toConsumableArray(n1Arr)).saveVariable('op2Arr', _toConsumableArray(n2Arr)).saveVariable('carryArr', [].concat(overflow)).saveVariable('resultArr', [].concat(_final)).saveVariable('result', result).saveVariable('overflow', this.producedOverflow);
      return result;
    }
  }, {
    key: "getResult",
    value: function getResult() {
      return this.result;
    }
  }]);

  return AdditionBaseNComplement;
}();

var MultiplicationBaseNComplement =
/*#__PURE__*/
function () {
  function MultiplicationBaseNComplement(n1, n2) {
    _classCallCheck(this, MultiplicationBaseNComplement);

    if (n1.base !== n2.base) {
      console.log("MultiplicationBaseNComplement(Number, Number): Base of n1(".concat(n1.base, ") and base of n2(").concat(n2.base, ") are not compatible."));
    }

    if (n1.digitNum !== n2.digitNum) {
      console.log("MultiplicationBaseNComplement(Number, Number): DigitNum of n1(".concat(n1.digitNum, ") and digitNum of n2(").concat(n2.digitNum, ") are not compatible."));
    }

    this.watcher = null;
    this.producedOverflow = false;
    this.result = this._multiply(n1, n2);
  }

  _createClass(MultiplicationBaseNComplement, [{
    key: "_multiply",
    value: function _multiply(n1, n2) {
      this.watcher = new Algorithm();
      const base = n1.base;
      const offset = Math.max(n1.offset, n2.offset);
      const digitsToTake = 2 * (n1.digitNum + offset);
      this.watcher.step("DetermineSize").saveVariable('n1Offset', n1.offset).saveVariable('n2Offset', n2.offset).saveVariable('digitNum', n1.digitNum).saveVariable('offset', offset).saveVariable('digitsToTake', digitsToTake);
      n1 = n1.translate(digitsToTake - offset);
      n2 = n2.translate(digitsToTake - offset);

      let op1Arr = _toConsumableArray(n1.arr);

      let op2Arr = _toConsumableArray(n2.arr);

      op1Arr.push.apply(op1Arr, _toConsumableArray(Array(Math.max(n2.offset - n1.offset, 0)).fill(0)));
      op2Arr.push.apply(op2Arr, _toConsumableArray(Array(Math.max(n1.offset - n2.offset, 0)).fill(0)));
      const op1 = new Number(n1.base, op1Arr, offset, false);
      const op2 = new Number(n2.base, op2Arr, offset, false);
      const operation = new MultiplicationBaseN(op1, op2);
      const result = operation.getResult();
      this.watcher.step("Multiply").saveVariable('multiplication', operation.watcher);

      let resultArr = _toConsumableArray(result.arr);

      resultArr.push.apply(resultArr, _toConsumableArray(Array(Math.max(2 * offset - result.offset, 0)).fill(0)));

      if (resultArr.length < digitsToTake) {
        resultArr.unshift.apply(resultArr, _toConsumableArray(Array(digitsToTake - resultArr.length).fill(0)));
      }

      if (resultArr.length > digitsToTake) {
        resultArr.splice(0, resultArr.length - digitsToTake);
      }

      const finalResult = new NumberBaseNComplement(base, digitsToTake - 2 * offset, resultArr, 2 * offset);
      this.watcher.step("Result").saveVariable('digitsToTake', digitsToTake).saveVariable('result', finalResult);
      return finalResult;
    }
  }, {
    key: "getResult",
    value: function getResult() {
      return this.result;
    }
  }]);

  return MultiplicationBaseNComplement;
}();

function numToChar$2(num) {
  if (0 <= num && num <= 9) {
    return String.fromCharCode(num + '0'.charCodeAt());
  }

  if (10 <= num && num <= 35) {
    return String.fromCharCode(num + 'A'.charCodeAt());
  }

  return '';
}

function charToNum(chr) {
  if ('0'.charCodeAt() <= chr.charCodeAt() && chr.charCodeAt() <= '9'.charCodeAt()) {
    return chr.charCodeAt() - '0'.charCodeAt();
  }

  if ('A'.charCodeAt() <= chr.charCodeAt() && chr.charCodeAt() <= 'Z') {
    return chr.charCodeAt() - 'A'.charCodeAt() + 10;
  }

  return -1;
}

export function getIEEEFromString(expBitNum, str) {
  if (str.length <= expBitNum + 2) {
    console.log("getIEEEFromString(expBitNum, str): Given string is not compatible with the given number of expBitNum.");
    process.exit(1);
  }

  for (let i = 0; i < str.length; i++) {
    if (str[i] === ' ') continue;
    const n = charToNum(str[i]);

    if (n < 0 || n >= 2) {
      console.log("getIEEEFromString(expBitNum, str): Given string is not compatible with base 2.");
      process.exit(1);
    }
  }

  let arr = [];

  for (let i = 0; i < str.length; i++) {
    if (str[i] === ' ') continue;
    arr.push(charToNum(str[i]));
  }

  return new NumberIEEE(expBitNum, arr.length - expBitNum - 1, arr);
} // Representation of a number in N's complement (Up to digitNum digits)

const NumberIEEE =
/*#__PURE__*/
function () {
  function NumberIEEE(expBitNum, manBitNum, representation) {
    _classCallCheck(this, NumberIEEE);

    if (expBitNum <= 0 || manBitNum <= 0) {
      console.log("IEEENumber(number, number, arr): Invalid number of bits for exponent and mantissa.");
    }

    this.expBitNum = expBitNum;
    this.manBitNum = manBitNum;
    this.bitNum = expBitNum + manBitNum + 1;

    this._checkArray(representation);

    this.arr = _toConsumableArray(representation);
    this.sign = this.arr[0];
    this.bias = (1 << expBitNum - 1) - 1;
    this.E = this._constructE();
    this.M = this._constructM();
    this.isNaN = this.E === 1 << expBitNum && this.M !== 0;
    this.isInfinity = this.E === 1 << expBitNum && this.M === 0;
    this.isSmall = this.E === 0 && this.M !== 0;
    this.isZero = this.E === 0 && this.M === 0;
    this.exponent = this._constructExponent();
    this.mantissa = this._constructMantissa();
    this.exponentBits = this._constructExponentBits();
    this.mantissaBits = this._constructMantissaBits();
    this.bitString = this._constructBitString();
    this.valueString = this._constructValString();
  }

  _createClass(NumberIEEE, [{
    key: "_checkArray",
    value: function _checkArray(arr) {
      if (arr.length !== this.bitNum) {
        return false;
      }

      for (let i = 0; i < arr.length; i++) {
        if (arr[i] < 0 || 2 <= arr[i]) {
          return false;
        }
      }

      return true;
    }
  }, {
    key: "_constructBitString",
    value: function _constructBitString() {
      let result = "";
      let count = 0;

      for (let i = 0; i < this.arr.length; i++) {
        result += numToChar$2(this.arr[i]);

        if (i === 0 || i === this.expBitNum) {
          count = 0;
          result += " ";
        }

        if (count % 4 === 0) {
          result += " ";
        }

        count++;
      }

      return result;
    }
  }, {
    key: "_constructValString",
    value: function _constructValString() {
      const sign = this.arr[0] === 0 ? '+' : '-';

      if (this.isNan) {
        return 'NaN';
      }

      if (this.isInfinity) {
        return "".concat(sign, "inf");
      }

      if (this.isZero) {
        return "".concat(sign, "0");
      }

      return "".concat(sign).concat(this.mantissa, "e").concat(this.exponent);
    }
  }, {
    key: "_constructE",
    value: function _constructE() {
      let result = 0;

      for (let i = 1; i < 1 + this.expBitNum; i++) {
        result *= 2;
        result += this.arr[i];
      }

      return result;
    }
  }, {
    key: "_constructM",
    value: function _constructM() {
      let result = 0.0;

      for (let i = this.bitNum - 1; i >= 1 + this.expBitNum; i--) {
        result /= 2.0;
        result += this.arr[i];
      }

      result /= 2.0;
      return result;
    }
  }, {
    key: "_constructExponent",
    value: function _constructExponent() {
      return this.E - this.bias;
    }
  }, {
    key: "_constructMantissa",
    value: function _constructMantissa() {
      if (this.isSmall || this.isZero) {
        return this.M;
      }

      return 1 + this.M;
    }
  }, {
    key: "_constructExponentBits",
    value: function _constructExponentBits() {
      let result = _toConsumableArray(this.arr);

      result.splice(0, 1);
      result.splice(1 + this.expBitNum, this.manBitNum);
      return result;
    }
  }, {
    key: "_constructMantissaBits",
    value: function _constructMantissaBits() {
      const firstBit = this.isSmall || this.isZero ? 0 : 1;

      let result = _toConsumableArray(this.arr);

      result.splice(0, 1 + this.expBitNum);
      result.unshift(firstBit);
      return result;
    }
  }]);

  return NumberIEEE;
}();

export var AdditionIEEE =
/*#__PURE__*/
function () {
  function AdditionIEEE(n1, n2) {
    _classCallCheck(this, AdditionIEEE);

    if (n1.expBitNum !== n2.expBitNum) {
      console.log("AdditionIEEE(Number, Number): expBitNum of n1(".concat(n1.expBitNum, ") and expBitNum of n2(").concat(n2.expBitNum, ") not compatible."));
    }

    if (n1.manBitNum !== n2.manBitNum) {
      console.log("AdditionIEEE(Number, Number): manBitNum of n1(".concat(n1.manBitNum, ") and manBitNum of n2(").concat(n2.manBitNum, ") not compatible."));
    }

    this.producedOverflow = false;
    this.result = this._add(n1, n2);
  }

  _createClass(AdditionIEEE, [{
    key: "_add",
    value: function _add(n1, n2) {
      const expBitNum = n1.expBitNum;
      const manBitNum = n1.manBitNum;
      const bitNum = n1.bitNum; // Edgecases:

      if (n1.isNaN || n2.isNaN || n1.isInfinity && n2.isInfinity && n1.sign !== n2.sign) {
        // Return NaN
        return new NumberIEEE(expBitNum, manBitNum, Array(bitNum).fill(1));
      }

      if (n1.isInfinity || n2.isInfinity) {
        // Return Infinty
        const _sign = n1.isInfinity ? n1.sign : n2.sign;

        let infArray = [_sign];
        infArray.push.apply(infArray, _toConsumableArray(Array(expBitNum).fill(1)));
        infArray.push.apply(infArray, _toConsumableArray(Array(manBitNum).fill(0)));
        return new NumberIEEE(expBitNum, manBitNum, infArray);
      }
      /*
      if(n1.isZero || n2.isZero){
        // Return other number
        let sign = n1.isInfinity ? n1.sign : n2.sign;
        let arr = [...(n1.isZero ? n2.arr : n1.arr)];
        return new NumberIEEE(expBitNum, manBitNum, arr);
      }
      */
      // Get unnormalized  exponent


      const anchorExp = n1.exponent;
      const difference = n2.exponent - n1.exponent;
      const digitNum = 3 + Math.max(difference, 0);
      const op1 = new NumberBaseNComplement(2, digitNum, n1.mantissaBits, n1.manBitNum, n1.sign === 1);
      const op2 = new NumberBaseNComplement(2, digitNum, n2.mantissaBits, n2.manBitNum - difference, n2.sign === 1);
      const additionResult = new AdditionBaseNComplement(op1, op2).getResult();
      console.log(n1.mantissaBits.join(' '));
      console.log(n2.mantissaBits.join(' '));
      console.log(op1.stringRepresentation);
      console.log(op2.stringRepresentation);
      console.log(additionResult.stringRepresentation);
      let sign;
      let unnormalizedMantissa;

      if (additionResult.isNegative()) {
        sign = 1;
        const additionResultInverted = new NumberBaseNComplement(2, additionResult.digitNum, additionResult.arr, additionResult.offset, true);
        unnormalizedMantissa = additionResultInverted.arr;
      } else {
        sign = 0;
        unnormalizedMantissa = _toConsumableArray(additionResult.arr);
      }

      let cDigits = digitNum;

      while (cDigits > 1 && unnormalizedMantissa[0] === 0) {
        unnormalizedMantissa.splice(0, 1);
        cDigits--;
      } // Calculate shift
      // Positive: Rightshift | Negative: Leftshift

      let shift;

      if (cDigits >= 1) {
        shift = cDigits - 1;
      } else {
        shift = 0;

        for (let i = 1; i < unnormalizedMantissa.length; i++) {
          shift--;

          if (unnormalizedMantissa[i] === 1) {
            break;
          }
        }
      }

      if (shift === unnormalizedMantissa.length - 1 && unnormalizedMantissa[0] === 0) {
        // Return zero
        return new NumberIEEE(expBitNum, manBitNum, Array(bitNum).fill(0));
      }

      let normalizedMatissa = [];

      for (let i = 0; i < manBitNum; i++) {
        const access = i + Math.max(-shift, 0) + 1;
        const num = access < unnormalizedMantissa.length ? unnormalizedMantissa[access] : 0;
        normalizedMatissa.push(num);
      } // Calculate exponent


      console.log(unnormalizedMantissa.join(' '));
      console.log(normalizedMatissa.join(' '));
      console.log(anchorExp, shift);
      const finalE = anchorExp + shift + n1.bias;
      console.log(anchorExp + shift);
      let curE = finalE;
      let exponentBits = [];

      for (let i = 0; i < expBitNum; i++) {
        exponentBits.unshift(curE % 2);
        curE = Math.floor(curE / 2);
      }

      let result = [sign];
      result.push.apply(result, exponentBits);
      result.push.apply(result, normalizedMatissa);
      return new NumberIEEE(expBitNum, manBitNum, result);
    }
  }, {
    key: "getResult",
    value: function getResult() {
      return this.result;
    }
  }]);

  return AdditionIEEE;
}();

export var SubtractionIEEE =
/*#__PURE__*/
function () {
  function SubtractionIEEE(n1, n2) {
    _classCallCheck(this, SubtractionIEEE);

    if (n1.expBitNum !== n2.expBitNum) {
      console.log("SubtractionIEEE(Number, Number): expBitNum of n1(".concat(n1.expBitNum, ") and expBitNum of n2(").concat(n2.expBitNum, ") not compatible."));
    }

    if (n1.manBitNum !== n2.manBitNum) {
      console.log("SubtractionIEEE(Number, Number): manBitNum of n1(".concat(n1.manBitNum, ") and manBitNum of n2(").concat(n2.manBitNum, ") not compatible."));
    }

    this.producedOverflow = false;
    this.result = this._subtract(n1, n2);
  }

  _createClass(SubtractionIEEE, [{
    key: "_subtract",
    value: function _subtract(n1, n2) {
      let flipedArr2 = _toConsumableArray(n2.arr);

      flipedArr2[0] = flipedArr2[0] === 0 ? 1 : 0;
      const op1 = new NumberIEEE(n1.expBitNum, n1.manBitNum, n1.arr);
      const op2 = new NumberIEEE(n2.expBitNum, n2.manBitNum, flipedArr2);
      return new AdditionIEEE(op1, op2).getResult();
    }
  }, {
    key: "getResult",
    value: function getResult() {
      return this.result;
    }
  }]);

  return SubtractionIEEE;
}();

export var MultiplicationIEEE =
/*#__PURE__*/
function () {
  function MultiplicationIEEE(n1, n2) {
    _classCallCheck(this, MultiplicationIEEE);

    if (n1.expBitNum !== n2.expBitNum) {
      console.log("MultiplicationIEEE(Number, Number): expBitNum of n1(".concat(n1.expBitNum, ") and expBitNum of n2(").concat(n2.expBitNum, ") not compatible."));
    }

    if (n1.manBitNum !== n2.manBitNum) {
      console.log("MultiplicationIEEE(Number, Number): manBitNum of n1(".concat(n1.manBitNum, ") and manBitNum of n2(").concat(n2.manBitNum, ") not compatible."));
    }

    this.producedOverflow = false;
    this.result = this._multiply(n1, n2);
  }

  _createClass(MultiplicationIEEE, [{
    key: "_multiply",
    value: function _multiply(n1, n2) {
      const expBitNum = n1.expBitNum;
      const manBitNum = n1.manBitNum;
      const bitNum = n1.bitNum;
      const sign = (n1.sign && !n2.sign || !n1.sign && n2.sign) + 0; // Edgecases:

      if (n1.isNaN || n2.isNaN || n1.isInfinity && n2.isZero || n1.isZero && n2.isInfinity) {
        // Return NaN
        return new NumberIEEE(expBitNum, manBitNum, Array(bitNum).fill(1));
      }

      if (n1.isInfinity || n2.isInfinity) {
        // Return Infinty
        let infArray = [sign];
        infArray.push.apply(infArray, _toConsumableArray(Array(expBitNum).fill(1)));
        infArray.push.apply(infArray, _toConsumableArray(Array(manBitNum).fill(0)));
        return new NumberIEEE(expBitNum, manBitNum, infArray);
      }

      const op1 = new NumberBaseNComplement(2, 3, n1.mantissaBits, n1.manBitNum, false);
      const op2 = new NumberBaseNComplement(2, 3, n2.mantissaBits, n2.manBitNum, false);
      const multiplicationResult = new MultiplicationBaseNComplement(op1, op2).getResult();
      const digitNum = multiplicationResult.digitNum;

      let unnormalizedMantissa = _toConsumableArray(multiplicationResult.arr);

      let cDigits = digitNum;

      while (cDigits > 1 && unnormalizedMantissa[0] === 0) {
        unnormalizedMantissa.splice(0, 1);
        cDigits--;
      } // Calculate shift
      // Positive: Rightshift | Negative: Leftshift


      let shift;

      if (cDigits >= 1) {
        shift = cDigits - 1;
      } else {
        shift = 0;

        for (let i = 1; i < unnormalizedMantissa.length; i++) {
          shift--;

          if (unnormalizedMantissa[i] === 1) {
            break;
          }
        }
      }

      if (shift === unnormalizedMantissa.length - 1 && unnormalizedMantissa[0] === 0) {
        // Return zero
        return new NumberIEEE(expBitNum, manBitNum, Array(bitNum).fill(0));
      }

      let normalizedMatissa = [];

      for (let i = 0; i < manBitNum; i++) {
        const access = i + Math.max(-shift, 0) + 1;
        const num = access < unnormalizedMantissa.length ? unnormalizedMantissa[access] : 0;
        normalizedMatissa.push(num);
      }

      let curE = n1.E + n2.E - n1.bias + shift;
      let exponentBits = [];

      for (let i = 0; i < expBitNum; i++) {
        exponentBits.unshift(curE % 2);
        curE = Math.floor(curE / 2);
      }

      let result = [sign];
      result.push.apply(result, exponentBits);
      result.push.apply(result, normalizedMatissa);
      return new NumberIEEE(expBitNum, manBitNum, result);
    }
  }, {
    key: "getResult",
    value: function getResult() {
      return this.result;
    }
  }]);

  return MultiplicationIEEE;
}();

//export * from './boolean/index.js';
/*
let num1 = getBaseNComplementFromString(2, 4,"0101");
let num2 = getBaseNComplementFromString(2, 4,"1011");



let op = new AdditionBaseNComplement(num1, num2);

console.log((new AdditionBaseNComplementToLatex(op.watcher)).getResult());
*/

/*
// Tests Addition
let x1 = getIEEEFromString(8, "1  0111 1011 0101 1110 0000 0000 0000 000");
let x2 = getIEEEFromString(8, "0  1000 0000 1011 0011 1010 1110 0101 000");
let x3 = getIEEEFromString(8, "0  1010 0101 0000 0101 1100 0100 0000 000");
let x4 = getIEEEFromString(8, "1  0101 1010 0101 1000 0001 0000 0000 000");
let x5 = getIEEEFromString(8, "1  0000 0000 0000 0000 0000 0000 0000 000");

//console.log(`x1: ${x1.bitString}|${x1.valueString}`);

let x6 = (new AdditionIEEE(x1, x3)).getResult();
let x7 = (new AdditionIEEE(x4, x2)).getResult();
let x8 = (new AdditionIEEE(x1, x4)).getResult();
let x9 = (new AdditionIEEE(x3, x6)).getResult();
let x10 = (new AdditionIEEE(x7, x2)).getResult();
let x11 = (new AdditionIEEE(x5, x1)).getResult();

console.log(`x1: ${x1.bitString}|${x1.valueString}`);
console.log(`x2: ${x2.bitString}|${x2.valueString}`);
console.log(`x3: ${x3.bitString}|${x3.valueString}`);
console.log(`x4: ${x4.bitString}|${x4.valueString}`);
console.log(`x5: ${x5.bitString}|${x5.valueString}`);
console.log(`x6(x1+x3): ${x6.bitString}|${x6.valueString}`);
console.log(`x7(x2+x4): ${x7.bitString}|${x7.valueString}`);
console.log(`x8(x1+x3): ${x8.bitString}|${x8.valueString}`);
console.log(`x9(x3+x6): ${x9.bitString}|${x9.valueString}`);
console.log(`x10(x2+x7): ${x10.bitString}|${x10.valueString}`);
console.log(`x11(x1+x5): ${x11.bitString}|${x11.valueString}`);
*/
// Tests Multiplication
// Tests Addition

const x1 = getIEEEFromString(8, "0 10000001  01011001100110011001101");
const y1 = getIEEEFromString(8, "0 10000000  00001100110011001100110");
const x2 = getIEEEFromString(8, "0 10001111  10101101000011000000000");
const y2 = getIEEEFromString(8, "0 01111010  00100100111111001010010");
const x3 = getIEEEFromString(8, "0 10000111  11110101010000000101100");
const y3 = getIEEEFromString(8, "0 01110110  11010100100101010001100");
const x4 = getIEEEFromString(8, "1 00000000  00000000000000000000000");
const y4 = getIEEEFromString(8, "1 10000000  10001000000000000000000");
const z1 = new MultiplicationIEEE(x1, y1).getResult();
const z2 = new MultiplicationIEEE(x2, y2).getResult();
const z3 = new MultiplicationIEEE(x3, y3).getResult();
const z4 = new MultiplicationIEEE(x4, y4).getResult();
const z5 = new AdditionIEEE(x4, y4).getResult();
const z6 = new SubtractionIEEE(x4, y4).getResult();
console.log("x1: ".concat(x1.bitString, "|").concat(x1.valueString));
console.log("y1: ".concat(y1.bitString, "|").concat(y1.valueString));
console.log("z1: ".concat(z1.bitString, "|").concat(z1.valueString));
console.log("--------------------------");
console.log("x2: ".concat(x2.bitString, "|").concat(x2.valueString));
console.log("y2: ".concat(y2.bitString, "|").concat(y2.valueString));
console.log("z2: ".concat(z2.bitString, "|").concat(z2.valueString));
console.log("--------------------------");
console.log("x3: ".concat(x3.bitString, "|").concat(x3.valueString));
console.log("y3: ".concat(y3.bitString, "|").concat(y3.valueString));
console.log("z3: ".concat(z3.bitString, "|").concat(z3.valueString));
console.log("--------------------------");
console.log("x4: ".concat(x4.bitString, "|").concat(x4.valueString));
console.log("y4: ".concat(y4.bitString, "|").concat(y4.valueString));
console.log("z4: ".concat(z4.bitString, "|").concat(z4.valueString));
console.log("z5: ".concat(z5.bitString, "|").concat(z5.valueString));
console.log("z6: ".concat(z6.bitString, "|").concat(z6.valueString));
console.log("--------------------------");
/*
let num1 = getNumFromString(2, "1110100.110");
let num2 = getNumFromString(2, "-11100010.110");

let op = new MultiplicationBaseN(num1, num2);
//console.log(op);
console.log((new MultiplicationBaseNSignedToLatex(op.watcher)).getResult());
*/

/*
let op = new MultiplicationBaseNComplement(num1, num2);

 num = op.getResult();
console.log(num);

console.log();



let x1 = getIEEEFromString(8, "0 10011001 0000 1001 1001 0000 0000 0000");
let x2 = getIEEEFromString(8, "0 10011001 1111 1111 0000 0000 0000 0000");
let x3 = getIEEEFromString(8, "1 10010100 0011 0110 0000 0000 0000 0000");

let y1 = getIEEEFromString(7, "0 1001000 1001 1011");
let y2 = getIEEEFromString(7, "1 1001010 1110 1000");

 op = new MultiplicationIEEE(y1, y2);

console.log(op.getResult());
*/
