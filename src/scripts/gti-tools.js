/* eslint-disable */

'use strict';

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  }
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

// Generated by PEG.js v0.11.0-master.f69239d, https://pegjs.org/
function peg$subclass(child, parent) {
  function C() {
    this.constructor = child;
  }

  C.prototype = parent.prototype;
  child.prototype = new C();
}

function peg$SyntaxError(message, expected, found, location) {
  this.message = message;
  this.expected = expected;
  this.found = found;
  this.location = location;
  this.name = "SyntaxError"; // istanbul ignore next

  if (typeof Error.captureStackTrace === "function") {
    Error.captureStackTrace(this, peg$SyntaxError);
  }
}

peg$subclass(peg$SyntaxError, Error);

peg$SyntaxError.buildMessage = function (expected, found) {
  var DESCRIBE_EXPECTATION_FNS = {
    literal: function literal(expectation) {
      return "\"" + literalEscape(expectation.text) + "\"";
    },
    "class": function _class(expectation) {
      var escapedParts = expectation.parts.map(function (part) {
        return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
      });
      return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
    },
    any: function any() {
      return "any character";
    },
    end: function end() {
      return "end of input";
    },
    other: function other(expectation) {
      return expectation.description;
    },
    not: function not(expectation) {
      return "not " + describeExpectation(expectation.expected);
    }
  };

  function hex(ch) {
    return ch.charCodeAt(0).toString(16).toUpperCase();
  }

  function literalEscape(s) {
    return s.replace(/\\/g, "\\\\").replace(/"/g, "\\\"").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function (ch) {
      return "\\x0" + hex(ch);
    }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
      return "\\x" + hex(ch);
    });
  }

  function classEscape(s) {
    return s.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function (ch) {
      return "\\x0" + hex(ch);
    }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
      return "\\x" + hex(ch);
    });
  }

  function describeExpectation(expectation) {
    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
  }

  function describeExpected(expected) {
    var descriptions = expected.map(describeExpectation);
    var i, j;
    descriptions.sort();

    if (descriptions.length > 0) {
      for (i = 1, j = 1; i < descriptions.length; i++) {
        if (descriptions[i - 1] !== descriptions[i]) {
          descriptions[j] = descriptions[i];
          j++;
        }
      }

      descriptions.length = j;
    }

    switch (descriptions.length) {
      case 1:
        return descriptions[0];

      case 2:
        return descriptions[0] + " or " + descriptions[1];

      default:
        return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
    }
  }

  function describeFound(found) {
    return found ? "\"" + literalEscape(found) + "\"" : "end of input";
  }

  return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
};

function numToChar(num) {
  if (0 <= num && num <= 9) {
    return String.fromCharCode(num + '0'.charCodeAt());
  }

  if (10 <= num && num <= 35) {
    return String.fromCharCode(num + 'A'.charCodeAt());
  }

  return '';
}

var Number =
/*#__PURE__*/
function () {
  function Number(base, representation) {
    var off = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var isNegative = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

    _classCallCheck(this, Number);

    this.offset = off;
    this.isNegative = isNegative;
    this.base = base;
    this.arr = null;
    this.stringRepresentation = null;

    this._checkArray(representation);

    this.arr = _toConsumableArray(representation);

    this._normalizeOffset();

    this._optimizeArray();

    this.stringRepresentation = this._constructString(this.arr);
  }

  _createClass(Number, [{
    key: "_normalizeOffset",
    value: function _normalizeOffset() {
      while (this.offset < 0) {
        this.arr.push(0);
        this.offset++;
      }
    }
  }, {
    key: "_optimizeArray",
    value: function _optimizeArray() {
      while (this.arr.length > this.offset + 1 && this.arr[0] == 0) {
        this.arr.splice(0, 1);
      }

      while (this.offset > 0 && this.arr[this.arr.length - 1] == 0) {
        this.arr.splice(this.arr.length - 1, 1);
        this.offset--;
      }
    }
  }, {
    key: "_checkArray",
    value: function _checkArray(arr) {
      for (var i = 0; i < arr.length; i++) {
        if (arr[i] < 0 || this.base <= arr[i]) {
          return false;
        }
      }

      return true;
    }
  }, {
    key: "_constructString",
    value: function _constructString(arr) {
      var result = "";

      for (var i = 0; i < arr.length; i++) {
        result += numToChar(arr[i]);

        if (this.offset != 0 && arr.length - 1 - i == this.offset) {
          result += '.';
        }
      }

      if (this.isNegative) {
        result = '-' + result;
      }

      return result;
    }
  }]);

  return Number;
}();

var ComparisonBaseN =
/*#__PURE__*/
function () {
  function ComparisonBaseN(n1, n2) {
    _classCallCheck(this, ComparisonBaseN);

    if (n1.base != n2.base) {
      console.log("ComparisonBaseN(Number, Number): Base of n1(".concat(n1.base, ") and base of n2(").concat(n2.base, ") not compatible."));
    }

    this.result = this._compare(n1, n2);
  }

  _createClass(ComparisonBaseN, [{
    key: "_compare",
    value: function _compare(n1, n2) {
      if (n1.arr.length == 1 && n2.arr.length == 1 && n1.arr[0] == 0 && n1.arr[0] == 0) {
        return 0;
      }

      if (n1.isNegative && !n2.isNegative) {
        return -1;
      }

      if (!n1.isNegative && n2.isNegative) {
        return 1;
      }

      var mult = n1.isNegative && n2.isNegative ? -1 : 1;

      if (n1.arr.length - n1.offset > n2.arr.length - n2.offset) {
        return mult * 1;
      }

      if (n1.arr.length - n1.offset < n2.arr.length - n2.offset) {
        return mult * -1;
      }

      var i = 0;

      while (i < n1.arr.length || i < n2.arr.length) {
        var a = i < n1.arr.length ? n1.arr[i] : 0;
        var b = i < n2.arr.length ? n2.arr[i] : 0;

        if (a > b) {
          return mult * 1;
        }

        if (b > a) {
          return mult * -1;
        }

        i++;
      }

      return 0;
    }
  }, {
    key: "getResult",
    value: function getResult() {
      return this.result;
    }
  }]);

  return ComparisonBaseN;
}();

var Algorithm =
/*#__PURE__*/
function () {
  function Algorithm() {
    _classCallCheck(this, Algorithm);

    this.start = null;
    this.curr = null;
  }

  _createClass(Algorithm, [{
    key: "step",
    value: function step(name) {
      if (this.curr == null) {
        this.start = new Step(name);
        this.curr = this.start;
        return this;
      }

      this.curr.next = new Step(name);
      this.curr = this.curr.next;
      return this;
    }
  }, {
    key: "saveVariable",
    value: function saveVariable(name, value) {
      this.curr.addDataPoint(name, value);
      return this;
    }
  }]);

  return Algorithm;
}();

var Step =
/*#__PURE__*/
function () {
  function Step(name) {
    _classCallCheck(this, Step);

    this.name = name;
    this.data = {};
    this.next = null;
  }

  _createClass(Step, [{
    key: "addDataPoint",
    value: function addDataPoint(name, value) {
      this.data[name] = value;
    }
  }]);

  return Step;
}();

var SubtractionBaseN =
/*#__PURE__*/
function () {
  function SubtractionBaseN(n1, n2) {
    _classCallCheck(this, SubtractionBaseN);

    if (n1.base != n2.base) {
      console.log("Subtraction(Number, Number): Base of n1(".concat(n1.base, ") and base of n2(").concat(n2.base, ") not compatible."));
      process.exit(1);
    }

    this.watcher = null;
    this.result = this._subtract(n1, n2);
  }

  _createClass(SubtractionBaseN, [{
    key: "_subtract",
    value: function _subtract(n1, n2) {
      this.watcher = new Algorithm();

      if (!n1.isNegative && n2.isNegative || n1.isNegative && !n2.isNegative) {
        var addition = new AdditionBaseN(n1, new Number(n2.base, n2.arr, n2.offset, !n2.isNegative));
        this.watcher = this.watcher.step("OperatorSwitch").saveVariable("addition", addition.watcher);
        return addition.getResult();
      }

      var base = n1.base;
      var comp = new ComparisonBaseN(new Number(n1.base, n1.arr, n1.offset, false), new Number(n2.base, n2.arr, n2.offset, false)).getResult();
      var isNegative = null;
      var op1 = null;
      var op2 = null;

      if (comp >= 0) {
        // |n1| >= |n2|
        op1 = n1;
        op2 = n2;
        isNegative = n1.isNegative && n2.isNegative;
      } else {
        op1 = n2;
        op2 = n1;
        isNegative = !(n1.isNegative && n2.isNegative);
      }

      this.watcher.step("GetSign").saveVariable('compareValue', comp).saveVariable('signN1', n1.isNegative).saveVariable('signN2', n2.isNegative).saveVariable('isNegative', isNegative);

      var op1Arr = _toConsumableArray(op1.arr);

      var op2Arr = _toConsumableArray(op2.arr);

      var offset = Math.max(op1.offset, op2.offset);

      if (op1.offset < offset) {
        op1Arr.push.apply(op1Arr, _toConsumableArray(Array(offset - op1.offset).fill(0)));
      }

      if (op2.offset < offset) {
        op2Arr.push.apply(op2Arr, _toConsumableArray(Array(offset - op2.offset).fill(0)));
      }

      var length = Math.max(op1Arr.length, op2Arr.length);

      if (op1Arr.length < length) {
        op1Arr.unshift.apply(op1Arr, _toConsumableArray(Array(length - op1Arr.length).fill(0)));
      }

      if (op2Arr.length < length) {
        op2Arr.unshift.apply(op2Arr, _toConsumableArray(Array(length - op2Arr.length).fill(0)));
      }

      var overflow = [];
      var _final = [];
      overflow.unshift(0);

      for (var i = length - 1; i >= 0; i--) {
        var m = op1Arr[i] - op2Arr[i] - overflow[0];

        _final.unshift((m + base) % base);

        if (m < 0) {
          overflow.unshift(1);
        } else {
          overflow.unshift(0);
        }
      }

      var result = new Number(base, _final, offset, isNegative);
      this.watcher.step("Subtraction").saveVariable('op1', op1).saveVariable('op2', op2).saveVariable('op1Arr', _toConsumableArray(op1Arr)).saveVariable('op2Arr', _toConsumableArray(op2Arr)).saveVariable('carryArr', [].concat(overflow)).saveVariable('resultArr', [].concat(_final)).saveVariable('result', result);
      return new Number(base, _final, offset, isNegative);
    }
  }, {
    key: "getResult",
    value: function getResult() {
      return this.result;
    }
  }]);

  return SubtractionBaseN;
}();

var AdditionBaseN =
/*#__PURE__*/
function () {
  function AdditionBaseN(n1, n2) {
    _classCallCheck(this, AdditionBaseN);

    if (n1.base != n2.base) {
      console.log("Addition(Number, Number): Base of n1(".concat(n1.base, ") and base of n2(").concat(n2.base, ") not compatible."));
    }

    this.watcher = null;
    this.result = this._add(n1, n2);
  }

  _createClass(AdditionBaseN, [{
    key: "_add",
    value: function _add(n1, n2) {
      this.watcher = new Algorithm();

      if (!n1.isNegative && n2.isNegative) {
        // Subtract abs(n2) from n1.
        var subtraction = new SubtractionBaseN(n1, new Number(n2.base, n2.arr, n2.offset));
        this.watcher = this.watcher.step("OperatorSwitch").saveVariable("subtraction", subtraction.watcher);
        return subtraction.getResult();
      }

      if (n1.isNegative && !n2.isNegative) {
        // Subtract abs(n1) from n2.
        var _subtraction = new SubtractionBaseN(n2, new Number(n1.base, n1.arr, n1.offset)).getResult();

        this.watcher = this.watcher.step("OperatorSwitch").saveVariable("subtraction", _subtraction.watcher);
        return _subtraction;
      }

      var base = n1.base; // If both n1 and n2 are negative the result must also be negative.

      var isNegative = n1.isNegative && n2.isNegative;
      this.watcher.step("GetSign").saveVariable('signN1', n1.isNegative).saveVariable('signN2', n2.isNegative).saveVariable('isNegative', isNegative);

      var n1Arr = _toConsumableArray(n1.arr);

      var n2Arr = _toConsumableArray(n2.arr);

      var offset = Math.max(n1.offset, n2.offset);

      if (n1.offset < offset) {
        n1Arr.push.apply(n1Arr, _toConsumableArray(Array(offset - n1.offset).fill(0)));
      }

      if (n2.offset < offset) {
        n2Arr.push.apply(n2Arr, _toConsumableArray(Array(offset - n2.offset).fill(0)));
      }

      var length = Math.max(n1Arr.length, n2Arr.length);

      if (n1Arr.length < length) {
        n1Arr.unshift.apply(n1Arr, _toConsumableArray(Array(length - n1Arr.length).fill(0)));
      }

      if (n2Arr.length < length) {
        n2Arr.unshift.apply(n2Arr, _toConsumableArray(Array(length - n2Arr.length).fill(0)));
      }

      var overflow = [];
      var _final = [];
      overflow.unshift(0);

      for (var i = length - 1; i >= 0; i--) {
        var m = n1Arr[i] + n2Arr[i] + overflow[0];

        _final.unshift(m % base);

        overflow.unshift(Math.floor(m / base));
      }

      if (overflow[0] > 0) {
        _final.unshift(overflow[0]);
      }

      var result = new Number(base, _final, offset, isNegative);
      this.watcher.step("Addition").saveVariable('op1', n1).saveVariable('op2', n2).saveVariable('op1Arr', _toConsumableArray(n1Arr)).saveVariable('op2Arr', _toConsumableArray(n2Arr)).saveVariable('carryArr', [].concat(overflow)).saveVariable('resultArr', [].concat(_final)).saveVariable('result', result);
      return new Number(base, _final, offset, isNegative);
    }
  }, {
    key: "getResult",
    value: function getResult() {
      return this.result;
    }
  }]);

  return AdditionBaseN;
}();

var MultiplicationBaseN =
/*#__PURE__*/
function () {
  function MultiplicationBaseN(n1, n2) {
    _classCallCheck(this, MultiplicationBaseN);

    if (n1.base != n2.base) {
      console.log("MultiplicationBaseN(Number, Number): Base of n1(".concat(n1.base, ") and base of n2(").concat(n2.base, ") are not compatible."));
    }

    this.watcher = null;
    this.result = this._multiply(n1, n2);
  }

  _createClass(MultiplicationBaseN, [{
    key: "_multiply",
    value: function _multiply(n1, n2) {
      this.watcher = new Algorithm();
      var base = n1.base;
      var isNegative = n1.isNegative && !n2.isNegative || n2.isNegative && !n1.isNegative;
      this.watcher.step("GetSign").saveVariable('signN1', n1.isNegative).saveVariable('signN2', n2.isNegative).saveVariable('isNegative', isNegative);
      var cur = new Number(base, [0], 0, false);
      var initalOffset = n1.offset - (n2.arr.length - 1 - n2.offset);
      this.watcher.step("MultInital").saveVariable('num1', n1).saveVariable('num2', n2);

      for (var i = 0; i < n2.arr.length; i++) {
        var num = new Number(base, n1.arr, i + initalOffset, false);
        var toAdd = new MultiplicationBaseNSingleDigit(num, n2.arr[i]).getResult();
        this.watcher.step("MultStep".concat(i)).saveVariable('cur', cur).saveVariable('toAdd', toAdd);
        cur = new AdditionBaseN(cur, toAdd).getResult();
      }

      this.watcher.step("MultFinal").saveVariable('cur', cur);
      var result = new Number(base, cur.arr, cur.offset, isNegative);
      this.watcher.step("Result").saveVariable('result', result);
      return result;
    }
  }, {
    key: "getResult",
    value: function getResult() {
      return this.result;
    }
  }]);

  return MultiplicationBaseN;
}();
var MultiplicationBaseNSingleDigit =
/*#__PURE__*/
function () {
  function MultiplicationBaseNSingleDigit(n, d) {
    _classCallCheck(this, MultiplicationBaseNSingleDigit);

    if (d < 0 || d >= n.base) {
      console.log("MultiplicationBaseNSingleDigit(Number, Digit): Base of n(".concat(n.base, ") and d(").concat(d, ") are not compatible."));
    }

    this.result = this._multiply(n, d);
  }

  _createClass(MultiplicationBaseNSingleDigit, [{
    key: "_multiply",
    value: function _multiply(n, d) {
      var offset = n.offset;
      var base = n.base;
      var isNegative = n.isNegative;
      var overflow = [0];
      var _final = [];

      for (var i = n.arr.length - 1; i >= 0; i--) {
        var m = d * n.arr[i] + overflow[0];

        _final.unshift(m % base);

        overflow.unshift(Math.floor(m / base));
      }

      _final.unshift(overflow[0]);

      return new Number(base, _final, offset, isNegative);
    }
  }, {
    key: "getResult",
    value: function getResult() {
      return this.result;
    }
  }]);

  return MultiplicationBaseNSingleDigit;
}();

function numToChar$1(num) {
  if (0 <= num && num <= 9) {
    return String.fromCharCode(num + '0'.charCodeAt());
  }

  if (10 <= num && num <= 35) {
    return String.fromCharCode(num + 'A'.charCodeAt());
  }

  return '';
}

function charToNum(chr) {
  if ('0'.charCodeAt() <= chr.charCodeAt() && chr.charCodeAt() <= '9'.charCodeAt()) {
    return chr.charCodeAt() - '0'.charCodeAt();
  }

  if ('A'.charCodeAt() <= chr.charCodeAt() && chr.charCodeAt() <= 'Z') {
    return chr.charCodeAt() - 'A'.charCodeAt() + 10;
  }

  return -1;
}

function getBaseNComplementFromString(base, digitNum, str) {
  if (base < 2 || base > 36) {
    console.log("getBaseNComplementFromString(base, str): Base ".concat(base, " is not supported."));
    process.exit(1);
  }

  var pointCount = 0;

  for (var i = 0; i < str.length; i++) {
    if (str[i] == '.') {
      pointCount++;
      continue;
    }

    var n = charToNum(str[i]);

    if (n < 0 || n >= base) {
      console.log("getBaseNComplementFromString(str): Given string is not compatible with base 2.");
      process.exit(1);
    }
  }

  if (pointCount > 1) {
    console.log("getBaseNComplementFromString(base, str): Given string contains more than 1 point.");
    process.exit(1);
  }

  var arr = [];
  var offset = 0;

  for (var _i = 0; _i < str.length; _i++) {
    if (str[_i] == '.') {
      offset = str.length - _i - 1;
      continue;
    }

    arr.push(charToNum(str[_i]));
  }

  return new NumberBaseNComplement(base, digitNum, arr, offset);
} // Representation of a number in N's complement (Up to digitNum digits)

var NumberBaseNComplement =
/*#__PURE__*/
function () {
  function NumberBaseNComplement(base, digitNum, representation) {
    var off = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    var negate = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

    _classCallCheck(this, NumberBaseNComplement);

    this.base = base;
    this.offset = off;
    this.digitNum = digitNum;
    this.stringRepresentation = null;

    this._checkArray(representation);

    this.arr = _toConsumableArray(representation);

    this._normalizeOffset();

    this._normalizeArray();

    if (negate) {
      this.arr = this.getFlipedArray(); // Add one

      for (var i = this.arr.length - 1; i >= 0; i--) {
        if (this.arr[i] != this.base - 1) {
          this.arr[i] += 1;
          break;
        } else {
          this.arr[i] = 0;
        }
      }

      this._normalizeOffset();

      this._normalizeArray();
    }

    this.stringRepresentation = this._constructString(this.arr);
  }

  _createClass(NumberBaseNComplement, [{
    key: "_normalizeOffset",
    value: function _normalizeOffset() {
      while (this.offset < 0) {
        this.arr.push(0);
        this.offset++;
        this.digitNum++;
      }
    }
  }, {
    key: "_normalizeArray",
    value: function _normalizeArray() {
      // Delete zeros from right.
      while (this.offset > 0 && this.arr[this.arr.length - 1] == 0) {
        this.arr.splice(this.arr.length - 1, 1);
        this.offset--;
      } // Bring array to the right size.


      if (this.arr.length > this.digitNum + this.offset) {
        this.arr.splice(0, this.arr.length - (this.digitNum + this.offset));
      } else {
        var _this$arr;

        (_this$arr = this.arr).unshift.apply(_this$arr, _toConsumableArray(Array(this.digitNum + this.offset - this.arr.length).fill(0)));
      }
    }
  }, {
    key: "_checkArray",
    value: function _checkArray(arr) {
      for (var i = 0; i < arr.length; i++) {
        if (arr[i] < 0 || this.base <= arr[i]) {
          return false;
        }
      }

      return true;
    }
  }, {
    key: "_constructString",
    value: function _constructString(arr) {
      var result = "";

      for (var i = 0; i < arr.length; i++) {
        result += numToChar$1(arr[i]);

        if (i == this.digitNum - 1 && this.offset > 0) {
          result += '.';
        }
      }

      return result;
    }
  }, {
    key: "getFlipedArray",
    value: function getFlipedArray() {
      var result = [];

      for (var i = 0; i < this.arr.length; i++) {
        result.push(this.base - 1 - this.arr[i]);
      }

      return result;
    }
  }, {
    key: "isNegative",
    value: function isNegative() {
      return this.arr[0] >= Math.ceil(this.base / 2);
    }
  }, {
    key: "translate",
    value: function translate(newDigitNum) {
      if (newDigitNum <= this.digitNum) {
        return new NumberBaseNComplement(this.base, newDigitNum, _toConsumableArray(this.arr).splice(0, this.digitNum - newDigitNum), this.offset);
      } // Sign extend.


      var sign = this.isNegative() ? this.base - 1 : 0;

      var arrCopy = _toConsumableArray(this.arr);

      arrCopy.unshift.apply(arrCopy, _toConsumableArray(Array(newDigitNum - this.digitNum).fill(sign)));
      return new NumberBaseNComplement(this.base, newDigitNum, arrCopy, this.offset);
    }
  }]);

  return NumberBaseNComplement;
}();

var AdditionBaseNComplement =
/*#__PURE__*/
function () {
  function AdditionBaseNComplement(n1, n2) {
    _classCallCheck(this, AdditionBaseNComplement);

    if (n1.base != n2.base) {
      console.log("AdditionBaseNComplement(Number, Number): Base of n1(".concat(n1.base, ") and base of n2(").concat(n2.base, ") not compatible."));
      process.exit(1);
    }

    if (n1.digitNum != n2.digitNum) {
      console.log("AdditionBaseNComplement(Number, Number): DigitNum of n1(".concat(n1.digitNum, ") and digitNum of n2(").concat(n2.digitNum, ") not compatible."));
      process.exit(1);
    }

    this.producedOverflow = false;
    this.watcher = null;
    this.result = this._add(n1, n2);
  }

  _createClass(AdditionBaseNComplement, [{
    key: "_add",
    value: function _add(n1, n2) {
      this.watcher = new Algorithm();
      var base = n1.base;
      var digitNum = n1.digitNum;

      var n1Arr = _toConsumableArray(n1.arr);

      var n2Arr = _toConsumableArray(n2.arr);

      var offset = Math.max(n1.offset, n2.offset);

      if (n1.offset < offset) {
        n1Arr.push.apply(n1Arr, _toConsumableArray(Array(offset - n1.offset).fill(0)));
      }

      if (n2.offset < offset) {
        n2Arr.push.apply(n2Arr, _toConsumableArray(Array(offset - n2.offset).fill(0)));
      }

      var overflow = [];
      var _final = [];
      overflow.unshift(0);

      for (var i = n1Arr.length - 1; i >= 0; i--) {
        var m = n1Arr[i] + n2Arr[i] + overflow[0];

        _final.unshift(m % base);

        overflow.unshift(Math.floor(m / base));
      }

      if (overflow[0] > 0) {
        _final.unshift(overflow[0]);
      }

      var result = new NumberBaseNComplement(base, digitNum, _final, offset);
      var overflowPossible = n1.isNegative() && n2.isNegative() || !n1.isNegative() && !n2.isNegative();
      var signChanged = overflowPossible && n1.isNegative() && !result.isNegative() || !n1.isNegative() && result.isNegative();
      this.producedOverflow = overflow[0] > 0 && signChanged;
      this.watcher.step("Addition").saveVariable('op1', n1).saveVariable('op2', n2).saveVariable('op1Arr', _toConsumableArray(n1Arr)).saveVariable('op2Arr', _toConsumableArray(n2Arr)).saveVariable('carryArr', [].concat(overflow)).saveVariable('resultArr', [].concat(_final)).saveVariable('result', result).saveVariable('overflow', this.producedOverflow);
      console.log(overflow, _final);
      return result;
    }
  }, {
    key: "getResult",
    value: function getResult() {
      return this.result;
    }
  }]);

  return AdditionBaseNComplement;
}();

var MultiplicationBaseNComplement =
/*#__PURE__*/
function () {
  function MultiplicationBaseNComplement(n1, n2) {
    _classCallCheck(this, MultiplicationBaseNComplement);

    if (n1.base != n2.base) {
      console.log("MultiplicationBaseNComplement(Number, Number): Base of n1(".concat(n1.base, ") and base of n2(").concat(n2.base, ") are not compatible."));
    }

    if (n1.digitNum != n2.digitNum) {
      console.log("MultiplicationBaseNComplement(Number, Number): DigitNum of n1(".concat(n1.digitNum, ") and digitNum of n2(").concat(n2.digitNum, ") are not compatible."));
    }

    this.watcher = null;
    this.producedOverflow = false;
    this.result = this._multiply(n1, n2);
  }

  _createClass(MultiplicationBaseNComplement, [{
    key: "_multiply",
    value: function _multiply(n1, n2) {
      this.watcher = new Algorithm();
      var base = n1.base;
      var offset = Math.max(n1.offset, n2.offset);
      var digitsToTake = 2 * (n1.digitNum + offset);
      this.watcher.step("DetermineSize").saveVariable('n1Offset', n1.offset).saveVariable('n2Offset', n2.offset).saveVariable('digitNum', n1.digitNum).saveVariable('offset', offset).saveVariable('digitsToTake', digitsToTake);
      n1 = n1.translate(digitsToTake - offset);
      n2 = n2.translate(digitsToTake - offset);

      var op1Arr = _toConsumableArray(n1.arr);

      var op2Arr = _toConsumableArray(n2.arr);

      op1Arr.push.apply(op1Arr, _toConsumableArray(Array(Math.max(n2.offset - n1.offset, 0)).fill(0)));
      op2Arr.push.apply(op2Arr, _toConsumableArray(Array(Math.max(n1.offset - n2.offset, 0)).fill(0)));
      var op1 = new Number(n1.base, op1Arr, offset, false);
      var op2 = new Number(n2.base, op2Arr, offset, false);
      var operation = new MultiplicationBaseN(op1, op2);
      var result = operation.getResult();
      this.watcher.step("Multiply").saveVariable('multiplication', operation.watcher);

      var resultArr = _toConsumableArray(result.arr);

      resultArr.push.apply(resultArr, _toConsumableArray(Array(Math.max(2 * offset - result.offset, 0)).fill(0)));

      if (resultArr.length < digitsToTake) {
        resultArr.unshift.apply(resultArr, _toConsumableArray(Array(digitsToTake - resultArr.length).fill(0)));
      }

      if (resultArr.length > digitsToTake) {
        resultArr.splice(0, resultArr.length - digitsToTake);
      }

      var finalResult = new NumberBaseNComplement(base, digitsToTake - 2 * offset, resultArr, 2 * offset);
      this.watcher.step("Result").saveVariable('digitsToTake', digitsToTake).saveVariable('result', finalResult);
      return finalResult;
    }
  }, {
    key: "getResult",
    value: function getResult() {
      return this.result;
    }
  }]);

  return MultiplicationBaseNComplement;
}();

function numToChar$2(num) {
  if (0 <= num && num <= 9) {
    return String.fromCharCode(num + '0'.charCodeAt());
  }

  if (10 <= num && num <= 35) {
    return String.fromCharCode(num + 'A'.charCodeAt());
  }

  return '';
}

function charToNum$1(chr) {
  if ('0'.charCodeAt() <= chr.charCodeAt() && chr.charCodeAt() <= '9'.charCodeAt()) {
    return chr.charCodeAt() - '0'.charCodeAt();
  }

  if ('A'.charCodeAt() <= chr.charCodeAt() && chr.charCodeAt() <= 'Z') {
    return chr.charCodeAt() - 'A'.charCodeAt() + 10;
  }

  return -1;
}

export function getIEEEFromString(expBitNum, str) {
  if (str.length <= expBitNum + 2) {
    console.log("getIEEEFromString(expBitNum, str): Given string is not compatible with the given number of expBitNum.");
    process.exit(1);
  }

  for (var i = 0; i < str.length; i++) {
    if (str[i] == ' ') continue;
    var n = charToNum$1(str[i]);

    if (n < 0 || n >= 2) {
      console.log("getIEEEFromString(expBitNum, str): Given string is not compatible with base 2.");
      process.exit(1);
    }
  }

  var arr = [];

  for (var _i = 0; _i < str.length; _i++) {
    if (str[_i] == ' ') continue;
    arr.push(charToNum$1(str[_i]));
  }

  return new NumberIEEE(expBitNum, arr.length - expBitNum - 1, arr);
} // Representation of a number in N's complement (Up to digitNum digits)

var NumberIEEE =
/*#__PURE__*/
function () {
  function NumberIEEE(expBitNum, manBitNum, representation) {
    _classCallCheck(this, NumberIEEE);

    if (expBitNum <= 0 || manBitNum <= 0) {
      console.log("IEEENumber(number, number, arr): Invalid number of bits for exponent and mantissa.");
    }

    this.expBitNum = expBitNum;
    this.manBitNum = manBitNum;
    this.bitNum = expBitNum + manBitNum + 1;

    this._checkArray(representation);

    this.arr = _toConsumableArray(representation);
    this.sign = this.arr[0];
    this.bias = (1 << expBitNum - 1) - 1;
    this.E = this._constructE();
    this.M = this._constructM();
    this.isNaN = this.E == 1 << expBitNum && this.M != 0;
    this.isInfinity = this.E == 1 << expBitNum && this.M == 0;
    this.isSmall = this.E == 0 && this.M != 0;
    this.isZero = this.E == 0 && this.M == 0;
    this.exponent = this._constructExponent();
    this.mantissa = this._constructMantissa();
    this.exponentBits = this._constructExponentBits();
    this.mantissaBits = this._constructMantissaBits();
    this.bitString = this._constructBitString();
    this.valueString = this._constructValString();
  }

  _createClass(NumberIEEE, [{
    key: "_checkArray",
    value: function _checkArray(arr) {
      if (arr.length != this.bitNum) {
        return false;
      }

      for (var i = 0; i < arr.length; i++) {
        if (arr[i] < 0 || 2 <= arr[i]) {
          return false;
        }
      }

      return true;
    }
  }, {
    key: "_constructBitString",
    value: function _constructBitString() {
      var result = "";
      var count = 0;

      for (var i = 0; i < this.arr.length; i++) {
        result += numToChar$2(this.arr[i]);

        if (i == 0 || i == this.expBitNum) {
          count = 0;
          result += " ";
        }

        if (count % 4 == 0) {
          result += " ";
        }

        count++;
      }

      return result;
    }
  }, {
    key: "_constructValString",
    value: function _constructValString() {
      var sign = this.arr[0] == 0 ? '+' : '-';

      if (this.isNan) {
        return 'NaN';
      }

      if (this.isInfinity) {
        return "".concat(sign, "inf");
      }

      if (this.isZero) {
        return "".concat(sign, "0");
      }

      return "".concat(sign).concat(this.mantissa, "e").concat(this.exponent);
    }
  }, {
    key: "_constructE",
    value: function _constructE() {
      var result = 0;

      for (var i = 1; i < 1 + this.expBitNum; i++) {
        result *= 2;
        result += this.arr[i];
      }

      return result;
    }
  }, {
    key: "_constructM",
    value: function _constructM() {
      var result = 0.0;

      for (var i = this.bitNum - 1; i >= 1 + this.expBitNum; i--) {
        result /= 2.0;
        result += this.arr[i];
      }

      result /= 2.0;
      return result;
    }
  }, {
    key: "_constructExponent",
    value: function _constructExponent() {
      return this.E - this.bias;
    }
  }, {
    key: "_constructMantissa",
    value: function _constructMantissa() {
      if (this.isSmall || this.isZero) {
        return this.M;
      }

      return 1 + this.M;
    }
  }, {
    key: "_constructExponentBits",
    value: function _constructExponentBits() {
      var result = _toConsumableArray(this.arr);

      result.splice(0, 1);
      result.splice(1 + this.expBitNum, this.manBitNum);
      return result;
    }
  }, {
    key: "_constructMantissaBits",
    value: function _constructMantissaBits() {
      var firstBit = this.isSmall || this.isZero ? 0 : 1;

      var result = _toConsumableArray(this.arr);

      result.splice(0, 1 + this.expBitNum);
      result.unshift(firstBit);
      return result;
    }
  }]);

  return NumberIEEE;
}();

export var AdditionIEEE =
/*#__PURE__*/
function () {
  function AdditionIEEE(n1, n2) {
    _classCallCheck(this, AdditionIEEE);

    if (n1.expBitNum != n2.expBitNum) {
      console.log("AdditionIEEE(Number, Number): expBitNum of n1(".concat(n1.expBitNum, ") and expBitNum of n2(").concat(n2.expBitNum, ") not compatible."));
    }

    if (n1.manBitNum != n2.manBitNum) {
      console.log("AdditionIEEE(Number, Number): manBitNum of n1(".concat(n1.manBitNum, ") and manBitNum of n2(").concat(n2.manBitNum, ") not compatible."));
    }

    this.producedOverflow = false;
    this.result = this._add(n1, n2);
  }

  _createClass(AdditionIEEE, [{
    key: "_add",
    value: function _add(n1, n2) {
      var expBitNum = n1.expBitNum;
      var manBitNum = n1.manBitNum;
      var bitNum = n1.bitNum; // Edgecases:

      if (n1.isNaN || n2.isNaN || n1.isInfinity && n2.isInfinity && n1.sign != n2.sign) {
        // Return NaN
        return new NumberIEEE(expBitNum, manBitNum, Array(bitNum).fill(1));
      }

      if (n1.isInfinity || n2.isInfinity) {
        // Return Infinty
        var _sign = n1.isInfinity ? n1.sign : n2.sign;

        var infArray = [_sign];
        infArray.push.apply(infArray, _toConsumableArray(Array(expBitNum).fill(1)));
        infArray.push.apply(infArray, _toConsumableArray(Array(manBitNum).fill(0)));
        return new NumberIEEE(expBitNum, manBitNum, infArray);
      } // Get unnormalized  exponent


      var anchorExp = n1.exponent;
      var difference = n2.exponent - n1.exponent;
      var digitNum = 3 + Math.max(difference, 0);
      var op1 = new NumberBaseNComplement(2, digitNum, n1.mantissaBits, n1.manBitNum, n1.sign == 1);
      var op2 = new NumberBaseNComplement(2, digitNum, n2.mantissaBits, n2.manBitNum - difference, n2.sign == 1);
      var additionResult = new AdditionBaseNComplement(op1, op2).getResult();
      var sign = null;
      var unnormalizedMantissa = null;

      if (additionResult.isNegative()) {
        sign = 1;
        unnormalizedMantissa = additionResult.getFlipedArray();
      } else {
        sign = 0;
        unnormalizedMantissa = _toConsumableArray(additionResult.arr);
      }

      var cDigits = digitNum;

      while (cDigits > 1 && unnormalizedMantissa[0] == 0) {
        unnormalizedMantissa.splice(0, 1);
        cDigits--;
      } // Calculate shift
      // Positive: Rightshift | Negative: Leftshift


      var shift = null;

      if (cDigits > 1) {
        shift = cDigits - 1;
      } else {
        shift = 0;

        for (var i = 1; i < unnormalizedMantissa.length; i++) {
          shift--;

          if (unnormalizedMantissa[i] == 1) {
            break;
          }
        }
      }

      if (shift == unnormalizedMantissa.length - 1 && unnormalizedMantissa[unnormalizedMantissa.length - 1] == 0) {
        // Return zero
        return new NumberIEEE(expBitNum, manBitNum, Array(bitNum).fill(0));
      }

      var normalizedMatissa = [];

      for (var _i = 0; _i < manBitNum; _i++) {
        var access = _i + Math.max(-shift, 0) + 1;
        var num = access < unnormalizedMantissa.length ? unnormalizedMantissa[access] : 0;
        normalizedMatissa.push(num);
      } // Calculate exponent


      var finalE = anchorExp + shift + n1.bias;
      var curE = finalE;
      var exponentBits = [];

      for (var _i2 = 0; _i2 < expBitNum; _i2++) {
        exponentBits.unshift(curE % 2);
        curE = Math.floor(curE / 2);
      }

      var result = [sign];
      result.push.apply(result, exponentBits);
      result.push.apply(result, normalizedMatissa);
      return new NumberIEEE(expBitNum, manBitNum, result);
    }
  }, {
    key: "getResult",
    value: function getResult() {
      return this.result;
    }
  }]);

  return AdditionIEEE;
}();

export var SubtractionIEEE =
/*#__PURE__*/
function () {
  function SubtractionIEEE(n1, n2) {
    _classCallCheck(this, SubtractionIEEE);

    if (n1.expBitNum != n2.expBitNum) {
      console.log("SubtractionIEEE(Number, Number): expBitNum of n1(".concat(n1.expBitNum, ") and expBitNum of n2(").concat(n2.expBitNum, ") not compatible."));
    }

    if (n1.manBitNum != n2.manBitNum) {
      console.log("SubtractionIEEE(Number, Number): manBitNum of n1(".concat(n1.manBitNum, ") and manBitNum of n2(").concat(n2.manBitNum, ") not compatible."));
    }

    this.producedOverflow = false;
    this.result = this._subtract(n1, n2);
  }

  _createClass(SubtractionIEEE, [{
    key: "_subtract",
    value: function _subtract(n1, n2) {
      var flipedArr2 = _toConsumableArray(n2.arr);

      flipedArr2[0] = flipedArr2[0] == 0 ? 1 : 0;
      var op1 = new NumberIEEE(n1.expBitNum, n1.manBitNum, n1.arr);
      var op2 = new NumberIEEE(n2.expBitNum, n2.manBitNum, flipedArr2);
      return new AdditionIEEE(op1, op2).getResult();
    }
  }, {
    key: "getResult",
    value: function getResult() {
      return this.result;
    }
  }]);

  return SubtractionIEEE;
}();

export var MultiplicationIEEE =
/*#__PURE__*/
function () {
  function MultiplicationIEEE(n1, n2) {
    _classCallCheck(this, MultiplicationIEEE);

    if (n1.expBitNum != n2.expBitNum) {
      console.log("MultiplicationIEEE(Number, Number): expBitNum of n1(".concat(n1.expBitNum, ") and expBitNum of n2(").concat(n2.expBitNum, ") not compatible."));
    }

    if (n1.manBitNum != n2.manBitNum) {
      console.log("MultiplicationIEEE(Number, Number): manBitNum of n1(".concat(n1.manBitNum, ") and manBitNum of n2(").concat(n2.manBitNum, ") not compatible."));
    }

    this.producedOverflow = false;
    this.result = this._multiply(n1, n2);
  }

  _createClass(MultiplicationIEEE, [{
    key: "_multiply",
    value: function _multiply(n1, n2) {
      var expBitNum = n1.expBitNum;
      var manBitNum = n1.manBitNum;
      var bitNum = n1.bitNum;
      var sign = (n1.sign && !n2.sign || !n1.sign && n2.sign) + 0; // Edgecases:

      if (n1.isNaN || n2.isNaN || n1.isInfinity && n2.isZero || n1.isZero && n2.isInfinity) {
        // Return NaN
        return new NumberIEEE(expBitNum, manBitNum, Array(bitNum).fill(1));
      }

      if (n1.isInfinity || n2.isInfinity) {
        // Return Infinty
        var infArray = [sign];
        infArray.push.apply(infArray, _toConsumableArray(Array(expBitNum).fill(1)));
        infArray.push.apply(infArray, _toConsumableArray(Array(manBitNum).fill(0)));
        return new NumberIEEE(expBitNum, manBitNum, infArray);
      }

      var op1 = new NumberBaseNComplement(2, 3, n1.mantissaBits, n1.manBitNum, false);
      var op2 = new NumberBaseNComplement(2, 3, n2.mantissaBits, n2.manBitNum, false);
      var multiplicationResult = new MultiplicationBaseNComplement(op1, op2).getResult();
      var digitNum = multiplicationResult.digitNum;

      var unnormalizedMantissa = _toConsumableArray(multiplicationResult.arr);

      var cDigits = digitNum;

      while (cDigits > 1 && unnormalizedMantissa[0] == 0) {
        unnormalizedMantissa.splice(0, 1);
        cDigits--;
      } // Calculate shift
      // Positive: Rightshift | Negative: Leftshift


      var shift = null;

      if (cDigits > 1) {
        shift = cDigits - 1;
      } else {
        shift = 0;

        for (var i = 1; i < unnormalizedMantissa.length; i++) {
          shift--;

          if (unnormalizedMantissa[i] == 1) {
            break;
          }
        }
      }

      if (shift == unnormalizedMantissa.length - 1 && unnormalizedMantissa[unnormalizedMantissa.length - 1] == 0) {
        // Return zero
        return new NumberIEEE(expBitNum, manBitNum, Array(bitNum).fill(0));
      }

      var normalizedMatissa = [];

      for (var _i = 0; _i < manBitNum; _i++) {
        var access = _i + Math.max(-shift, 0) + 1;
        var num = access < unnormalizedMantissa.length ? unnormalizedMantissa[access] : 0;
        normalizedMatissa.push(num);
      }

      var finalE = n1.E + n2.E - n1.bias + shift;
      var curE = finalE;
      var exponentBits = [];

      for (var _i2 = 0; _i2 < expBitNum; _i2++) {
        exponentBits.unshift(curE % 2);
        curE = Math.floor(curE / 2);
      }

      var result = [sign];
      result.push.apply(result, exponentBits);
      result.push.apply(result, normalizedMatissa);
      return new NumberIEEE(expBitNum, manBitNum, result);
    }
  }, {
    key: "getResult",
    value: function getResult() {
      return this.result;
    }
  }]);

  return MultiplicationIEEE;
}();

var MultiplicationBaseNSignedToLatex =
/*#__PURE__*/
function () {
  function MultiplicationBaseNSignedToLatex(watcher) {
    var multiplicationOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    _classCallCheck(this, MultiplicationBaseNSignedToLatex);

    this.algorithm = watcher;
    this.result = this._generateLatex(multiplicationOnly);
  }

  _createClass(MultiplicationBaseNSignedToLatex, [{
    key: "_generateLatex",
    value: function _generateLatex() {
      var multiplicationOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var latexSign, latexMultiplication;
      this.algorithm = this.algorithm.start;

      while (this.algorithm.name != "Result") {
        if (this.algorithm.name == "GetSign") {
          latexSign = this._computeGetSign();
        } else if (this.algorithm.name == "MultInital") {
          latexMultiplication = this._computeMultiplication();
        } else {
          console.log("MultiplicationBaseNSignedToLatex._generateLatex(): Unknown step.");
          process.exit(0);
        }

        this.algorithm = this.algorithm.next;
      }

      if (multiplicationOnly) {
        return latexMultiplication;
      }

      var latex = ["\\begin{enumerate}", "\\item Get Final Sign: \\ ".concat(latexSign, " "), "\\item Multiply absolute values: \\\\", "".concat(latexMultiplication), "\\item[] Final Result: \\ $".concat(this.algorithm.data.result.stringRepresentation, "$"), "\\end{enumerate}"].join('\n');
      return latex;
    }
  }, {
    key: "_computeGetSign",
    value: function _computeGetSign() {
      var data = this.algorithm.data;
      var latex = "$".concat(data.signN1 ? 1 : 0, " \\oplus ").concat(data.signN2 ? 1 : 0, " = ").concat(data.isNegative ? 1 : 0, "$");
      return latex;
    }
  }, {
    key: "_computeMultiplication",
    value: function _computeMultiplication() {
      var _firstline, _secondline, _firstline3;

      var data = this.algorithm.data;
      var widthNeeded = 0;
      var step = this.algorithm;

      while (step.name != 'Result') {
        if (step.name == 'MultInital') {
          widthNeeded = Math.max(step.data.num1.arr.length, step.data.num2.arr.length + 1);
        } else if (step.name == 'MultFinal') {
          widthNeeded = Math.max(widthNeeded, step.data.cur.arr.length + 1);
        } else {
          widthNeeded = Math.max(widthNeeded, step.data.cur.arr.length + 1);
          widthNeeded = Math.max(widthNeeded, step.data.toAdd.arr.length + 1);
        }

        step = step.next;
      }

      var firstline, secondline;
      firstline = _toConsumableArray(this.algorithm.data.num1.arr);

      (_firstline = firstline).unshift.apply(_firstline, _toConsumableArray(Array(Math.max(0, widthNeeded - firstline.length)).fill('')));

      firstline = firstline.map(function (e) {
        return '' + e;
      }).join(' & ');
      secondline = _toConsumableArray(this.algorithm.data.num2.arr);

      (_secondline = secondline).unshift.apply(_secondline, _toConsumableArray(Array(Math.max(0, widthNeeded - 1 - secondline.length)).fill('')));

      secondline.unshift('\\times');
      secondline = secondline.map(function (e) {
        return '' + e;
      }).join(' & ');
      var latex = ["\\begin{align*}", "\t\\begin{array}{".concat(Array(widthNeeded).fill('c').join(''), "}"), "\t\t ".concat(firstline, " \\\\"), "\t\t ".concat(secondline, " \\\\ \\hline")];
      this.algorithm = this.algorithm.next;

      while (this.algorithm.name != 'MultFinal') {
        var _firstline2, _secondline2;

        firstline = _toConsumableArray(this.algorithm.data.cur.arr);

        (_firstline2 = firstline).unshift.apply(_firstline2, _toConsumableArray(Array(Math.max(0, widthNeeded - 1 - firstline.length)).fill('0')));

        firstline.unshift('');
        firstline = firstline.map(function (e) {
          return '' + e;
        }).join(' & ');
        secondline = _toConsumableArray(this.algorithm.data.toAdd.arr);

        (_secondline2 = secondline).unshift.apply(_secondline2, _toConsumableArray(Array(Math.max(0, widthNeeded - 1 - secondline.length)).fill('0')));

        secondline.unshift('+');
        secondline = secondline.map(function (e) {
          return '' + e;
        }).join(' & ');
        latex.push("\t\t ".concat(firstline, " \\\\"));
        latex.push("\t\t ".concat(secondline, " \\\\ \\hline"));
        this.algorithm = this.algorithm.next;
      }

      firstline = _toConsumableArray(this.algorithm.data.cur.arr);

      (_firstline3 = firstline).unshift.apply(_firstline3, _toConsumableArray(Array(Math.max(0, widthNeeded - 1 - firstline.length)).fill('0')));

      firstline.unshift('');
      firstline = firstline.map(function (e) {
        return '' + e;
      }).join(' & ');
      latex.push("\t\t ".concat(firstline, " \\\\"));
      latex.push("\t\\end{array}\\\\");
      latex.push("\\end{align*}");
      return latex.join('\n');
    }
  }, {
    key: "getResult",
    value: function getResult() {
      return this.result;
    }
  }]);

  return MultiplicationBaseNSignedToLatex;
}();

var MultiplicationBaseNComplementToLatex =
/*#__PURE__*/
function () {
  function MultiplicationBaseNComplementToLatex(watcher) {
    _classCallCheck(this, MultiplicationBaseNComplementToLatex);

    this.algorithm = watcher;
    this.result = this._generateLatex();
  }

  _createClass(MultiplicationBaseNComplementToLatex, [{
    key: "_generateLatex",
    value: function _generateLatex() {
      var latexSize, latexMultiplication;
      this.algorithm = this.algorithm.start;

      while (this.algorithm.name != "Result") {
        if (this.algorithm.name == "DetermineSize") {
          latexSize = this._computeDetermineSize();
        } else if (this.algorithm.name == "Multiply") {
          latexMultiplication = this._computeMultiplication();
        } else {
          console.log("MultiplicationBaseNComplementToLatex._generateLatex(): Unknown step.");
          process.exit(0);
        }

        this.algorithm = this.algorithm.next;
      }

      var latex = ["\\begin{enumerate}", "\\item Get needed size: \\ ".concat(latexSize, " "), "\\item Sign extend operands to $S$ and multiply as positive numbers: \\\\", "".concat(latexMultiplication), "\\item[] Take the $S$ last digits.\\\\", "Final Result: \\ $".concat(this.algorithm.data.result.stringRepresentation, "$"), "\\end{enumerate}"].join('\n');
      return latex;
    }
  }, {
    key: "_computeDetermineSize",
    value: function _computeDetermineSize() {
      var data = this.algorithm.data;
      var latex = "$S = 2 \\cdot \\max(\\text{length}(n1), \\text{length}(n2)) = 2 \\cdot \\max(".concat(data.n1Offset + data.digitNum, ", ").concat(data.n2Offset + data.digitNum, ")$ = ").concat(data.digitsToTake);
      return latex;
    }
  }, {
    key: "_computeMultiplication",
    value: function _computeMultiplication() {
      var data = this.algorithm.data;
      var latex = new MultiplicationBaseNSignedToLatex(data.multiplication, true).getResult();
      return latex;
    }
  }, {
    key: "getResult",
    value: function getResult() {
      return this.result;
    }
  }]);

  return MultiplicationBaseNComplementToLatex;
}();

//export * from './boolean/index.js';
var num1 = getBaseNComplementFromString(10, 3, "185");
var num2 = getBaseNComplementFromString(10, 3, "671");
var op = new MultiplicationBaseNComplement(num1, num2);
console.log(new MultiplicationBaseNComplementToLatex(op.watcher).getResult());
/*
let num1 = getNumFromString(2, "1110100");
let num2 = getNumFromString(2, "11100010");

let op = new SubtractionBaseN(num1, num2);
//console.log(op);
console.log((new SubtractionBaseNSignedToLatex(op.watcher)).getResult());
*/

/*
let op = new MultiplicationBaseNComplement(num1, num2);

 num = op.getResult();
console.log(num);

console.log();


*/

var x1 = getIEEEFromString(8, "0 10011001 0000 1001 1001 0000 0000 0000");
var x2 = getIEEEFromString(8, "0 10011001 1111 1111 0000 0000 0000 0000");
var x3 = getIEEEFromString(8, "1 10010100 0011 0110 0000 0000 0000 0000");
var y1 = getIEEEFromString(7, "0 1001000 1001 1011");
var y2 = getIEEEFromString(7, "1 1001010 1110 1000");
op = new MultiplicationIEEE(y1, y2);
var op2 = new AdditionIEEE(y1, y2);
var op3 = new SubtractionIEEE(y1, y2);
console.log(op.getResult());
console.log(op2.getResult());
console.log(op3.getResult());
