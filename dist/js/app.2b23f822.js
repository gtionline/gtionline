(function(){"use strict";var e={9275:function(e,t,i){var n=i(3751),s=i(5220),a=i(3165),o=i.n(a),r=i(1273),l=i(7107),c=i(6188),u=i(11),h=i(4598),d=i(3132),m=i(641),p=i(33),f=i.p+"img/codesign_white.d2bfe512.png",g=i.p+"img/FAU_logo_white.0a4def77.png";const b={id:"websiteContainer"},v={id:"content"},w={id:"footer"},x={href:"https://www.studon.fau.de/studon/ilias.php?ref_id=4386562&cmd=view&cmdClass=ilobjcontentpagegui&cmdNode=12b:q0&baseClass=ilrepositorygui"};function _(e,t,i,n,s,a){const o=(0,m.g2)("TheNavigationBar"),r=(0,m.g2)("router-view");return(0,m.uX)(),(0,m.CE)("div",b,[(0,m.bF)(o),(0,m.Lk)("div",v,[(0,m.bF)(r)]),(0,m.Lk)("footer",w,[(0,m.Lk)("span",null,(0,p.v_)(e.$t("disclaimerFooter")),1),(0,m.Lk)("span",null,[(0,m.eW)(" © "+(0,p.v_)(e.$t("copyright"))+" ",1),(0,m.Lk)("a",x,(0,p.v_)(e.$t("impressum")),1),(0,m.eW)(". "+(0,p.v_)(e.$t("contact"))+": ",1),t[0]||(t[0]=(0,m.Lk)("a",{href:"mailto:cs12-gti@fau.de?subject=GTI-Online Feedback&body=Nachricht"},"cs12-gti@fau.de",-1))]),t[1]||(t[1]=(0,m.Fv)('<div id="logoContainerFooter"><a href="https://www.cs12.tf.fau.de"><img id="codesignLogo" alt="white codesign logo" src="'+f+'"></a><a href="https://www.fau.de/"><img id="fauLogo" alt="white FAU logo" src="'+g+'"></a></div>',1))])])}var $="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAANQAAAAnCAYAAAB32GavAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAPYQAAD2EBqD+naQAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAABBwSURBVHic7Z15lFT1lcc/91U13Y0iMuMWxSWJGtSJY6JmJDja2tUNiGgm2jjQxeJGQMExLicaNINmUZPZFAPjLnQ3oqgHgkvoBToRBo+jE7eYGI0mCqKiNi7NVtXvO39UNV316lXXq+puuhr9nFPn1Pst993qfr/3fr/7u/c+IwuqmHYAoY5xmCqBg4F9gQ+AvwAtlJQ8Zk/etylbfwBV1k7FGN5dG/+OoRXWsujFtKJI7TVAqKtkx+3WvPTjvGUDqqodhZyxhfTNxH3Dmhvu7R1Z6ShSMxSn5PDcKoRdXN7n47L37bk7Yz0655hphxGPHdATGRnES/5irfe/C6CKaWWEY8f1qnwvoR1/spVLP8qni0ZHD8flGmuqv6gnpw5nCK765wNR6HqIXwAM8lR/DRgF1BKL7VAkeg9x/cxaG9b7Sje+BzYyb60cbQBeTC+0G4GSLs33aAAKGlDIRoLmFNQ3A2sF+mRAQenJuDyWu50LDjBsyzZFoquAB4mvX2ytrfG8TxmPXwk2K+9+3RHuuAL4TwBKdhyMnHW9Kt+LWzYBWJpXnzizMKKqnvxDa6x7v9BTO6kHikQrUPj/wGaQOZi8DAJmErbfq7L2vEIV6AtUPXkPVUzr3bvswKAMOANYSPjgl1Q1+dT+VmggoIqaPTGmAaW47gU9kbVzQCky6WygGdg/Txl7YTZTYD1RpLfQ6bVjcfUu4fhGRaIL+1uf/kMjkJpUFe3RFOZzQWjQFGBo4sBmqqIiY+YWlDCAqiYdh5wHSFujAGgdZvNwaGXk4e+x7vX9ce1kpIuA6mSjNpz4ZANlSHftKkx/k1ZmdhPwd13H/AeuVqe1iev5Qn8Qjt0I7Jk8mqJI9LtAh6fVH7uVMaiEjjGnwNC9cBqfwt77oGB1+pkSxJ2qrN1sLQ0P97cyRYvZzJSjQwgPPxt4pBBRYYEh53agPKXcxbiCpobbdg6UlQBsJDE3XaqqyWcgLUSaaY1L3vbVc1X9/3jLFIle5Wn1vLXUB1gnBER8kvasNF5GttXTaHvW/mbEb7gc99gRAHScUUHJ7LnYB229puIuxjC7R5UTn7KWB97rb2WKDVVGq0i9wSeYTaEDisiUSnBHpZ/Fvm/Ndbd119Ga6p7QuElH2uOLi+tKM10OtggYjulma2r4d2+T5KAe49ddhw3HPXYEztrnsBf+gP7hODhgPyiqAaXlYN7BcRBwCjDEp8NeWOg6EhdKIbigZQX2Bem1FFHt4DQG6HUcsJ+nbBvw25w9Xb2bh3Z+f5NTVTnlWK+lOQhh0IS0ErNnaK6bF6Rz0Q0mwJobXgK+UbCAWNLq3PYxocdXw+Oru2/fHyh0i7UsyrCUKVIzFMp+AbrYp9dUjZ19lT05L/vTOTs7rLnhnAL6ZWBNS94BRudqp0jtMrCzPcXvWXN9zr5B0emTDsU4w7fSNAuYnq/MMMjzdNL9fushjZ1dSuzDg3JK3Fq2ydbe+2m+ihQLtv5d7N1NuJXfRg89jn24uSA5qqkJ0VZ6FzAB8Rwd4fM692L6iuS+3HRFomHgfE/1EGKbK+icvH8BWGg2KORfqagqp1xrLYs+zEdkmMSmbcpJ5P+Yi330DQiwfzA4Ngv4ZT5KFBMdZ1WiA/YFID7nUsI33EbHJVGcZ17AaclYEgIcqkj01YzSNg0BvgSAcQrhjh8Cl/WZ4qnIuRpzJwGl6RXukXwxoADQ+OmD2brVe9NJpRxzzwf+LR+5TkZJh2Va6/JBKs/dqHhxJ4zD3nyb0MJH0de+QvzGy3FPPgEN9VuaACBMsYwP5qa1Mg3uc+U7T5W4q/rd/Lxrks8vW7dGwWOBzmSWamqyPMH8CYNtAI3YWeLoGMD3VhwIqVt3pKImHEZDh+C89Cqhhx6HYXvRcVYEAHvjrWy93rKmhtO8hRpZU87g0l9jnAK8hev8vO8U9yVzqiJnwE7Fex9dGqDRoWwuHQf8KqjUMGgd0DWgsKnAXZnnD72G4zFguK6DWQNp+1fKeuXtCjSyppw9Bl2EnD0ZFL47l79hGvE4zu9fwz35BOKDy9GwoV1Vcy4lPL8eZ/XTgUTZuqVbgVNVMe0A9m3fZEuXevfC+povZyrVkTk1/RyiykmnAccGa6zZ5DWgxENY2gJ2lCK1F1tzQ9qgSk4j0vyjFJlyMripj8TPGPS3hT/deoM9SxchzsUEsdilikSvQPJMv/iSzzY0AKFb70NzZuGe8HUAnGdfwmlaQ8c5Y3aurfKhrw0Rfigy+SiQ1wF1O6HYU7tal6LEHL+nUwxjOeJcT+NKVdYebS0NrwQRHaalfiWR2nXpTqw2X5Fo2JrrF2TrqIqJ+4A7P/3cPFKgWbb3EJGUo4OABzHztmnN1t02bqJk9lx04H7YJ+3w6WcAOGueBSdzyVlsaGRNOaa7kWd9bCzJ1wN7d0SRKYeA6zXHA/Yo4gbQOeBxDTCbBVwSRH7YQCJ0Kbhr6fKWCAPzVTV5GrAA2SrayjZSFi+jfPth4ERAVwEHpsjaRof7r3n/wt5GrMb4JwCMjRhXI1xPmxOBiuwyhG3wcSpw3cyyIkE1NYPYXBZBugllTGc2Y/Hr+0WxosO9BJ8oC5yO+da4+A+qjK7GON1TO1XjJs0Jsu8aBrDmRb9TZNJEcB4hdT0kfQv4FgiGbUkWGn7bVJjNtFWL/xr0Z/UZIZuMq5kYe+GwwFbWb/Q2USSaez+tmDH3YUWi25JHg4FS2hgC8nPqbMd0bjb3sICEVRXN8DjJrafdZ411L/fgvL1KYi+1zc9U/gqNi5PTYS0A8w6owWy3qcB/5TrHzn+ANS9erqra0cgWk595dQdmV1hT3f159OkzrLGunTz3DgYgB+ZuAsA2sHtB2wTm68AcjDDiivy7uWuAohlQxD6qBcu8ts3m7fzbdGxYRsnw9cgbGGuzNHfubTZ3brfTlLR5tjU1tKCOYxG3Aluz9EmlFbNR1lQ3YDdyd3PKQLORrSES/aMqa8/sb4X6F8dvHfQpYXdx54G1tsYRd/u0+ypr/+zr/5lKxhQh6ZF8uSqn/BjrGA0WIWGC3Q9oTzhluk9D6AlrXvS74D+m8wS6G9HUdWwBZehHpE5H4+2F+xE69iqu8ovozIapeO7A3XMkZitUVXsbo474fq477e5G0iJ9vE/VQnuy4ZO0khB30sEcUiPEodOE/kR358kaSJU0ky9OfnoNa2qoL6hfc8PNvaZDY90KYEVvyRtQyC5jzes7gKv7W5Vdi+vvae/YHd4iW1m/UZHoMqDGUzVa1RNHWOMDWePpCo5M/IJ+5RawN7LWmvbB5SSMajL8+QC4UpW1v7GWht6LQytiEnlSkpbftApWdWM0mU/mgDLc8CV045P5xYAaiMhZ7he+kdGsonY4YfslcJanyjD7uWpqngzowRED/iVvPc0pPPK6N1HJJaCSjHKzrGt/a65vVST6EvB1j7BpGlt7XcY0MYnvgJI0BJgKnAkcBrjAG8ByoN7MGwGb1vdKYIGZbclSXwLcnjz8wMzmeOovAjrnur8w6+ZOnGg/EpiSPHzCzFak1JUAV5pZ1umipBOBzrwLzWa21FN/OxmpAdJ40cyyboD3J9basF7wHSLRJcAET/VRefipdXS3yV/MJE3lfnk13qGtvPtpv9kdJP7/qQwhZlPouobTyEwjJp0J3Eln6EEXRwHjgDmSpplZaxY1TgPGSBpvZtt86sN0BW69CXjTeY2Gne4fdSQGcneMAGYkv39I+trIgJskycxuydL/8BR9PiMz/dQMuh9QjwFFe7EZSKXuDLY71cDeaZWyM8nDT21AEms7D7/EQ+K/c+Yw3FKyiPIdPwP28tRcprlz5/sZdtLTiEkTgWVkDqZUDgVWJgdeNiLAckl+8/f+4CYpkHfxbklih98ezaxR/jkTBx5+OQZjOPF7cnVMBso2+FQdwdrXIj7lXU8oSccA99B1N34fuBVYkyw7jUT8/d4kcvLVS/p7M8vmHVENLJE0wcx6lM20FzBgnqS4WaZVJyCfAX7uO7meoMWC3+K7uxvngEeR2pOAEzMqjEeSofgBhOh2zGbgTZMnZzaQkRsjdcr3U7p8+V4Aqs0sNYPmakl3k8jddwSJPGZzyQy1TuU7wGJJE80s/yymvYsB8yW1m1khpvstZpbT9aRoMQ3y8ZPIGjW5e+DM9nUOcZmfWeiPtTS8osroU8m4thQ0TpVTjrSWRX9KLU3k5ZP2B8Yny3YA53gGU0K42VuSzgOeJTFdnCjpMjPrLnDtXGCLpPPNrL83Ex3gfkkdZvZAP+uya5GO8clFOmATDuYikTk4fq5vpfFbRaI9PYXhuN8Drkwt7FxDnZ7yfZmZ/TmrlIRnw6rkYSnwjwFOPgW4S1IxZJcNAQsleU3JuRgiaZ7nc0NfKNjbJLIh2Xifqp44zBY34XiQdOI9Q1ygipo9U4s6B1Fqopb/DSDqmZTvh3TTbknK9wsI4K3bh7xDV063EuAhSTl9s1IoJ7HATf1M600F+47Sm/Ba+ABMv9n1uvQ9On56CV1bIX3J3pSUpT3qOgdUqlk4yEZfapvuNodvAX6ScnxZsqw/2E5iX61zQ7QUeBQyYl92GwSmqtofATN9G5ize2ZAGtZeQyK4tO+RZqfm9e8cDKkWjyDv7klNJOn/KpskZna9pDBwTbKo0OylPcbMPpU0FmgiYf0pJ/idrB3wJlopLGlfH6Px0wezZUs1Dlcjvp2l2Ys01gXO4qmKaWUFK7Rve2zX5tSwXXmNHU315NNorFsFXQOqNaXBOZKuMbOMwDwASUfSlfmzA8iZp8DMru30WihY7V7CzD6WVA20AN/Mo2u7md3YR2rlh7krFYlms5oaW7fs7R8HmoL04zzio8oIx4OE8/jTVtb1fqg+RtWTjsflJJ+qVnAv7Jlw+yYeTxoAXM0maVdIROya/VVSK4mw8D2AByWN81rvJO1DYl3U6Rf1KzMLmlnz6qTsGbka9jVmtjm5fmoFju5ndQqhZ+Zu42Fr3k3fxuE6WRxXbZ41L+7pnuEbikRfJvPlAuNVPfnL1lj3Zur651oST5swCcvd85JuBtaSWGNVAD+ga266DbguqCZmJkmd8fxBp1kRSYf6lC8x61lCTjPbJOl0EoNqRI7mAKVJTxIvG8wsdwL74uFZYmG/3OcDHo09f19iMa/PIgTx2wvOHYA3938IuTOAH3SFwJs9LekquixxXyHh0+eHC8wws0CplVLOIUkzSDyp/C5OL9nM0kuBHm8Um9l7kqpIWP8y89ilMxT/2LDHCPJGiKJAzWwt/e5Azj3fLbEd08Ey13pB/PaCsnXQQsp3/BSvf5/sYo2ffkN6CLzZrcCFJNxsstEGnGdmBb0d0Mw6gMnk+w7UPsLM1pN4+vZ/gpm+YxPoQpobqnfXwaSKinDSRchLIL+9oCT+fvK7sQ5j25ZJmSHwZvdK+jWJPGRnAl8lYXx4nUT4xvwc66bn6Qpq8/3nmVmHpMn4L1SfI5HJpztSPS7episs2ZsZ1SXhKgWQNeFk0gOkGvDJ18YTdO9tHmTfrjBMMWSFhPq3ARsQr2IsY9j2Jlu6dEfAvu3J/r2I/KIOcnSxTzGPHurGqho6aAxiDzJ1XxHYby+wbqEFmJv5XmlR+//pHt16DBgd/wAAAABJRU5ErkJggg==";const y={class:"navbar"},E={id:"languageDropdown"};function C(e,t,i,n,s,a){const o=(0,m.g2)("router-link"),r=(0,m.g2)("LSelect");return(0,m.uX)(),(0,m.CE)("div",y,[t[1]||(t[1]=(0,m.Lk)("input",{class:"menu-btn",type:"checkbox",id:"menu-btn"},null,-1)),t[2]||(t[2]=(0,m.Lk)("label",{id:"checkBoxLabel",class:"menu-icon",for:"menu-btn"},[(0,m.Lk)("span",{class:"navicon"})],-1)),(0,m.bF)(o,{class:"logoContainer",to:"/"},{default:(0,m.k6)((()=>t[0]||(t[0]=[(0,m.Lk)("img",{id:"logo",alt:"logo",src:$},null,-1)]))),_:1}),(0,m.Lk)("div",{class:(0,p.C4)(["menu",s.responsive?"responsive":""])},[((0,m.uX)(!0),(0,m.CE)(m.FK,null,(0,m.pI)(a.menu,(e=>((0,m.uX)(),(0,m.Wv)(o,{onClick:a.checkMenuClose,class:"routerLink",key:e.id,"active-class":"selectedNav",to:`${e.link}`},{default:(0,m.k6)((()=>[(0,m.Lk)("span",null,(0,p.v_)(e.label),1)])),_:2},1032,["onClick","to"])))),128))],2),(0,m.Lk)("div",E,[(0,m.bF)(r,{onInput:a.chooseLang},null,8,["onInput"])])])}const M=["tabindex"],k=["src"],T={class:"longLanguageName"},S=["onClick"],N=["src"],B={class:"longLanguageName"};function F(e,t,i,n,s,a){const o=(0,m.g2)("font-awesome-icon");return(0,m.uX)(),(0,m.CE)("div",{class:"langSelect",tabindex:i.tabindex,onBlur:t[1]||(t[1]=e=>s.open=!1)},[(0,m.Lk)("div",{class:(0,p.C4)(["selected",{open:s.open}]),onClick:t[0]||(t[0]=e=>s.open=!s.open)},[(0,m.Lk)("img",{class:"langImg",alt:"language flag",src:s.selected.img},null,8,k),(0,m.Lk)("span",T,(0,p.v_)(s.selected.nameLong),1),(0,m.bF)(o,{class:"angleDown",icon:"angle-down"})],2),(0,m.Lk)("div",{class:(0,p.C4)(["items",{selectHide:!s.open}])},[((0,m.uX)(!0),(0,m.CE)(m.FK,null,(0,m.pI)(s.languages,(e=>((0,m.uX)(),(0,m.CE)("div",{class:"item",key:e.name,onClick:t=>a.optionSelect(e)},[(0,m.Lk)("img",{class:"langImg",alt:"language flag",src:e.img},null,8,N),(0,m.Lk)("span",B,(0,p.v_)(e.nameLong),1)],8,S)))),128))],2)],40,M)}var L=i.p+"img/americanFlag.ecf901d6.png",A=i.p+"img/frenchFlag.5645e99b.png",V=i.p+"img/spanishFlag.d5d97c30.png",I=i.p+"img/chineseFlag.8d40b343.png",D=i.p+"img/japaneseFlag.59ecf4ca.png",P=i.p+"img/ukraineFlag.c295e427.png",O=i.p+"img/portugueseFlag.ba27116f.png";const j=i(4792);var R={name:"LanguageSelect",props:["sel","tabindex"],created(){this.selected=this.languages[0]},data(){return{languages:[{name:"de",nameLong:"Deutsch",img:j},{name:"en",nameLong:"English",img:L},{name:"fr",nameLong:"Français",img:A},{name:"es",nameLong:"Español",img:V},{name:"pt",nameLong:"Português",img:O},{name:"uk",nameLong:"Українська",img:P},{name:"ja",nameLong:"日本語",img:D},{name:"ch",nameLong:"中国",img:I}],selected:null,open:!1}},mounted(){this.$emit("input",this.selected)},methods:{optionSelect(e){this.selected=e,this.open=!1,this.$emit("input",e),this.$nextTick((()=>{window.MathJax&&window.MathJax.typeset()}))}}},z=i(6262);const W=(0,z.A)(R,[["render",F],["__scopeId","data-v-330b7316"]]);var q=W,H={name:"TheNavigationBar",components:{LSelect:q},data(){return{responsive:!1}},computed:{menu(){return[{id:1,label:this.$t("floatingPoint"),link:"fparithmetic"},{id:2,label:this.$t("functionMin"),link:"bfminimizer"},{id:3,label:"CMOS",link:"cmos"}]}},methods:{checkMenuClose(){const e=document.getElementById("menu-btn");e.checked=!1},chooseLang(e){this.$i18n.locale=e.name}}};const U=(0,z.A)(H,[["render",C],["__scopeId","data-v-1f7d4850"]]);var K=U,G={name:"app",components:{TheNavigationBar:K}};const X=(0,z.A)(G,[["render",_]]);var Z=X;const J={class:"floatingPoint"};function Y(e,t,i,n,s,a){const o=(0,m.g2)("tab"),r=(0,m.g2)("tabs"),l=(0,m.g2)("fpc"),c=(0,m.g2)("tab-panel"),u=(0,m.g2)("fpe"),h=(0,m.g2)("fpa"),d=(0,m.g2)("tab-panels");return(0,m.uX)(),(0,m.CE)("div",J,[(0,m.bF)(r,{modelValue:e.selectedTab,"onUpdate:modelValue":t[0]||(t[0]=t=>e.selectedTab=t)},{default:(0,m.k6)((()=>[((0,m.uX)(!0),(0,m.CE)(m.FK,null,(0,m.pI)(e.tabs,((t,i)=>((0,m.uX)(),(0,m.Wv)(o,{key:`t${i}`,val:t,label:e.$t(t),indicator:!0},null,8,["val","label"])))),128))])),_:1},8,["modelValue"]),(0,m.bF)(d,{modelValue:e.selectedTab,"onUpdate:modelValue":t[1]||(t[1]=t=>e.selectedTab=t),animate:!1,swipeable:!1},{default:(0,m.k6)((()=>[(0,m.bF)(c,{val:"conversion"},{default:(0,m.k6)((()=>[(0,m.bF)(l)])),_:1}),(0,m.bF)(c,{val:"exercises"},{default:(0,m.k6)((()=>[(0,m.bF)(u)])),_:1}),(0,m.bF)(c,{val:"arithmetic"},{default:(0,m.k6)((()=>[(0,m.bF)(h)])),_:1})])),_:1},8,["modelValue"])])}var Q=i(953);const ee={class:"fp-arithmetic pageContainer"},te={class:"title"},ie={class:"bodyContainer"},ne={class:"introduction"},se={class:"introduction"},ae={class:"floatingPointFormatSelection"},oe={class:"fpOperationContainer"},re={id:"fpOperationTable",class:"fpOperationTable"},le={class:"container"},ce={id:"fpfTable1",class:"floatingPointInput"},ue=["placeholder"],he={class:"container"},de={class:"operand"},me={class:"container"},pe={id:"fpfTable2",class:"floatingPointInput"},fe=["placeholder"],ge={class:"solutionArea"},be={class:"solutionInput"},ve={key:0,class:"checkmark"},we={class:"solutionInput"},xe={key:0,class:"checkmark"},_e={class:"solutionInput"},$e={key:0,class:"checkmark"},ye={style:{position:"relative"}},Ee={id:"solution"},Ce=["innerHTML"],Me=["innerHTML"];function ke(e,t,i,s,a,o){const r=(0,m.g2)("FSelect"),l=(0,m.g2)("AttentionBanner"),c=(0,m.g2)("AccordionItem"),u=(0,m.g2)("Accordion");return(0,m.uX)(),(0,m.CE)("div",ee,[(0,m.Lk)("h3",te,(0,p.v_)(`${e.$t("floatingPoint")} ${e.$t("arithmetic")}`),1),(0,m.Lk)("div",ie,[(0,m.Lk)("p",ne,(0,p.v_)(e.$t("fpArithIntro")),1),(0,m.Lk)("h4",null,(0,p.v_)(e.$t("fpformat")),1),(0,m.Lk)("p",se,(0,p.v_)(e.$t("fpFormatSelection")),1),(0,m.Lk)("div",ae,[(0,m.bF)(r,{class:"bits",num:5,sel:a.selectedFormat[5],onInput:o.selectBitRange,options:o.bitrangeOptions},null,8,["sel","onInput","options"]),(0,m.bF)(r,{class:"mobile_bits",num:5,sel:a.selectedFormat[5],onInput:o.selectBitRange,options:o.bitrangeOptions},null,8,["sel","onInput","options"]),(0,m.Lk)("div",{class:"formatContainer",onMousemove:t[3]||(t[3]=(...e)=>o.sliderMouseMove&&o.sliderMouseMove(...e))},[t[19]||(t[19]=(0,m.Lk)("div",{class:"sign"},"VB",-1)),(0,m.Lk)("div",{class:"exponent",style:(0,p.Tr)({width:60+this.exponentBits*(this.containerWidth/(this.numBits-1))+"px"})},[(0,m.Lk)("div",{onClick:t[0]||(t[0]=(...e)=>o.expandFraction&&o.expandFraction(...e)),class:"expandExponent"},t[17]||(t[17]=[(0,m.Lk)("div",{class:"arrowLeft"},[(0,m.Lk)("div",{class:"arrowMask"})],-1)])),(0,m.eW)(" E("+(0,p.v_)(a.exponentBits)+") ",1),(0,m.Lk)("div",{onMousedown:t[1]||(t[1]=(...e)=>o.sliderMouseDown&&o.sliderMouseDown(...e)),class:"slider"},null,32)],4),(0,m.Lk)("div",{class:"fraction",style:(0,p.Tr)({width:60+(this.numBits-this.exponentBits-1)*(this.containerWidth/(this.numBits-1))+"px"})},[(0,m.Lk)("div",{onClick:t[2]||(t[2]=(...e)=>o.expandExponent&&o.expandExponent(...e)),class:"expandFraction"},t[18]||(t[18]=[(0,m.Lk)("div",{class:"arrowRight"},[(0,m.Lk)("div",{class:"arrowMask"})],-1)])),(0,m.eW)(" M("+(0,p.v_)(a.numBits-a.exponentBits-1)+") ",1)],4)],32),(0,m.Lk)("div",{class:"mobile_formatContainer",onMousemove:t[6]||(t[6]=(...e)=>o.sliderMouseMove&&o.sliderMouseMove(...e))},[t[20]||(t[20]=(0,m.Lk)("div",{class:"mobile_sign"},"Sign(1)",-1)),(0,m.Lk)("div",{onClick:t[4]||(t[4]=(...e)=>o.expandExponent&&o.expandExponent(...e)),class:"mobile_exponent"}," Exponent("+(0,p.v_)(a.exponentBits)+") ↑ ",1),(0,m.Lk)("div",{onClick:t[5]||(t[5]=(...e)=>o.expandFraction&&o.expandFraction(...e)),class:"mobile_fraction"}," Mantisse("+(0,p.v_)(a.numBits-a.exponentBits-1)+") ↓ ",1)],32)]),(0,m.Lk)("h4",null,(0,p.v_)(e.$t("operationSelect")),1),(0,m.Lk)("div",oe,[(0,m.Lk)("div",re,[(0,m.Lk)("div",le,[(0,m.Lk)("div",null,(0,p.v_)(e.$t("firstFloatingPoint")),1),(0,m.Lk)("table",ce,[(0,m.Lk)("tbody",null,[(0,m.Lk)("tr",null,[(0,m.Lk)("td",null,[(0,m.bo)((0,m.Lk)("input",{id:"fpfInput0","onUpdate:modelValue":t[7]||(t[7]=e=>a.inputNums[0]=e),placeholder:this.$t("inputNumber"),onInput:t[8]||(t[8]=e=>o.checkAndConvertFormat(0))},null,40,ue),[[n.Jo,a.inputNums[0]]])]),(0,m.Lk)("td",null,[(0,m.bF)(r,{num:0,sel:a.selectedFormat[0],onInput:o.selectVal,options:o.formatOptions},null,8,["sel","onInput","options"])])]),(0,m.Lk)("tr",null,[(0,m.Lk)("td",null,[(0,m.bo)((0,m.Lk)("input",{id:"fpfInput1","onUpdate:modelValue":t[9]||(t[9]=e=>o.numLeft=e),disabled:""},null,512),[[n.Jo,o.numLeft]])]),(0,m.Lk)("td",null,[(0,m.bF)(r,{num:1,sel:a.selectedFormat[1],onInput:o.selectVal,isDisabled:!0,options:o.formatOptions},null,8,["sel","onInput","options"])])])])])]),(0,m.Lk)("div",he,[(0,m.Lk)("div",null,(0,p.v_)(e.$t("operand")),1),(0,m.Lk)("div",de,[(0,m.bF)(r,{num:2,sel:a.selectedFormat[2],onInput:o.selectOp,options:o.operationOptions},null,8,["sel","onInput","options"])])]),(0,m.Lk)("div",me,[(0,m.Lk)("div",null,(0,p.v_)(e.$t("secondFloatingPoint")),1),(0,m.Lk)("table",pe,[(0,m.Lk)("tbody",null,[(0,m.Lk)("tr",null,[(0,m.Lk)("td",null,[(0,m.bo)((0,m.Lk)("input",{id:"fpfInput2","onUpdate:modelValue":t[10]||(t[10]=e=>a.inputNums[1]=e),placeholder:this.$t("inputNumber"),onInput:t[11]||(t[11]=e=>o.checkAndConvertFormat(1))},null,40,fe),[[n.Jo,a.inputNums[1]]])]),(0,m.Lk)("td",null,[(0,m.bF)(r,{num:3,sel:a.selectedFormat[3],onInput:o.selectVal,options:o.formatOptions},null,8,["sel","onInput","options"])])]),(0,m.Lk)("tr",null,[(0,m.Lk)("td",null,[(0,m.bo)((0,m.Lk)("input",{id:"fpfInput3","onUpdate:modelValue":t[12]||(t[12]=e=>o.numRight=e),disabled:""},null,512),[[n.Jo,o.numRight]])]),(0,m.Lk)("td",null,[(0,m.bF)(r,{num:4,sel:a.selectedFormat[4],onInput:o.selectVal,isDisabled:!0,options:o.formatOptions},null,8,["sel","onInput","options"])])])])])])])]),(0,m.Lk)("div",ge,[(0,m.Lk)("div",be,[(0,m.Lk)("p",null,(0,p.v_)(e.$t("signBit")),1),(0,m.bo)((0,m.Lk)("input",{id:"propVB",class:(0,p.C4)(a.backVB),"onUpdate:modelValue":t[13]||(t[13]=e=>a.propVB=e)},null,2),[[n.Jo,a.propVB]]),"correctInput"===a.backVB?((0,m.uX)(),(0,m.CE)("div",ve,t[21]||(t[21]=[(0,m.Lk)("svg",{version:"1",xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 48 48","enable-background":"new 0 0 48 48"},[(0,m.Lk)("polygon",{fill:"#43A047",points:"40.6,12.1 17,35.7 7.4,26.1 4.6,29 17,41.3 43.4,14.9"})],-1)]))):(0,m.Q3)("",!0)]),t[24]||(t[24]=(0,m.Lk)("div",{class:"divMargin"},null,-1)),(0,m.Lk)("div",we,[(0,m.Lk)("p",null,(0,p.v_)(e.$t("exponentBits")),1),(0,m.bo)((0,m.Lk)("input",{id:"propE",class:(0,p.C4)(a.backE),"onUpdate:modelValue":t[14]||(t[14]=e=>a.propE=e)},null,2),[[n.Jo,a.propE]]),"correctInput"===a.backE?((0,m.uX)(),(0,m.CE)("div",xe,t[22]||(t[22]=[(0,m.Lk)("svg",{version:"1",xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 48 48","enable-background":"new 0 0 48 48"},[(0,m.Lk)("polygon",{fill:"#43A047",points:"40.6,12.1 17,35.7 7.4,26.1 4.6,29 17,41.3 43.4,14.9"})],-1)]))):(0,m.Q3)("",!0)]),t[25]||(t[25]=(0,m.Lk)("div",{class:"divMargin"},null,-1)),(0,m.Lk)("div",_e,[(0,m.Lk)("p",null,(0,p.v_)(e.$t("fractionBits")),1),(0,m.bo)((0,m.Lk)("input",{id:"propM",class:(0,p.C4)(a.backM),"onUpdate:modelValue":t[15]||(t[15]=e=>a.propM=e)},null,2),[[n.Jo,a.propM]]),"correctInput"===a.backM?((0,m.uX)(),(0,m.CE)("div",$e,t[23]||(t[23]=[(0,m.Lk)("svg",{version:"1",xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 48 48","enable-background":"new 0 0 48 48"},[(0,m.Lk)("polygon",{fill:"#43A047",points:"40.6,12.1 17,35.7 7.4,26.1 4.6,29 17,41.3 43.4,14.9"})],-1)]))):(0,m.Q3)("",!0)]),t[26]||(t[26]=(0,m.Lk)("div",{class:"divMargin"},null,-1)),(0,m.Lk)("button",{id:"checkSolution",onClick:t[16]||(t[16]=(...e)=>o.checkSolution&&o.checkSolution(...e))},(0,p.v_)(e.$t("check")),1)]),(0,m.Lk)("h4",null,(0,p.v_)(e.$t("correctSolution")),1),(0,m.Lk)("div",ye,[(0,m.Lk)("div",null,[!1===a.denominatorZero?((0,m.uX)(),(0,m.Wv)(l,{key:0,text:e.$t("attSolve")},null,8,["text"])):(0,m.Q3)("",!0),a.negativeSummand?((0,m.uX)(),(0,m.Wv)(l,{key:1,text:e.$t("negativeSummand")},null,8,["text"])):(0,m.Q3)("",!0),a.negativeSubtrahend?((0,m.uX)(),(0,m.Wv)(l,{key:2,text:e.$t("negativeSubtrahend")},null,8,["text"])):(0,m.Q3)("",!0),a.denominatorZero?((0,m.uX)(),(0,m.Wv)(l,{key:3,text:e.$t("zeroDivision")},null,8,["text"])):(0,m.Q3)("",!0)]),(0,m.Lk)("div",null,[a.negativeMinuendSubtrahend?((0,m.uX)(),(0,m.Wv)(l,{key:0,text:e.$t("negativeMinuendSubtrahend")},null,8,["text"])):(0,m.Q3)("",!0)])]),(0,m.Lk)("div",Ee,[(0,m.bF)(u,{solutionDescription:o.solDescr},{default:(0,m.k6)((()=>[((0,m.uX)(!0),(0,m.CE)(m.FK,null,(0,m.pI)(o.solDescr,(e=>((0,m.uX)(),(0,m.Wv)(c,{key:e.name},{"accordion-item-title":(0,m.k6)((()=>[(0,m.eW)((0,p.v_)(e.name),1)])),"accordion-item-body":(0,m.k6)((()=>[(0,m.Lk)("span",{innerHTML:e.text},null,8,Ce),null!=e.subpanels?((0,m.uX)(),(0,m.Wv)(u,{key:0},{default:(0,m.k6)((()=>[((0,m.uX)(!0),(0,m.CE)(m.FK,null,(0,m.pI)(e.subpanels,(e=>((0,m.uX)(),(0,m.Wv)(c,{key:e.name},{"accordion-item-title":(0,m.k6)((()=>[(0,m.eW)((0,p.v_)(e.name),1)])),"accordion-item-body":(0,m.k6)((()=>[(0,m.Lk)("span",{innerHTML:e.text},null,8,Me)])),_:2},1024)))),128))])),_:2},1024)):(0,m.Q3)("",!0)])),_:2},1024)))),128))])),_:1},8,["solutionDescription"])]),t[27]||(t[27]=(0,m.Lk)("div",{id:"jaxHelper"},null,-1))])])}const Te={class:"attention"};function Se(e,t,i,n,s,a){const o=(0,m.g2)("font-awesome-icon");return(0,m.uX)(),(0,m.CE)("div",Te,[(0,m.bF)(o,{class:"infoCircle",icon:"info-circle"}),(0,m.Lk)("label",null,(0,p.v_)(this.text),1)])}var Ne={name:"AttentionBanner",props:["text"],data(){return{}}};const Be=(0,z.A)(Ne,[["render",Se],["__scopeId","data-v-0a955a9d"]]);var Fe=Be;const Le=["disabled"],Ae=["disabled"],Ve=["value"];function Ie(e,t,i,s,a,o){const r=(0,m.g2)("font-awesome-icon");return(0,m.uX)(),(0,m.CE)("div",{class:"selectBox",disabled:i.isDisabled},[(0,m.bo)((0,m.Lk)("select",{class:"fpfSelect","onUpdate:modelValue":t[0]||(t[0]=e=>a.selectedOption=e),disabled:i.isDisabled,onInput:t[1]||(t[1]=t=>{e.$emit("input",i.num,t.target.value)})},[((0,m.uX)(!0),(0,m.CE)(m.FK,null,(0,m.pI)(i.options,((e,t)=>((0,m.uX)(),(0,m.CE)("option",{value:t,key:t},(0,p.v_)(e),9,Ve)))),128))],40,Ae),[[n.u1,a.selectedOption]]),(0,m.bF)(r,{class:"angleDown",icon:"angle-down"})],8,Le)}var De={name:"FormatSelect",props:["num","sel","options","isDisabled"],emits:["input"],created(){this.selectedOption=this.sel},data(){return{selectedOption:"binary"}},watch:{sel:{immediate:!0,handler(e){this.selectedOption=e}}},methods:{setSelected(e){this.selectedOption=e}}};const Pe=(0,z.A)(De,[["render",Ie],["__scopeId","data-v-6f4cc2eb"]]);var Oe=Pe;const je={class:"accordion"};function Re(e,t,i,n,s,a){return(0,m.uX)(),(0,m.CE)("div",je,[(0,m.RG)(e.$slots,"default",{},void 0,!0)])}var ze={};const We=(0,z.A)(ze,[["render",Re],["__scopeId","data-v-04d699bf"]]);var qe=We;const He={class:"accordion-item"},Ue={key:0,class:"accordion-item-body",ref:"accordion_item_body"};function Ke(e,t,i,n,s,a){const o=(0,m.g2)("font-awesome-icon");return(0,m.uX)(),(0,m.CE)("div",He,[(0,m.Lk)("div",{class:"accordion-item-header",onClick:t[0]||(t[0]=(...e)=>a.doclick&&a.doclick(...e))},[(0,m.RG)(e.$slots,"accordion-item-title",{},void 0,!0),(0,m.bF)(o,{class:"angleDown",icon:"angle-down"})]),!0===this.expanded?((0,m.uX)(),(0,m.CE)("div",Ue,[this.expandableSideways?((0,m.uX)(),(0,m.CE)("button",{key:0,class:"accordion-item-expand-sideways-toggle ion-md-expand",onClick:t[1]||(t[1]=(...e)=>a.toggleExpandSideways&&a.toggleExpandSideways(...e))}," > ")):(0,m.Q3)("",!0),(0,m.RG)(e.$slots,"accordion-item-body",{},void 0,!0)],512)):(0,m.Q3)("",!0)])}var Ge={props:["expandableSideways"],data(){return{expanded:!1,expandedSideways:!0}},methods:{doclick(e){this.expanded=!this.expanded,e.target.classList.contains("accordion-item-header")&&e.target.classList.toggle("active"),this.$nextTick((()=>{window.MathJax&&window.MathJax.typeset()})),e.preventDefault()},toggleExpandSideways(e){this.expandedSideways=!this.expandedSideways,this.$nextTick((()=>{window.MathJax&&window.MathJax.typeset()})),e.target.classList.contains("accordion-item-expand-sideways-toggle")&&this.$refs.accordion_item_body.classList.toggle("accordion-item-body-expanded-sideways")}}};const Xe=(0,z.A)(Ge,[["render",Ke],["__scopeId","data-v-92ff0172"]]);var Ze=Xe;i(4114);function Je(e,t,i=!1,n=2){let s=e;if(s.length<t)return s;let a=!1;"string"===typeof s&&(s=s.split("").map((e=>parseInt(e,10))),a=!0);let o=i;o||(o=s[t]>=n/2);while(s.length>t)s.pop();if(o){const e=[],t=[];e.unshift(1);for(let i=s.length-1;i>=0;i-=1){const a=s[i]+e[0];t.unshift(a%n),e.unshift(Math.floor(a/n))}return e[0]!==e[1]&&(t.unshift(1),t.pop()),a?t.join(""):t}return a?s.join(""):s}function Ye(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}class Qe{constructor(e,t){Ye(this,Qe),this.exponentBits=e,this.numBits=t,this.result=""}getBias(){return 2**(this.exponentBits-1)-1}binToIEEE(e){this.result="";const t=this.getBias(),i=e.replace(",",".").split(".");let n=i[0];const s=i[1];let a=0;"-"===n[0]&&(a=1,n=n.substring(1));let o=!0;for(const m of[n,s].join(""))if("0"!==m){o=!1;break}if(o){const e="0".repeat(this.exponentBits),t="0".repeat(this.numBits-this.exponentBits-1);return void(this.result=`${a} ${e} ${t}`)}const r=n.replace(/^0+/,"");console.log(r);let l=r.substring(1);const c=l.length,u=this.numBits-this.exponentBits-1;null!=s&&(l+=s);let h=0;""===r&&(h=l.indexOf("1")+1,l=l.slice(h)),l.length>u&&(l=Je(l,u)),l.length<u&&(l+="0".repeat(u-l.length));let d=(c+t-h).toString(2);(d.length>this.exponentBits||d==="1".repeat(this.exponentBits))&&(d="1".repeat(this.exponentBits),l="0".repeat(u)),d="0".repeat(this.exponentBits-d.length)+d,this.result=`${a} ${d} ${l}`}ieeeToBin(e){this.result="";const t=e.replace(/\s/g,"");t.length!==this.numBits&&(this.result=0);const i=0===t[0]?"":"-";let n=t.substring(1,1+this.exponentBits);const s=t.substring(1+this.exponentBits,this.numBits),a=this.getBias();n-=a;let o=1,r=s;n<0?(o=0,r=`${"0".repeat(n-1)}1${s}`):(o=`1${s.substring(0,Math.min(n,s.length))}\n          ${"0".repeat(Math.max(0,n-s.length))}`,r=s.substring(n)),""===r&&(this.result=`${i}${o}`),this.result=`${i}${o},${r}`}ieeeToDec(e,t=""){let i=!1;if(""!==t&&"none"!==t)switch(t){case"zero":return void(this.result="0.0");case"nan":return void(this.result="NaN");case"inf":return void(0===Number(e[0])?this.result="Inf":this.result="-Inf");case"denormalized":i=!0;break;default:}this.result="";const n=e.replace(/\s/g,"");let s=!0;for(const m of n.substr(1))if("0"!==m){s=!1;break}if(s)return void(this.result=0);let a=!0;for(const m of n.substr(1))if("1"!==m){a=!1;break}if(a)return void(this.result="NaN");n.length!==this.numBits&&(this.result=0),console.log(n,this.exponentBits,this.numBits);const o="0"===n[0]?1:-1,r=n.substring(1,1+this.exponentBits),l=n.substring(1+this.exponentBits,this.numBits),c=this.getBias();let u=0,h=0;for(let m=r.length-1;m>=0;m-=1)u+=r[m]*2**h,h+=1;u-=c;let d=i?0:1;for(let m=0;m<l.length;m+=1)d+=l[m]*2**(-m-1);console.log(l),console.log(o,d,u,o*d*2**u),this.result=o*d*2**u}decToBin(e){this.result="";const t=parseFloat(e.replace(",","."));this.result=t.toString(2)}binToDec(e){this.result="";const t=e.replace(",","."),i=t.split(".");let n=parseInt(i[0],2);if(null!=i[1]&&-1!==i[1].lastIndexOf("1")){const e=i[1].substring(0,i[1].lastIndexOf("1")+1),t=parseInt(e,2)/2**e.length;n<0?n-=t:n+=t}this.result=n}}function et(e){return e>=0&&e<=9?String.fromCharCode(e+"0".charCodeAt(0)):e>=10&&e<=35?String.fromCharCode(e+"A".charCodeAt(0)):""}function tt(e){return"0".charCodeAt()<=e.charCodeAt()&&e.charCodeAt()<="9".charCodeAt()?e.charCodeAt()-"0".charCodeAt():"A".charCodeAt()<=e.charCodeAt()&&e.charCodeAt()<="Z"?e.charCodeAt()-"A".charCodeAt()+10:-1}class it{constructor(e,t,i){(e<=0||t<=0)&&console.log("IEEENumber(number, number, arr): Invalid number of bits for exponent and mantissa."),this.expBitNum=e,this.manBitNum=t,this.bitNum=e+t+1,this._checkArray(i),this.arr=[...i],this.sign=this.arr[0],this.bias=(1<<e-1)-1,this.E=this._constructE(),this.M=this._constructM();let n=!1,s=!0,a=!0;for(let o=e+1;o<this.bitNum;o+=1)0!==this.arr[o]&&(a=!1,n=!0,s=!1);for(let o=1;o<=e;o+=1)0!==this.arr[o]&&(a=!1),1!==this.arr[o]&&(n=!1,s=!1);this.isNaN=n,this.isInfinity=s,this.isZero=a,this.isDenormalized=0===this.E&&0!==this.M,this.exponent=this._constructExponent(),this.mantissa=this._constructMantissa(),this.exponentBits=this._constructExponentBits(),this.mantissaBits=this._constructMantissaBits(),this.bitString=this._constructBitString(),this.valueString=this._constructValString()}_checkArray(e){if(e.length!==this.bitNum)return!1;for(let t=0;t<e.length;t+=1)if(e[t]<0||e[t]>=2)return!1;return!0}_constructBitString(){let e="",t=0;for(let i=0;i<this.arr.length;i+=1)e+=et(this.arr[i]),0!==i&&i!==this.expBitNum||(t=0,e+=" "),t%4===0&&(e+=" "),t+=1;return e}_constructValString(){const e=0===this.arr[0]?"+":"-";return this.isNan?"NaN":this.isInfinity?`${e}inf`:this.isZero?`${e}0`:`${e}${this.mantissa}e${this.exponent}`}_constructE(){let e=0;for(let t=1;t<1+this.expBitNum;t+=1)e*=2,e+=this.arr[t];return e}_constructM(){let e=0;for(let t=this.bitNum-1;t>=1+this.expBitNum;t-=1)e/=2,e+=this.arr[t];return e/=2,e}_constructExponent(){return Math.max(1-this.bias,this.E-this.bias)}_constructMantissa(){return this.isDenormalized||this.isZero?this.M:1+this.M}_constructExponentBits(){const e=[...this.arr];return e.splice(0,1),e.splice(this.expBitNum,this.manBitNum),e}_constructMantissaBits(){const e=this.isDenormalized||this.isZero?0:1,t=[...this.arr];return t.splice(0,1+this.expBitNum),t.unshift(e),t}}function nt(e,t){let i=t;t.length<=e+2&&(console.log("getIEEEFromString(expBitNum, str): Given string is not compatible with the given number of expBitNum."),process.exit(1));let n=!1,s=!1,a=!1;-1!==i.search("Inf")?n=!0:-1!==i.search("Zero")?s=!0:-1!==i.search("Nan")&&(a=!0),i=i.replace(/\s+/g,"");let o=!1;if(n||s||a){const e=i.length;i=i.replace(/[^0-9\.]+/g,""),e>i.length&&(o=!0)}for(let c=0;c<i.length;c+=1){const e=tt(i[c]);(e<0||e>=2)&&(console.log("getIEEEFromString(expBitNum, str): Given string is not compatible with base 2."),process.exit(1))}const r=[];for(let c=0;c<i.length;c+=1)" "!==i[c]&&r.push(tt(i[c]));const l=new it(e,r.length-e-1,r);return o&&n?l.isInfinity=!0:o&&a?l.isNaN=!0:o&&s&&(l.isZero=!0),l}function st(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}class at{constructor(e,t,i,n){st(this,at),this.imp=e,this.table="",this.result=(0,Q.Kh)([]),this.exponentBits=t,this.numBits=i,this.watcher=n}getAdditionTable(){const e=this.watcher.steps.AddMantissa.data.addition.steps.Addition.data.op1Arr,t=this.watcher.steps.AddMantissa.data.addition.steps.Addition.data.op2Arr,i=this.watcher.steps.AddMantissa.data.addition.steps.Addition.data.carryArr,n=this.watcher.steps.AddMantissa.data.addition.steps.Addition.data.resultArr,s=this.watcher.steps.AddMantissa.data.binNum,a=[],o=[],r=[],l=[],c=[];a.push("&"),o.push("+&"),l.push("&"),r.push("&"),c.push("{"),console.log(e),console.log(t);for(let u=e.length;u<=s;u+=1)e.unshift(0);for(let u=t.length;u<=s;u+=1)t.unshift(0);for(let u=i.length;u<=s;u+=1)i.unshift(0);for(let u=0;u<=s+1;u+=1){if(c.push("c"),2===u)a.push(","),o.push(","),l.push(""),r.push(",");else{const s=u>2?u-1:u;a.push(` ${e[s]}`),o.push(` ${t[s]}`),l.push(`\\scriptsize{${i[s]}}`),r.push(` ${n[s]}`)}a.push("&"),l.push("&"),o.push("&"),r.push("&")}c.push("}"),a.pop(),a.push("\\\\ "),o.pop(),l.pop(),l.push("\\\\ "),o.push("\\\\ "),r.pop(),this.table=[`\\begin{array} ${c.join("")}`,`${a.join("")}`,`${o.join("")}`,`${l.join("")}`,"\\hline",`${r.join("")}`,"\\end{array}"].join("")}createExponentShiftDescription(e,t,i,n,s,a,o,r){const l=Math.max(t,s),c=Math.min(t,s);return[`${this.imp.$t("smallerExponent")} `,`\\( ( [ ${e} ] :=  ${t} ${i}\n            [ ${n} ] :=  ${s}) \\) `,"</br>",`${this.imp.$t("resDiffExponent")}: `,`\\( ${l} - ${c} = ${a} \\)`,"</br>",` ${this.imp.$t("shiftMantissa")}: \\( `,o,`\\overset{\\text{Shift: ${a} }}{\\rightarrow}`,r,"\\)"].join("")}additionDescription(e,t,i){let n,s;t.exponent>=i.exponent&&0===t.sign?(n=JSON.parse(JSON.stringify(t)),s=JSON.parse(JSON.stringify(i))):(n=JSON.parse(JSON.stringify(i)),s=JSON.parse(JSON.stringify(t))),console.log(n),console.log(s);let a=n.mantissaBits.join("");a=`${a[0]},${a.substring(1)}`;let o=s.mantissaBits.join("");o=`${o[0]},${o.substring(1)}`;const r=n.exponentBits.join(""),l=s.exponentBits.join(""),c=this.watcher;if(this.result.push({name:this.imp.$t("values"),text:`${this.imp.$t("firstSummand")}: ${this.imp.$t("sign")}: ${0===n.sign?"+":"-"} ${this.imp.$t("exponent")}: ${r} ${this.imp.$t("mantissa")}: ${a}<br>${this.imp.$t("secondSummand")}: ${this.imp.$t("sign")}: ${0===s.sign?"+":"-"} ${this.imp.$t("exponent")}: ${l} ${this.imp.$t("mantissa")}: ${o}`}),n.isZero||s.isZero){this.result.push((0,Q.Kh)({name:`${this.imp.$t("step")} 1`,text:[`${this.imp.$t("addWithZero")}`].join("")}));const e=new Qe(this.exponentBits,this.numBits);e.ieeeToDec([c.steps.Result.data.result.sign," ",c.steps.Result.data.result.exponentBits.join(""),c.steps.Result.data.result.mantissaBits.join("").substring(1)].join(""),c.steps.ResultEdgecase.data.edgecase);const t=e.result;this.createIEEESolutionBox(t,c.steps.Result.data.result)}else if("none"!==c.steps.ResultEdgecase.data.edgecase){switch(c.steps.ResultEdgecase.data.edgecase){case"nan":this.result.push((0,Q.Kh)({name:`${this.imp.$t("step")} 2`,text:[`${this.imp.$t("solutionIsNan")}`].join("")}));break;case"inf":this.result.push((0,Q.Kh)({name:`${this.imp.$t("step")} 2`,text:[`${this.imp.$t("solutionIsInf")}`].join("")}));break;case"zero":this.result.push((0,Q.Kh)({name:`${this.imp.$t("step")} 2`,text:[`${this.imp.$t("solutionIsZero")}`].join("")}));break;default:}const e=new Qe(this.exponentBits,this.numBits);e.ieeeToDec([c.steps.Result.data.result.sign," ",c.steps.Result.data.result.exponentBits.join(""),c.steps.Result.data.result.mantissaBits.join("").substring(1)].join(""),c.steps.ResultEdgecase.data.edgecase);const t=e.result;this.createIEEESolutionBox(t,c.steps.Result.data.result)}else{const e=this.watcher.steps.CalculateDeltaE.data.deltaE;if(0===e)this.result.push((0,Q.Kh)({name:`${this.imp.$t("step")} 1`,text:`${this.imp.$t("adjustExponents")} \\( (${r} = ${l} \\Rightarrow i.O.) \\)`}));else{const t=c.steps.CalculateDeltaE.data.switched?"<":">",i=c.steps.CalculateDeltaE.data.expN1Bits.join(""),n=c.steps.CalculateDeltaE.data.expN2Bits.join(""),s=c.steps.CalculateDeltaE.data.expN1,a=c.steps.CalculateDeltaE.data.expN2,o=c.steps.CalculateDeltaE.data.preShift.join(""),u=c.steps.AddMantissa.data.mantissa2.join("");this.result.push((0,Q.Kh)({name:`${this.imp.$t("step")} 1`,text:`${this.imp.$t("adjustExponents")} \\( (${r} \\neq ${l}) \\)`,subpanels:[{name:`${this.imp.$t("diffExponent")}`,text:this.createExponentShiftDescription(i,s,t,n,a,e,e,o,u)}]}))}c.steps.AddMantissa.data.equalMantissa?this.result.push((0,Q.Kh)({name:`${this.imp.$t("step")} 2`,text:`${this.imp.$t("addMantissa")}`,subpanels:[{name:`${this.imp.$t("newMantissa")}`,text:`${this.imp.$t("equalMantissa")}`}]})):(this.getAdditionTable(),c.steps.Result.data.result.isDenormalized?this.result.push((0,Q.Kh)({name:`${this.imp.$t("step")} 2`,text:[`${this.imp.$t("addMantissa")}`].join(""),subpanels:[{name:`${this.imp.$t("newMantissa")}`,text:[`${this.imp.$t("consider1comma")} `,`${this.imp.$t("newMantissaIs")}`,"<br> <br>","\\(",this.table,"\\)","<br> <br>",0!==c.steps.AddMantissa.data.shift?`${this.imp.$t("mantissaNormalizeDenorm",{shift:c.steps.Normalize.data.shift,exponent:c.steps.Normalize.data.finalExpBits.join("")})} <br>`:"",`${this.imp.$t("mantissa1float")} ${c.steps.Normalize.data.normalizedMantissa.join("")}`].join("")}]})):this.result.push((0,Q.Kh)({name:`${this.imp.$t("step")} 2`,text:[`${this.imp.$t("addMantissa")}`].join(""),subpanels:[{name:`${this.imp.$t("newMantissa")}`,text:[`${this.imp.$t("consider1comma")} `,`${this.imp.$t("newMantissaIs")}`,"<br> <br>","\\(",this.table,"\\)","<br> <br>",0!==c.steps.AddMantissa.data.shift?`${this.imp.$t("mantissaNormalize",{shift:c.steps.Normalize.data.shift,exponent:c.steps.Normalize.data.finalExpBits.join("")})} <br>`:"",`${this.imp.$t("mantissa1float")} ${c.steps.Normalize.data.normalizedMantissa.join("")}`].join("")}]}))),console.log(this.watcher);const t=new Qe(this.exponentBits,this.numBits);t.ieeeToDec([this.watcher.steps.Result.data.result.sign," ",this.watcher.steps.Result.data.result.exponentBits.join(""),this.watcher.steps.Result.data.result.mantissaBits.join("").substring(1)].join(""),this.watcher.steps.ResultEdgecase.data.edgecase);const i=t.result;this.createIEEESolutionBox(i,c.steps.Result.data.result)}}getMultiplicationTable(){const e=[],t=this.watcher;if(t.steps.Result.data.result.isNaN)this.table=`\\text{${this.imp.$t("solutionIsNan")}}`;else{const i=t.steps.Multiplication.data.multiplication,n=i.steps.MultiplicationSteps.data,s=i.steps.MultiplicationInput.data.leftArr,a=i.steps.MultiplicationInput.data.rightArr;while(0===s[s.length-1])s.pop();const o=s.length;while(0===a[a.length-1])a.pop();const r=a.length,l=Math.min(n.countSteps,r),c=i.steps.Result.data.resultArr,u=n.Step0_toAdd.arr.length;let h=Math.max(o+l,o+r,r+l)+3;e.push("{"),e.push("c|");for(let t=0;t<h;t+=1)e.push("c");e.push("c"),e.push("}");const d=[`&&${s.join("&")}`];d[0]+="&\\times&",d[0]+=a.join("&");for(let e=s.length+a.length+1;e<h;e+=1)d[0]+="&";let m=new Qe(this.exponentBits,this.numBits);m.binToDec(s.join(""));const p=m.result;m.binToDec(a.join(""));const f=m.result;d[0]+=`\\ (${p}_{10} * ${f}_{10})\\\\`,d[0]+="\\hline";for(let e=0;e<l;e+=1){d.push(`${e}&+`);let t=n[`Step${e}_toAdd`].arr;const i=t.every((e=>0===e));i||(t=s),u-t.length>0&&(t=t.concat(Array(u-t.length).fill(0,0)));for(let n=0;n<e;n+=1)d[d.length-1]+="&";d[d.length-1]=d[d.length-1],d[d.length-1]+="&",d[d.length-1]+=t.join("&");for(let n=t.length+e;n<h;n+=1)d[d.length-1]+="&";const a=c.length-t.length-1;a>0&&(t=t.concat(Array(a).fill(0,0))),m=new Qe(this.exponentBits,this.numBits),m.binToDec(t.join(""));const o=m.result*2**-e;d[d.length-1]+=`\\ (${o}_{10})`,d[d.length-1]+="\\\\ "}d.push("\\hline"),d.push("\\mathcal{L}&");let g=1;for(let e=c.length;e<=u;e+=1)d.push("&"),g+=1;d[d.length-1]+=`${c.join("&")}`,g+=c.length;for(let e=g;e<=h;e+=1)d[d.length-1]+="&";m=new Qe(this.exponentBits,this.numBits),m.binToDec(c.join(""));const b=m.result;d[d.length-1]+=`&\\ (${b}_{10})`,this.table=[`\\begin{array} ${e.join("")}`,d.join(""),"\\end{array}"].join("")}}multiplicationDescription(e,t,i){let n=t.mantissaBits.join("");n=`1,${n.substring(1)}`;let s=i.mantissaBits.join("");s=`1,${s.substring(1)}`;const a=t.exponentBits.join(""),o=i.exponentBits.join(""),r=this.watcher;if(this.result.push((0,Q.Kh)({name:`${this.imp.$t("values")}`,text:`${this.imp.$t("firstFactor")}: ${this.imp.$t("sign")}: ${0===t.sign?"+":"-"} ${this.imp.$t("exponent")}: ${a} ${this.imp.$t("mantissa")}: ${n}<br>${this.imp.$t("secondFactor")}: ${this.imp.$t("sign")}: ${0===i.sign?"+":"-"} ${this.imp.$t("exponent")}: ${o} ${this.imp.$t("mantissa")}: ${s}`})),t.isZero||i.isZero)this.result.push((0,Q.Kh)({name:`${this.imp.$t("step")} 1`,text:[`${this.imp.$t("mulWithZero")}`].join("")}));else{if("none"!==r.steps.ResultEdgecase.data.edgecase){switch(r.steps.ResultEdgecase.data.edgecase){case"nan":return void this.result.push((0,Q.Kh)({name:`${this.imp.$t("step")} 1`,text:[`${this.imp.$t("solutionIsNan")}`].join("")}));case"inf":return void this.result.push((0,Q.Kh)({name:`${this.imp.$t("step")} 1`,text:[`${this.imp.$t("solutionIsInf")}`].join("")}));case"zero":this.result.push((0,Q.Kh)({name:`${this.imp.$t("step")} 1`,text:[`${this.imp.$t("solutionIsZero")}`].join("")}));break;default:}return}{const e=new Qe(this.exponentBits,this.numBits);e.binToDec(a),e.binToDec(o),console.log(r);let t=r.steps.CalculateExp.data.notShifted;const i=[],n=r.steps.Result.data.result.expBitNum;for(let a=0;a<n;a+=1)i.unshift(t%2),t=Math.floor(t/2);this.result.push((0,Q.Kh)({name:`${this.imp.$t("step")} 1`,text:[this.imp.$t("addExponents"),this.imp.$t("newExponentMultiplication",{E1:r.steps.CalculateExp.data.E1,E2:r.steps.CalculateExp.data.E2,Bias:r.steps.CalculateExp.data.bias,Result:r.steps.CalculateExp.data.notShifted,ExpBits:i.join("")})].join(" ")})),this.getMultiplicationTable();const s=[`${this.imp.$t("newMantissaIs")}`,"<br> <br>",`\\( ${this.table} \\)`,"<br> <br>"];if(console.log(r),s.push(`${this.imp.$t("consider1comma")} `),0!==r.steps.MulMantissa.data.shift){const e=this.imp.$t("mantissaNormalize",{shift:r.steps.MulMantissa.data.shift,exponent:r.steps.Result.data.result.exponentBits.join("")});s.push(`${e} <br>`)}s.push(`${this.imp.$t("mantissa1float")} ${r.steps.MulMantissa.data.normalizedMantissa.join("")}`);const l=s.join("");this.result.push((0,Q.Kh)({name:`${this.imp.$t("step")} 2`,text:[`${this.imp.$t("mulMantissa")}`].join(""),subpanels:[{name:`${this.imp.$t("doMultiplication")}`,text:l}]}))}}const l=new Qe(this.exponentBits,this.numBits);l.ieeeToDec([r.steps.Result.data.result.sign," ",r.steps.Result.data.result.exponentBits.join(""),r.steps.Result.data.result.mantissaBits.join("").substring(1)].join(""),r.steps.ResultEdgecase.data.edgecase);const c=l.result;this.createIEEESolutionBox(c,r.steps.Result.data.result),console.log(r)}getSubtractionTable(){const e=this.watcher.steps.Addition.data.addition,t=e.steps.AddMantissa.data.addition.steps.Addition.data.op1Arr,i=e.steps.AddMantissa.data.addition.steps.Addition.data.op2Arr,n=e.steps.AddMantissa.data.addition.steps.Addition.data.carryArr,s=e.steps.AddMantissa.data.addition.steps.Addition.data.resultArr,a=e.steps.AddMantissa.data.binNum,o=[],r=[],l=[],c=[],u=[],h=[],d=[];console.log(e.steps.AddMantissa.data.addition.steps.Addition.data),console.log(e.steps),1===e.steps.AddMantissa.data.sign1&&0===e.steps.AddMantissa.data.sign2?(o.push("-&"),r.push("+&")):0===e.steps.AddMantissa.data.sign1&&1===e.steps.AddMantissa.data.sign2?(o.push("&"),r.push("-&")):(o.push("-&"),r.push("-&")),l.push("&"),c.push("+&"),u.push("\\scriptsize{+}&"),h.push("=&"),d.push("{");for(let m=t.length;m<=a;m+=1)0===e.steps.AddMantissa.data.addition.steps.Addition.data.op1.signBit?t.unshift(0):t.unshift(1);for(let m=i.length;m<=a;m+=1)0===e.steps.AddMantissa.data.addition.steps.Addition.data.op2.signBit?i.unshift(0):i.unshift(1);for(let m=n.length;m<=a;m+=1)n.unshift(0);for(let m=s.length;m<=a;m+=1)s.unshift(e.steps.AddMantissa.data.addition.steps.Addition.data.result.signBit);for(let m=0;m<a+1;m+=1){if(d.push("c"),2===m)l.push(","),c.push(","),u.push(""),h.push(",");else{const e=m>2?m-1:m;l.push(` ${t[e]}`),c.push(` ${i[e]}`),u.push(` \\scriptsize{${n[e]}}`),h.push(` ${s[e]}`)}l.push("&"),c.push("&"),u.push("&"),h.push("&")}d.push("}"),o.pop(),o.push("\\\\ "),r.pop(),r.push("\\\\ "),l.pop(),l.push("\\\\ "),c.pop(),c.push("\\\\ "),u.pop(),u.push("\\\\ "),h.pop(),this.table=[`\\begin{array} ${d.join("")}`,`${l.join("")}`,`${c.join("")}`,`${u.join("")}`,"\\hline",`${h.join("")}`,"\\end{array}"].join("")}createIEEESolutionBox(e,t){this.result.push((0,Q.Kh)({name:this.imp.$t("solution"),text:[`${this.imp.$t("solution")}: ${t.sign} ${t.exponentBits.join("")} ${t.mantissaBits.join("").substring(1)}`,"\\( \\implies \\)",` ${this.imp.$t("decimal")}: ${e}`].join("")+this.createIEEENumberBreakdown(t)}))}createIEEENumberBreakdown(e){return`<ul><li>${this.imp.$t("sign")}: ${e.sign}</li><li>${this.imp.$t("exponent")}: ${e.exponentBits.join("")}</li><li>${this.imp.$t("mantissa")}: ${e.mantissaBits.join("").substring(1)}</li></ul>`}subtractionDescription(e,t,i){let n,s;t.exponent>=i.exponent?(n=JSON.parse(JSON.stringify(t)),s=JSON.parse(JSON.stringify(i))):(n=JSON.parse(JSON.stringify(i)),s=JSON.parse(JSON.stringify(t)));let a=n.mantissaBits.join("");a=`1,${a.substring(1)}`;let o=s.mantissaBits.join("");o=`1,${o.substring(1)}`;const r=n.exponentBits.join(""),l=s.exponentBits.join(""),c=this.watcher;console.log(n),console.log(s),console.log(c);let u=1;this.result.push((0,Q.Kh)({name:`${this.imp.$t("values")}`,text:`${this.imp.$t("minuend")}: ${this.imp.$t("sign")}: ${0===n.sign?"+":"-"} ${this.imp.$t("exponent")}: ${r} ${this.imp.$t("mantissa")}: ${a}<br>${this.imp.$t("subtrahend")}: ${this.imp.$t("sign")}: ${0===s.sign?"+":"-"} ${this.imp.$t("exponent")}: ${l} ${this.imp.$t("mantissa")}: ${o}`}));const h=c.steps.Addition.data.addition;if(console.log(n),console.log(s),n.isZero||s.isZero){this.result.push((0,Q.Kh)({name:`${this.imp.$t("step")} ${u}`,text:[`${this.imp.$t("subWithZero")}`].join("")}));const e=new Qe(this.exponentBits,this.numBits);e.ieeeToDec([h.steps.Result.data.result.sign," ",h.steps.Result.data.result.exponentBits.join(""),h.steps.Result.data.result.mantissaBits.join("").substring(1)].join(""),h.steps.ResultEdgecase.data.edgecase);const t=e.result;this.createIEEESolutionBox(t,h.steps.Result.data.result)}else if("none"!==h.steps.ResultEdgecase.data.edgecase){switch(h.steps.ResultEdgecase.data.edgecase){case"nan":return void this.result.push((0,Q.Kh)({name:`${this.imp.$t("step")} ${u}`,text:[`${this.imp.$t("solutionIsNan")}`].join("")}));case"inf":return void this.result.push((0,Q.Kh)({name:`${this.imp.$t("step")} ${u}`,text:[`${this.imp.$t("solutionIsInf")}`].join("")}));case"zero":return void this.result.push((0,Q.Kh)({name:`${this.imp.$t("step")} ${u}`,text:[`${this.imp.$t("solutionIsZero")}`].join("")}));default:}const e=new Qe(this.exponentBits,this.numBits);e.ieeeToDec([h.steps.Result.data.result.sign," ",h.steps.Result.data.result.exponentBits.join(""),h.steps.Result.data.result.mantissaBits.join("").substring(1)].join(""),h.steps.ResultEdgecase.data.edgecase);const t=e.result;console.log(c),this.createIEEESolutionBox(t,c.steps.Result.data.result)}else{if(0===h.steps.CalculateDeltaE.data.deltaE)this.result.push((0,Q.Kh)({name:`${this.imp.$t("step")} ${u}`,text:`${this.imp.$t("adjustExponents")} \\( (${r} = ${l} \\Rightarrow i.O.) \\)`}));else{const e=h.steps.CalculateDeltaE.data.switched?"<":">",t=h.steps.CalculateDeltaE.data.expN1Bits.join(""),i=h.steps.CalculateDeltaE.data.expN2Bits.join(""),n=h.steps.CalculateDeltaE.data.expN1,s=h.steps.CalculateDeltaE.data.expN2,a=h.steps.CalculateDeltaE.data.deltaE,o=h.steps.CalculateDeltaE.data.preShift.join(""),c=h.steps.AddMantissa.data.mantissa2.join("");this.result.push((0,Q.Kh)({name:`${this.imp.$t("step")} ${u}`,text:`${this.imp.$t("adjustExponents")} \\( (${r} \\neq ${l}) \\)`,subpanels:[{name:`${this.imp.$t("diffExponent")}`,text:this.createExponentShiftDescription(t,n,e,i,s,a,o,c)}]}))}if(h.steps.AddMantissa.data.equalMantissa){u+=1;const e=[`${this.imp.$t("subtraction")} ${this.imp.$t("mantissa")}`,`${this.imp.$t("consider1comma")} ${this.imp.$t("mantissa1float")} ${h.steps.AddMantissa.data.normalizedMantissa.join("")}`].join("");this.result.push((0,Q.Kh)({name:`${this.imp.$t("step")} ${u}`,text:e}))}else{if(h.steps.AddMantissa.data.complement1.steps.Complement.data.negate){u+=1;const e=h.steps.AddMantissa.data.mantissa1.join(""),t=h.steps.AddMantissa.data.complement1.steps.Complement.data.flippedArray.join(""),i=h.steps.AddMantissa.data.complement1.steps.Complement.data.oneAdded.join(""),n=h.steps.AddMantissa.data.complement1.steps.Complement.data.normalizedArray.join(""),s=t.substring(0,e.length),a=i.substring(0,e.length);this.result.push((0,Q.Kh)({name:`${this.imp.$t("step")} ${u}`,text:`${this.imp.$t("subtTwosComplement")}`,subpanels:[{name:`${this.imp.$t("mantissaTwosComplement")}: \\(${e}\\)`,text:`${this.imp.$t("switchBits")}: \\(${e} \\rightarrow ${s}\\)<br>${this.imp.$t("add1")}: \\(${s} \\rightarrow ${a}\\)<br>${this.imp.$t("normalize")}: \\(${a} \\rightarrow ${n}\\)`}]}))}const e=h.steps.AddMantissa.data.complement2.steps.Complement.data.negate;if(e){u+=1;const e=h.steps.AddMantissa.data.mantissa2.join(""),t=h.steps.AddMantissa.data.complement2.steps.Complement.data.flippedArray.join(""),i=h.steps.AddMantissa.data.complement2.steps.Complement.data.oneAdded.join(""),n=h.steps.AddMantissa.data.complement2.steps.Complement.data.normalizedArray.join(""),s=t.substring(0,e.length),a=i.substring(0,e.length);this.result.push((0,Q.Kh)({name:`${this.imp.$t("step")} ${u}`,text:`${this.imp.$t("subtTwosComplement")}`,subpanels:[{name:`${this.imp.$t("mantissaTwosComplement")}: \\(${e}\\)`,text:`${this.imp.$t("switchBits")}: \\(${e} \\rightarrow ${s}\\)<br>${this.imp.$t("add1")}: \\(${s} \\rightarrow ${a}\\)<br>${this.imp.$t("normalize")}: \\(${a} \\rightarrow ${n}\\)`}]}))}this.getSubtractionTable(),u+=1;let t=[e?`${this.imp.$t("newMantissaSignBit")}`:`${this.imp.$t("newMantissaIs")}`,"<br> <br>",`\\( ${this.table} \\)`,"<br> <br>"];if(h.steps.AddMantissa.data.sign&&t.push(`${this.imp.$t("mantissaComplement")} `),t.push(`${this.imp.$t("consider1comma")} `),0!==h.steps.AddMantissa.data.shift){const e=this.imp.$t("mantissaNormalize",{shift:h.steps.Normalize.data.shift,exponent:h.steps.Normalize.data.finalExpBits.join("")});t.push(`${e} <br>`)}t.push(`${this.imp.$t("mantissa1float")} ${h.steps.AddMantissa.data.normalizedMantissa.join("")}`),t=t.join(""),this.result.push((0,Q.Kh)({name:`${this.imp.$t("step")} ${u}`,text:`${this.imp.$t("addMantissa")}`,subpanels:[{name:`${this.imp.$t("newMantissa")}`,text:t}]}))}const e=new Qe(this.exponentBits,this.numBits);e.ieeeToDec([h.steps.Result.data.result.sign," ",h.steps.Result.data.result.exponentBits.join(""),h.steps.Result.data.result.mantissaBits.join("").substring(1)].join(""),h.steps.ResultEdgecase.data.edgecase);const t=e.result;this.createIEEESolutionBox(t,h.steps.Result.data.result)}}getDivisionTable(){const e=[];if(this.watcher.steps.Result.data.result.isNaN)this.table=`${this.imp.$t("solutionIsNan")}`;else{const t=this.watcher.steps.Division.data.division,i=t.steps.DivisionSteps.data,n=i.countSteps,s=t.steps.DivisionInput.data.n1Arr,a=i.Step0_Sub2,o=a.length,r=t.steps.Result.data.resultArr;let l=Math.max(i[`Step${n-1}_SubRes`].length-2,i.Step0_Sub1.length+i.Step0_Sub2.length);l=l+o+2,e.push("{"),e.push("c|");for(let h=0;h<l;h+=1)e.push("c");e.push("|c"),e.push("}");const c=[`&&${i.Step0_Sub1.join("&")}`];c[0]+="&:&",c[0]+=a.join("&");for(let e=s.length+a.length+1;e<l;e+=1)c[0]+="&";c[0]+="\\\\";let u=0;for(let e=0;e<n;e+=1){if(c.push("&&"),c.push(`${e}&&`),0!==u){const t=i[`Step${e-1}_Sub1`];for(let i=0;i<e-1;i+=1)t[i]=" ";c[c.length-2]+=t.join("&"),c[c.length-2]+="& 0";for(let n=i[`Step${e-1}_Sub1`].length+1;n<l;n+=1)c[c.length-2]+="&";e>0&&(c[c.length-2]+="\\Sigma < 0 \\rightarrow 0"),c[c.length-3]=c[c.length-3].replace("-","<")}else{const t=i[`Step${e}_Sub1`];for(let i=0;i<e-u;i+=1)t[i]=" ";c[c.length-2]+=t.join("&");for(let n=i[`Step${e}_Sub1`].length;n<l;n+=1)c[c.length-2]+="&";e>0&&(c[c.length-2]+="\\Sigma > 0 \\rightarrow 1")}for(let t=0;t<e;t+=1)c[c.length-1]+="&";c[c.length-1]=c[c.length-1].slice(0,-1),c[c.length-1]+="-&",c[c.length-1]+=a.join("&");for(let t=o+e;t<l;t+=1)c[c.length-1]+="&";0!==u&&(c[c.length-1]+=`\\hookrightarrow {\\scriptstyle ${this.imp.$t("repeatMinuend")}}`),c[c.length-2]+="\\\\ ",c[c.length-1]+="\\\\ ",c[c.length-1]+="\\hline",i[`Step${e}_SubRes_isNegative`]?u+=1:u=0}c.push("\\mathcal{L}&&"),c[c.length-1]+=`${r[0]},& ${r.slice(1,r.length).join("&")}`,c[c.length-1]+="&";for(let e=r.length;e<l-2;e+=1)c[c.length-1]+="&";0!==u?(c[c.length-1]+="&\\Sigma < 0 \\rightarrow 0",c[c.length-2]=c[c.length-2].replace("-","<")):c[c.length-1]+="&\\Sigma > 0 \\rightarrow 1",this.table=[`\\begin{array} ${e.join("")}`,c.join(""),"\\end{array}"].join("")}}divisionDescription(e,t,i){let n=t.mantissaBits.join("");n=`1,${n.substring(1)}`;let s=i.mantissaBits.join("");s=`1,${s.substring(1)}`;const a=t.exponentBits.join(""),o=i.exponentBits.join(""),r=this.watcher;if(this.result.push((0,Q.Kh)({name:`${this.imp.$t("values")}`,text:`${this.imp.$t("numerator")}: ${this.imp.$t("sign")}: ${0===t.sign?"+":"-"} ${this.imp.$t("exponent")}: ${a} ${this.imp.$t("mantissa")}: ${n}<br>${this.imp.$t("denominator")}: ${this.imp.$t("sign")}: ${0===i.sign?"+":"-"} ${this.imp.$t("exponent")}: ${o} ${this.imp.$t("mantissa")}: ${s}`})),t.isZero)this.result.push((0,Q.Kh)({name:`${this.imp.$t("step")} 1`,text:[`${this.imp.$t("divWithZero")}`].join("")}));else{if(i.isZero)return void this.result.push((0,Q.Kh)({name:`${this.imp.$t("step")} 1`,text:[`${this.imp.$t("divByZero")}`].join("")}));if(console.log(r),null!=r.steps.Exponent&&this.result.push((0,Q.Kh)({name:`${this.imp.$t("step")} ${this.result.length}`,text:[`${this.imp.$t("subtExponents")} ${this.imp.$t("newExponentDivision",{E1:r.steps.Exponent.data.E1,E2:r.steps.Exponent.data.E2,Bias:r.steps.Exponent.data.Bias,Result:r.steps.Exponent.data.EUnshifted})}`].join("")})),"none"!==r.steps.ResultEdgecase.data.edgecase)switch(r.steps.ResultEdgecase.data.edgecase){case"nan":return void this.result.push((0,Q.Kh)({name:`${this.imp.$t("step")} ${this.result.length}`,text:[`${this.imp.$t("solutionIsNan")}`].join("")}));case"inf":return void this.result.push((0,Q.Kh)({name:`${this.imp.$t("step")} ${this.result.length}`,text:[`${this.imp.$t("solutionIsInf")}`].join("")}));case"zero":return void this.result.push((0,Q.Kh)({name:`${this.imp.$t("step")} ${this.result.length}`,text:[`${this.imp.$t("solutionIsZero")}`].join("")}));default:}if(r.steps.Result.data.result.isNaN)this.result.push((0,Q.Kh)({name:`${this.imp.$t("step")} ${this.result.length}`,text:`${this.imp.$t("divMantissa")}`,subpanels:[{name:`${this.imp.$t("doDivision")}`,text:`${this.imp.$t("solutionIsNan")} ${this.imp.$t("newMantissaIs")}: ${e.mantissaBits.join("").substring(1)}`}]}));else if(r.steps.Division.data.equalMantissa)this.result.push((0,Q.Kh)({name:`${this.imp.$t("step")} 2`,text:`${this.imp.$t("divMantissa")}`,subpanels:[{name:`${this.imp.$t("doDivision")}`,text:`${this.imp.$t("equalMantissaDiv",{Mantissa:e.mantissaBits.join("").substring(1)})}`}]}));else{this.getDivisionTable();const t=[`${this.imp.$t("newMantissaIs")}`,"<br> <br>",`\\( ${this.table} \\)`,"<br> <br>"];if("denormalized"===r.steps.ResultEdgecase.data.edgecase)t.push(`${this.imp.$t("mantissaDenormalize")} <br>`);else{if(0!==r.steps.Exponent.data.Shift){const e=this.imp.$t("mantissaNormalize",{shift:r.steps.Exponent.data.Shift,exponent:r.steps.Result.data.result.exponentBits.join("")});t.push(`${e} <br>`)}t.push(`${this.imp.$t("mantissa1float")} ${e.mantissaBits.join("").substring(1)}`)}const i=t.join("");this.result.push((0,Q.Kh)({name:`${this.imp.$t("step")} 2`,text:`${this.imp.$t("divMantissa")}`,subpanels:[{name:`${this.imp.$t("doDivision")}`,text:i}]}))}}const l=new Qe(this.exponentBits,this.numBits);l.ieeeToDec([r.steps.Result.data.result.sign," ",r.steps.Result.data.result.exponentBits.join(""),r.steps.Result.data.result.mantissaBits.join("").substring(1)].join(""),r.steps.ResultEdgecase.data.edgecase);const c=l.result;this.createIEEESolutionBox(c,r.steps.Result.data.result)}makeDescriptionArithmetic(e,t,i,n){if(""!==e&&""!==t&&e!==this.imp.$t("falseFormat")&&t!==this.imp.$t("falseFormat")){const s=nt(this.exponentBits,i),a=nt(this.exponentBits,e),o=nt(this.exponentBits,t);switch(n){case"add":0===a.sign&&0===o.sign?this.additionDescription(s,a,o):1===o.sign?(o.sign=0,o.arr[0]=0,this.subtractionDescription(s,a,o)):this.subtractionDescription(s,a,o);break;case"mul":this.multiplicationDescription(s,a,o);break;case"sub":0===o.sign?1===a.sign?(this.negativeMinuendSubtrahend=!0,a.sign=0,a.arr[0]=0,o.sign=0,o.arr[0]=0,this.additionDescription(s,a,o)):this.subtractionDescription(s,a,o):1===a.sign&&1===o.sign?this.subtractionDescription(s,a,o):(o.sign=0,o.arr[0]=0,this.additionDescription(s,a,o));break;case"div":this.divisionDescription(s,a,o);break;default:}}else this.result=(0,Q.Kh)([])}makeDescriptionConversion(e){const t=new Qe(e.exponentBits.length,e.bitNum);let i="";e.isZero&&(i="zero"),e.isNaN&&(i="nan"),e.isInfinity&&(i="inf"),e.isDenormalized&&(i="denormalized"),t.ieeeToDec([e.sign," ",e.exponentBits.join(""),e.mantissaBits.join("").substring(1)].join(""),i);const n=t.result;this.createIEEESolutionBox(n,e)}}function ot(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}class rt{constructor(e){ot(this,rt),this.exponentBits=e,this.backVB="",this.backE="",this.backM=""}checkSolution(e,t,i,n){t.replace(/\s/g,"")===`${e.sign}`?this.backVB="correctInput":this.backVB="incorrectInput";const s=e.bitString.replace(/\s/g,""),a=s.substring(1,1+this.exponentBits),o=s.substring(1+this.exponentBits);i.replace(/\s/g,"")===a?this.backE="correctInput":this.backE="incorrectInput",n.replace(/\s/g,"")===o?this.backM="correctInput":this.backM="incorrectInput"}}function lt(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}class ct{constructor(e,t,i,n){lt(this,ct),this.imp=e,this.description=new at(this.imp,t,i,n),this.negativeMinuendSubtrahend=!1,this.exponentBits=t,this.numBits=i,this.watcher=n}getStyle(){let e="";e+="<style scoped>",e+=".MathJax { font-size: 11px !important; } ",e+="#body { size: A4; padding-top: 2cm; margin-top: 2cm; margin-bottom: 0.5cm; }",e+="#page :first { size: A4; margin-top: 0; margin-bottom: 0.5cm; }",e+="#header1 { color: black; font-family: arial; font-size: 28px; font-weight: bold;break-after: always; margin-left: auto; margin-right: auto; margin-bottom: 0.5cm;margin-top: 0.5cm} ",e+="#header2 { color: black; font-family: arial; font-size: 16px; font-weight: bold;text-align: left; margin-left: 1cm; margin-right: 1cm; margin-top: 0.5cm} ",e+="#header3 { color: black; font-family: arial; font-size: 13px;  text-align: left;margin-left: 0; margin-right: 0; margin-top: 0.5cm; margin-bottom: 0.25cm;font-style: italic} ",e+="#txt { color: black; font-family: arial; font-size: 12px; text-align: left;margin-left: 1cm; margin-right: 1cm} ",e+="#ctr { color: black; font-family: arial; font-size: 12px; text-align: center; margin-left: auto; margin-right: auto} ",e+="ul, ol{ display: block; list-style-type: decimal; list-style-type: disc;  margin-top: 1em; margin-bottom: 1em; margin-left: 1cm; margin-right: 1cm;padding-left: 0.3cm;}",e+="li { color: black; font-family: arial; font-size: 12px; text-align: left;} ",e+="#tab1 { width:60%; border-spacing: 5px; padding: 15px;border-collapse: collapse; margin-left:auto; margin-right:auto; text-align: center} ",e+="th { font-weight: bold; text-size: 12px; font-family: arial;border-bottom: 1px solid gray} ",e+="tr, td { text-size: 12px; font-family: arial} ",e+="td:first-child, th:first-child { text-size: 12px; border-right: 1px solid gray} ",e+="#page-break { display: block; page-break-before: always; padding-bottom: 2cm} ",e+="#foot { position: fixed; left: 0; bottom: 0; width: auto; color: lightgray; text-align: center; margin-bottom: 0.7cm; margin-left: 0.7cm; margin-right: 0.7cm; font-size: 10px; border-top: 1px solid lightgray} ",e+="</style>",this.style=e}getHeader(e){let t="";switch(t+=`<div id="header1">${this.imp.$t("gti")}</div>`,this.imp.selectedFormat[2]){case"add":if(0===e.sign)t+=`<ctr>${this.imp.$t("example")} ${this.imp.$t("approach")}: ${this.imp.$t("addition")} \\( ${this.imp.inputNums["0"]} + ${this.imp.inputNums["1"]} \\)</ctr>`;else{t+=`<ctr>${this.imp.$t("example")} ${this.imp.$t("approach")}: ${this.imp.$t("addition")} \\( ${this.imp.inputNums["0"]} + ${this.imp.inputNums["1"]} \\Rightarrow \\)`;const e=-1*this.imp.inputNums["1"];t+=` ${this.imp.$t("subtraction")} \\( ${this.imp.inputNums["0"]} - ${e} \\)</ctr>`}break;case"mul":t+=`<ctr>${this.imp.$t("example")} ${this.imp.$t("approach")}: ${this.imp.$t("multiplication")} \\( ${this.imp.inputNums["0"]} * ${this.imp.inputNums["1"]} \\)</ctr>`;break;case"sub":if(0===e.sign)t+=`<ctr>${this.imp.$t("example")} ${this.imp.$t("approach")}: ${this.imp.$t("subtraction")} \\( ${this.imp.inputNums["0"]} - ${this.imp.inputNums["1"]} \\)</ctr>`;else{t+=`<ctr>${this.imp.$t("example")} ${this.imp.$t("approach")}: ${this.imp.$t("subtraction")} \\( ${this.imp.inputNums["0"]} - ${this.imp.inputNums["1"]} \\Rightarrow \\)`;const e=-1*this.imp.inputNums["1"];t+=` ${this.imp.$t("addition")} \\( ${this.imp.inputNums["0"]} + ${e} \\)</ctr>`}break;case"div":t+=`<ctr>${this.imp.$t("example")} ${this.imp.$t("approach")}: ${this.imp.$t("division")} \\( ${this.imp.inputNums["0"]} : ${this.imp.inputNums["1"]} \\)</ctr>`;break;default:}this.header=t}getDisclaimer(){let e="";e+=`<div id="foot">${this.imp.$t("disclaimer")}</div>`,this.disclaimer=e}getValues(e,t){let i=e.mantissaBits.join("");i=`1,${i.substring(1)}`;let n=t.mantissaBits.join("");n=`1,${n.substring(1)}`;const s=e.exponentBits.join(""),a=t.exponentBits.join("");let o="";switch(o+=`<div id="header2">${this.imp.$t("values")}</div>`,o+='<table id="tab1">',o+="<tr>",o+="<th></th>",this.imp.selectedFormat[2]){case"add":o+=`<th>${this.imp.$t("firstSummand")}</th>`,o+=`<th>${this.imp.$t("secondSummand")}</th>`;break;case"mul":o+=`<th>${this.imp.$t("firstFactor")}</th>`,o+=`<th>${this.imp.$t("secondFactor")}</th>`;break;case"sub":o+=`<th>${this.imp.$t("minuend")}</th>`,o+=`<th>${this.imp.$t("subtrahend")}</th>`;break;case"div":o+=`<th>${this.imp.$t("numerator")}</th>`,o+=`<th>${this.imp.$t("denominator")}</th>`;break;default:}o+="</tr>",o+="<tr>",o+=`<td>${this.imp.$t("values")}</td>`,o+=`<td>${e.valueString}</td>`,o+=`<td>${t.valueString}</td>`,o+="</tr>",o+="<tr>",o+=`<td>${this.imp.$t("sign")}</td>`,o+=`<td>${0===e.sign?"+":"-"}</td>`,o+=`<td>${0===t.sign?"+":"-"}</td>`,o+="</tr>",o+="<tr>",o+=`<td>${this.imp.$t("mantissa")}</td>`,o+=`<td>${i}</td>`,o+=`<td>${n}</td>`,o+="</tr>",o+="<tr>",o+=`<td>${this.imp.$t("exponent")}</td>`,o+=`<td>${s}</td>`,o+=`<td>${a}</td>`,o+="</tr>",o+="</table>",this.values=o}additionString(e,t,i,n=!1){const s=t.exponentBits.join(""),a=i.exponentBits.join(""),o=this.imp.watcher;let r=0,l="<style scoped>#scoped-content { width:100%; justify-content: center; }</style>";if(l+='<div id="scoped-content">',l+=this.style,l+=this.header,l+=this.values,t.isZero||i.isZero)l+=`<div id="header2">${this.imp.$t("step")} 1 </div> <br>`,l+="<ul>",l+=`<div id="txt">${this.imp.$t("addWithZero")}</div>`,l+="</ul>",l+=`<div id="header2">${this.imp.$t("step")} 2 </div>`;else{if(n&&(r+=1,l+=`<div id="header2">${this.imp.$t("step")} ${r} </div> <br>`,l+=`<div id="txt">${this.imp.$t("negativeMinuendSubtrahend")} </div>`),r+=1,l+=`<div id="header2">${this.imp.$t("step")} ${r} </div> <br>`,l+=`<div id="txt">${this.imp.$t("adjustExponents")} `,0===o.steps.CalculateDeltaE.data.deltaE)l+=`\\( (${s} = ${a} \\Rightarrow i.O.) \\)`,l+="</div>";else{const e=o.steps.CalculateDeltaE.data.switched?"<":">";l+=`\\( (${s} \\neq ${a}) \\)`,l+="</div>",l+="<ul>",l+=`<li><div id="header3">${this.imp.$t("diffExponent")} :</div>`,l+=[`${this.imp.$t("smallerExponent")} `,`\\( ( [ ${o.steps.CalculateDeltaE.data.expN1Bits.join("")} ] :=  ${o.steps.CalculateDeltaE.data.expN1} ${e}\n                [ ${o.steps.CalculateDeltaE.data.expN2Bits.join("")} ] :=  ${o.steps.CalculateDeltaE.data.expN2}) \\) <br>`,`${this.imp.$t("resDiffExponent")}: `,"\\(",this.imp.watcher.steps.CalculateDeltaE.data.deltaE,"\\)</li>"].join(""),l+=`<li><div id="header3">${this.imp.$t("adjustSmallerMantissa")} :</div>`,l+=[`${this.imp.$t("shiftMantissa")}: \\( `,o.steps.CalculateDeltaE.data.preShift.join(""),`\\overset{\\text{Shift: ${o.steps.CalculateDeltaE.data.deltaE} }}{\\rightarrow}`,o.steps.AddMantissa.data.mantissa2.join(""),"\\)","</li></ul>"].join("")}r+=1,l+=`<div id="header2">${this.imp.$t("step")} ${r} </div>`,l+="<ul>",l+=`<li><div id="header3">${this.imp.$t("addition")} ${this.imp.$t("mantissa")} :</div></li>`,l+='<div id="ctr">\\(',this.description.getAdditionTable(),l+=this.description.table,l+="\\)</div>",l+=`<li><div id="header3">${this.imp.$t("considerRepresentation")} :</div>`,l+=[`${this.imp.$t("consider1comma")}<br>`,`${this.imp.$t("mantissa1float")} \\( `,`${o.steps.AddMantissa.data.normalizedMantissa.join("")}`,"\\)","</li></ul>"].join(""),l+="</div>",r+=1,l+=`<div id="header2">${this.imp.$t("step")} ${r} </div>`}l+="<ul>",l+=`<li><div id="header3">${this.imp.$t("solution")} :</div>`;const c=new Qe(this.exponentBits,this.numBits);c.ieeeToDec([o.steps.Result.data.result.sign," ",o.steps.Result.data.result.exponentBits.join(""),o.steps.Result.data.result.mantissaBits.join("").substring(1)].join(""));const u=c.result;l+=[`${this.imp.$t("correctSolution")}: \\(`,o.steps.Result.data.result.sign,"\\,",o.steps.Result.data.result.exponentBits.join(""),"\\,",o.steps.Result.data.result.mantissaBits.join("").substring(1),"\\,",`\\Rightarrow ${u} \\)`,"</li>"].join(""),l+=`<li><div id="header3">${this.imp.$t("composition")} :</div></li>`,l+="</ul>",l+='<table id="tab1">',l+="<tr>",l+="<th></th>",l+=`<th>${this.imp.$t("values")}</th>`,l+="</tr>",l+="<tr>",l+=`<td>${this.imp.$t("sign")}</td>`,l+=`<td>${o.steps.Result.data.result.sign}</td>`,l+="</tr>",l+="<tr>",l+=`<td>${this.imp.$t("exponent")}</td>`,l+=`<td>${o.steps.Result.data.result.exponentBits.join("")}</td>`,l+="</tr>",l+="<tr>",l+=`<td>${this.imp.$t("mantissa")}</td>`,l+=`<td>${o.steps.Result.data.result.mantissaBits.join("")}</td>`,l+="</tr>",l+="</table>",l+=this.disclaimer,this.string=l}subtractionString(e,t,i){const n=t.exponentBits.join(""),s=i.exponentBits.join(""),a=this.imp.watcher.steps.Addition.data.addition;let o=0,r="<style scoped>#scoped-content { width:100%; justify-content: center; }</style>";if(r+='<div id="scoped-content">',r+=this.style,r+=this.header,r+=this.values,t.isZero||i.isZero)o+=1,r+=`<div id="header2">${this.imp.$t("step")} ${o} </div> <br>`,r+="<ul>",r+=`<div id="txt">${this.imp.$t("subWithZero")}</div>`,r+="</ul>",o+=1,r+=`<div id="header2">${this.imp.$t("step")} ${o} </div>`;else{if(o+=1,r+=`<div id="header2">${this.imp.$t("step")} ${o} </div> <br>`,r+=`<div id="txt">${this.imp.$t("adjustExponents")} `,0===a.steps.CalculateDeltaE.data.deltaE)r+=`\\( (${n} = ${s} \\Rightarrow i.O.) \\)`,r+="</div>";else{const e=a.steps.CalculateDeltaE.data.switched?"<":">";r+=`\\( (${n} \\neq ${s}) \\)`,r+="</div>",r+="<ul>",r+=`<li><div id="header3">${this.imp.$t("diffExponent")} :</div>`,r+=[`${this.imp.$t("smallerExponent")} `,`\\( ( [ ${a.steps.CalculateDeltaE.data.expN1Bits.join("")} ] :=  ${a.steps.CalculateDeltaE.data.expN1} ${e}\n                [ ${a.steps.CalculateDeltaE.data.expN2Bits.join("")} ] :=  ${a.steps.CalculateDeltaE.data.expN2}) \\) <br>`,`${this.imp.$t("resDiffExponent")}: `,"\\(",a.steps.CalculateDeltaE.data.deltaE,"\\)</li>"].join(""),r+=`<li><div id="header3">${this.imp.$t("adjustSmallerMantissa")} :</div>`,r+=[`${this.imp.$t("shiftMantissa")}: \\( `,a.steps.CalculateDeltaE.data.preShift.join(""),`\\overset{\\text{Shift: ${a.steps.CalculateDeltaE.data.deltaE} }}{\\rightarrow}`,a.steps.AddMantissa.data.mantissa2.join(""),"\\)","</li></ul>"].join("")}a.steps.AddMantissa.data.equalMantissa?(o+=1,r+=`<div id="header2">${this.imp.$t("step")} ${o} </div>`,r+="<ul>",r+=`<li><div id="header3">${this.imp.$t("subtraction")} ${this.imp.$t("mantissa")} :</div></li>`,r+=`<li><div id="header3">${this.imp.$t("newMantissa")} :</div>`,r+=[`${this.imp.$t("zeroMantissa")} \\( `,`${a.steps.AddMantissa.data.normalizedMantissa.join("")}`,"\\)","</li>"].join(""),r+=`<li><div id="header3">${this.imp.$t("considerRepresentation")} :</div>`,r+=[`${this.imp.$t("consider1comma")}<br>`,`${this.imp.$t("mantissa1float")} \\( `,`${a.steps.AddMantissa.data.normalizedMantissa.join("")}`,"\\)","</li></ul>"].join("")):(a.steps.AddMantissa.data.complement1.steps.Complement.data.negate&&(o+=1,r+=`<div id="header2">${this.imp.$t("step")} ${o} </div>`,r+="<ul>",r+=`<div id="txt">${this.imp.$t("subtTwosComplement")} `,r+=[`<div id="header3">${this.imp.$t("considerRepresentation")} \\(`,a.steps.AddMantissa.data.mantissa1.join(""),"\\)</div>"].join(""),r+=`<li><div id="header3">${this.imp.$t("switchBits")} :</div></li>`,r+=["\\(",a.steps.AddMantissa.data.mantissa1.join(""),"\\rightarrow",a.steps.AddMantissa.data.complement1.steps.Complement.data.flippedArray.join(""),"\\) </li>"].join(""),r+=`<li><div id="header3">${this.imp.$t("add1")} :</div></li>`,r+=["\\(",a.steps.AddMantissa.data.complement1.steps.Complement.data.flippedArray.join(""),"\\rightarrow",a.steps.AddMantissa.data.complement1.steps.Complement.data.oneAdded.join(""),"\\) </li>"].join(""),r+=`<li><div id="header3">${this.imp.$t("normalize")} :</div></li>`,r+=["\\(",a.steps.AddMantissa.data.complement1.steps.Complement.data.oneAdded.join(""),"\\rightarrow",a.steps.AddMantissa.data.complement1.steps.Complement.data.normalizedArray.join(""),"\\) </li>"].join("")),a.steps.AddMantissa.data.complement2.steps.Complement.data.negate&&(o+=1,r+=`<div id="header2">${this.imp.$t("step")} ${o} </div>`,r+="<ul>",r+=`<div id="txt">${this.imp.$t("subtTwosComplement")} `,r+=[`<div id="header3">${this.imp.$t("considerRepresentation")} \\(`,a.steps.AddMantissa.data.mantissa2.join(""),"\\)</div>"].join(""),r+=`<li><div id="header3">${this.imp.$t("switchBits")} :</div></li>`,r+=["\\(",a.steps.AddMantissa.data.mantissa2.join(""),"\\rightarrow",a.steps.AddMantissa.data.complement2.steps.Complement.data.flippedArray.join(""),"\\) </li>"].join(""),r+=`<li><div id="header3">${this.imp.$t("add1")} :</div></li>`,r+=["\\(",a.steps.AddMantissa.data.complement2.steps.Complement.data.flippedArray.join(""),"\\rightarrow",a.steps.AddMantissa.data.complement2.steps.Complement.data.oneAdded.join(""),"\\) </li>"].join(""),r+=`<li><div id="header3">${this.imp.$t("normalize")} :</div></li>`,r+=["\\(",a.steps.AddMantissa.data.complement2.steps.Complement.data.oneAdded.join(""),"\\rightarrow",a.steps.AddMantissa.data.complement2.steps.Complement.data.normalizedArray.join(""),"\\) </li>"].join("")),r+="</ul>",r+="</ul>",r+="</div>",o+=1,r+=`<div id="header2">${this.imp.$t("step")} ${o} </div>`,r+="<ul>",r+=`<li><div id="header3">${this.imp.$t("subtraction")} ${this.imp.$t("mantissa")} :</div></li>`,r+='<div id="ctr">\\(',this.description.getSubtractionTable(),r+=this.description.table,r+="\\)</div>",r+=`<li><div id="header3">${this.imp.$t("considerRepresentation")} :</div>`,r+=[`${this.imp.$t("consider1comma")}<br>`,`${this.imp.$t("mantissa1float")} \\( `,`${a.steps.AddMantissa.data.normalizedMantissa.join("")}`,"\\)","</li></ul>"].join(""),r+="</div>")}o+=1,4===o&&(r+='<div id="page-break"></div>'),r+=`<div id="header2">${this.imp.$t("step")} ${o} </div>`,r+="<ul>",r+=`<li><div id="header3">${this.imp.$t("solution")} :</div>`;const l=new Qe(this.exponentBits,this.numBits);l.ieeeToDec([a.steps.Result.data.result.sign," ",a.steps.Result.data.result.exponentBits.join(""),a.steps.Result.data.result.mantissaBits.join("").substring(1)].join(""));const c=l.result;r+=[`${this.imp.$t("correctSolution")}: \\(`,a.steps.Result.data.result.sign,"\\,",a.steps.Result.data.result.exponentBits.join(""),"\\,",a.steps.Result.data.result.mantissaBits.join("").substring(1),"\\,",`\\Rightarrow ${c} \\)`,"</li>"].join(""),r+=`<li><div id="header3">${this.imp.$t("composition")} :</div></li>`,r+="</ul>",r+='<table id="tab1">',r+="<tr>",r+="<th></th>",r+=`<th>${this.imp.$t("values")}</th>`,r+="</tr>",r+="<tr>",r+=`<td>${this.imp.$t("sign")}</td>`,r+=`<td>${a.steps.Result.data.result.sign}</td>`,r+="</tr>",r+="<tr>",r+=`<td>${this.imp.$t("exponent")}</td>`,r+=`<td>${a.steps.Result.data.result.exponentBits.join("")}</td>`,r+="</tr>",r+="<tr>",r+=`<td>${this.imp.$t("mantissa")}</td>`,r+=`<td>${a.steps.Result.data.result.mantissaBits.join("")}</td>`,r+="</tr>",r+="</table>",r+=this.disclaimer,this.string=r}multiplicationString(e,t,i){const n=this.imp.watcher;let s="<style scoped>#scoped-content { width:100%; justify-content: center; }</style>";if(s+='<div id="scoped-content">',s+=this.style,s+=this.header,s+=this.values,t.isZero||i.isZero)s+=`<div id="header2">${this.imp.$t("step")} 1 </div> <br>`,s+="<ul>",s+=`<div id="txt">${this.imp.$t("mulWithZero")}</div>`,s+="</ul>",s+=`<div id="header2">${this.imp.$t("step")} 2 </div>`;else{s+=`<div id="header2">${this.imp.$t("step")} 1 </div> <br>`,s+="<ul>",s+=`<div id="txt">${this.imp.$t("adjustExponents")} `;const a=new Qe(this.exponentBits,this.numBits);a.binToDec(t.exponentBits.join(""));const o=a.result;a.binToDec(i.exponentBits.join(""));const r=a.result;s+=[`${this.imp.$t("addExponents")}. (${this.imp.$t("newExponent")}: `,o+r,")"].join(""),s+="</ul>",s+=`<div id="header2">${this.imp.$t("step")} 2 </div>`,s+="<ul>",s+=`<li><div id="header3">${this.imp.$t("multiplication")} ${this.imp.$t("mantissa")} :</div></li>`,s+='<div id="ctr">\\(',this.description.getMultiplicationTable(),s+=this.description.table,s+="\\)</div>",s+=`<li><div id="header3">${this.imp.$t("considerRepresentation")} :</div>`,s+=[`${this.imp.$t("consider1comma")}<br>`,`${this.imp.$t("mantissa1float")}: \\( `,`${e.mantissaBits.join("").substring(1)}`,"\\)","</li></ul>"].join(""),s+="</div>";const l=n.steps.Multiplication.data.multiplication.steps.MultiplicationSteps.data.countSteps;l>17&&(s+='<div id="page-break"></div>'),s+=`<div id="header2">${this.imp.$t("step")} 3 </div>`}s+="<ul>",s+=`<li><div id="header3">${this.imp.$t("solution")} :</div>`;const a=new Qe(this.exponentBits,this.numBits);a.ieeeToDec([n.steps.Result.data.result.sign," ",n.steps.Result.data.result.exponentBits.join(""),n.steps.Result.data.result.mantissaBits.join("").substring(1)].join(""));const o=a.result;s+=[`${this.imp.$t("correctSolution")}: \\(`,n.steps.Result.data.result.sign,"\\,",n.steps.Result.data.result.exponentBits.join(""),"\\,",n.steps.Result.data.result.mantissaBits.join("").substring(1),"\\,",`\\Rightarrow ${o} \\)`,"</li>"].join(""),s+=`<li><div id="header3">${this.imp.$t("composition")} :</div></li>`,s+="</ul>",s+='<table id="tab1">',s+="<tr>",s+="<th></th>",s+=`<th>${this.imp.$t("values")}</th>`,s+="</tr>",s+="<tr>",s+=`<td>${this.imp.$t("sign")}</td>`,s+=`<td>${n.steps.Result.data.result.sign}</td>`,s+="</tr>",s+="<tr>",s+=`<td>${this.imp.$t("exponent")}</td>`,s+=`<td>${n.steps.Result.data.result.exponentBits.join("")}</td>`,s+="</tr>",s+="<tr>",s+=`<td>${this.imp.$t("mantissa")}</td>`,s+=`<td>${n.steps.Result.data.result.mantissaBits.join("")}</td>`,s+="</tr>",s+="</table>",s+=this.disclaimer,this.string=s}divisionString(e,t,i){const n=this.imp.watcher;let s="<style scoped>#scoped-content { width:100%; justify-content: center; }</style>";if(s+='<div id="scoped-content">',s+=this.style,s+=this.header,s+=this.values,t.isZero)s+=`<div id="header2">${this.imp.$t("step")} 1 </div> <br>`,s+="<ul>",s+=`<div id="txt">${this.imp.$t("divWithZero")}</div>`,s+="</ul>",s+=`<div id="header2">${this.imp.$t("step")} 2 </div>`;else{s+=`<div id="header2">${this.imp.$t("step")} 1 </div> <br>`,s+="<ul>",s+=`<div id="txt">${this.imp.$t("adjustExponents")} `;const a=new Qe(this.exponentBits,this.numBits);a.binToDec(t.exponentBits.join(""));const o=a.result;a.binToDec(i.exponentBits.join(""));const r=a.result;s+=[`${this.imp.$t("subtExponents")}. (${this.imp.$t("newExponent")}: `,o-r,")"].join(""),s+="</ul>";const l=n.steps.Division.data.division.steps.DivisionSteps.data.countSteps;l>14&&(s+='<div id="page-break"></div>'),s+=`<div id="header2">${this.imp.$t("step")} 2 </div>`,s+="<ul>",s+=`<li><div id="header3">${this.imp.$t("division")} ${this.imp.$t("mantissa")} :</div></li>`,s+='<div id="ctr">\\(',this.description.getDivisionTable(),s+=this.description.table,s+="\\)</div>",s+=`<li><div id="header3">${this.imp.$t("considerRepresentation")} :</div>`,s+=[`${this.imp.$t("consider1comma")}<br>`,`${this.imp.$t("mantissa1float")}: \\( `,`${e.mantissaBits.join("").substring(1)}`,"\\)","</li></ul>"].join(""),s+="</div>",l<=14&&l>6&&(s+='<div id="page-break"></div>'),s+=`<div id="header2">${this.imp.$t("step")} 3 </div>`}s+="<ul>",s+=`<li><div id="header3">${this.imp.$t("solution")} :</div>`;const a=new Qe(this.exponentBits,this.numBits);a.ieeeToDec([n.steps.Result.data.result.sign," ",n.steps.Result.data.result.exponentBits.join(""),n.steps.Result.data.result.mantissaBits.join("").substring(1)].join(""));const o=a.result;s+=[`${this.imp.$t("correctSolution")}: \\(`,n.steps.Result.data.result.sign,"\\,",n.steps.Result.data.result.exponentBits.join(""),"\\,",n.steps.Result.data.result.mantissaBits.join("").substring(1),"\\,",`\\Rightarrow ${o} \\)`,"</li>"].join(""),s+=`<li><div id="header3">${this.imp.$t("composition")} :</div></li>`,s+="</ul>",s+='<table id="tab1">',s+="<tr>",s+="<th></th>",s+=`<th>${this.imp.$t("values")}</th>`,s+="</tr>",s+="<tr>",s+=`<td>${this.imp.$t("sign")}</td>`,s+=`<td>${n.steps.Result.data.result.sign}</td>`,s+="</tr>",s+="<tr>",s+=`<td>${this.imp.$t("exponent")}</td>`,s+=`<td>${n.steps.Result.data.result.exponentBits.join("")}</td>`,s+="</tr>",s+="<tr>",s+=`<td>${this.imp.$t("mantissa")}</td>`,s+=`<td>${n.steps.Result.data.result.mantissaBits.join("")}</td>`,s+="</tr>",s+="</table>",s+=this.disclaimer,this.string=s}generatePdf(e,t,i,n,s="decimal",a="decimal",o="FloatingPointTabs"){let r=e,l=t;if("decimal"===s){const e=new Qe(this.exponentBits,this.numBits);e.decToBin(r),e.binToIEEE(e.result),r=e.result}else if("binary"===s){const e=new Qe(this.exponentBits,this.numBits);e.binToIEEE(r),r=e.result}if("decimal"===a){const e=new Qe(this.exponentBits,this.numBits);e.decToBin(l),e.binToIEEE(e.result),l=e.result}else if("binary"===a){const e=new Qe(this.exponentBits,this.numBits);e.binToIEEE(l),r=e.result}const c=nt(this.exponentBits,i),u=nt(this.exponentBits,r),h=nt(this.exponentBits,l);switch(this.getStyle(),this.getHeader(h),this.getDisclaimer(),this.getValues(u,h),this.description.makeDescriptionArithmetic(r,l,i,n),n){case"add":0===u.sign&&0===h.sign?this.additionString(c,u,h):1===h.sign?(h.sign=0,h.arr[0]=0,this.subtractionString(c,u,h)):this.subtractionString(c,u,h);break;case"mul":this.multiplicationString(c,u,h);break;case"sub":0===h.sign?1===u.sign?(this.negativeMinuendSubtrahend=!0,u.sign=0,u.arr[0]=0,h.sign=0,h.arr[0]=0,this.additionString(c,u,h,!0)):this.subtractionString(c,u,h):1===u.sign&&1===h.sign?this.subtractionString(c,u,h):(h.sign=0,h.arr[0]=0,this.additionString(c,u,h));break;case"div":this.divisionString(c,u,h);break;default:}const d=this.string,m=ou.resolve({name:o});ou.replace({name:"DescriptionPDF",params:{math:d,returnRoute:m.href}})}}class ut{constructor(e){this.name=e,this.data={}}addDataPoint(e,t){this.data[e]=t}}class ht{constructor(){this.steps={}}step(e){const t=this.steps[e];return t||(this.steps[e]=new ut(e)),this.curr=this.steps[e],this}saveVariable(e,t){return this.curr.addDataPoint(e,t),this}}function dt(e){return e>=0&&e<=9?String.fromCharCode(e+"0".charCodeAt()):e>=10&&e<=35?String.fromCharCode(e+"A".charCodeAt()):""}class mt{constructor(e,t,i,n=0,s=!1){if(e<2||e>36)throw new Error(`NumberBaseNComplement.constructor(base, digitNum, ...): Base ${e} is not supported.`);if(t<=0)throw new Error("NumberBaseNComplement.constructor(base, digitNum, ...): digitNum must be positive.");if(this.base=e,this.offset=n,this.digitNum=t,this.stringRepresentation=null,this.stringRepresentationNoLeadingZeros=null,this.watcher=new ht,!this._checkArray(i))throw new Error("NumberBaseNComplement.constructor(base, digitNum, ...): representation contains invalid number.");if(this.arr=[...i],this._normalizeOffset(),this._normalizeArray(),this.watcher=this.watcher.step("Complement").saveVariable("originalArray",[...this.arr]),this.watcher=this.watcher.step("Complement").saveVariable("negate",s),s){this.arr=this.getFlipedArray(),this.watcher=this.watcher.step("Complement").saveVariable("flippedArray",[...this.arr]);for(let e=this.arr.length-1;e>=0;e-=1){if(this.arr[e]!==this.base-1){this.arr[e]+=1;break}this.arr[e]=0}this.watcher=this.watcher.step("Complement").saveVariable("oneAdded",[...this.arr]),this._normalizeOffset(),this._normalizeArray(),this.watcher=this.watcher.step("Complement").saveVariable("normalizedArray",[...this.arr])}else this.watcher=this.watcher.step("Complement").saveVariable("flippedArray",[...this.arr]).saveVariable("oneAdded",[...this.arr]).saveVariable("normalizedArray",[...this.arr]);while(this.arr.length>t)this.arr.pop();this.negative=s,this.signBit=s?1:0,this.stringRepresentation=this._constructString(this.arr)}_normalizeOffset(){while(this.offset<0)this.arr.push(0),this.offset+=1}_normalizeArray(){while(this.offset>0&&0===this.arr[this.arr.length-1])this.arr.splice(this.arr.length-1,1),this.offset-=1;this.arr.length>this.digitNum+this.offset?this.arr.splice(this.digitNum+this.offset,this.arr.length-(this.digitNum+this.offset)):this.arr.push(...Array(this.digitNum+this.offset-this.arr.length).fill(0))}_checkArray(e){for(let t=0;t<e.length;t+=1)if(e[t]<0||this.base<=e[t])return!1;return!0}_constructString(e){let t="";for(let i=0;i<e.length;i+=1)t+=dt(e[i]),i===this.digitNum-1&&this.offset>0&&(t+=".");return t}getFlipedArray(){const e=[];for(let t=0;t<this.arr.length;t+=1)e.push(this.base-1-this.arr[t]);return e}isNegative(){return this.arr[0]>=Math.ceil(this.base/2)}translate(e){if(e<=0)throw new Error("NumberBaseNComplement.translate(newDigitNum): newDigitNum must be positive.");if(e<=this.digitNum){const t=[...this.arr].splice(0,this.digitNum-e);return new mt(this.base,e,t,this.offset)}const t=this.isNegative()?this.base-1:0,i=[...this.arr];return i.unshift(...Array(e-this.digitNum).fill(t)),new mt(this.base,e,i,this.offset)}}class pt{constructor(e,t){if(e.base!==t.base)throw new Error(`AdditionBaseNComplement.constructor(n1, n2): Base of n1(${e.base}) and base of n2(${t.base}) must be qual.`);if(e.digitNum!==t.digitNum)throw new Error(`AdditionBaseNComplement.constructor(n1, n2): DigitNum of n1(${e.digitNum}) and digitNum of n2(${t.digitNum}) must be qual.`);this.producedOverflow=!1,this.carryOutSet=!1,this.watcher=null,this.result=this._add(e,t)}_add(e,t){this.watcher=new ht;const i=e.base,n=[...e.arr],s=[...t.arr],a=[],o=[];a.unshift(0);for(let u=n.length-1;u>=0;u-=1){const e=n[u]+s[u]+a[0];o.unshift(e%i),a.unshift(Math.floor(e/i))}this.producedOverflow=a[0]!==a[1];const r=1===e.signBit&&1===t.signBit||!(0===e.signBit&&0===t.signBit)&&1===o[0]&&!this.producedOverflow;if(r)while(o.length>e.digitNum)o.shift();let l=e.digitNum;e.signBit===t.signBit&&a.length>l&&(l+=1,o.unshift(a[0])),this.negativeResult=r;const c=new mt(i,l,o,0,!1);return this.watcher.step("Addition").saveVariable("op1",e).saveVariable("op2",t).saveVariable("op1Arr",[...n]).saveVariable("op2Arr",[...s]).saveVariable("carryArr",[...a]).saveVariable("resultArr",[...o]).saveVariable("result",c).saveVariable("overflow",this.producedOverflow),c}getResult(){return this.result}}class ft{constructor(e,t){if(e.expBitNum!==t.expBitNum)throw new Error(`AdditionIEEE: expBitNum of n1(${e.expBitNum}) and n2(${t.expBitNum}) not compatible.`);if(e.manBitNum!==t.manBitNum)throw new Error(`AdditionIEEE: manBitNum of n1(${e.manBitNum}) and n2(${t.manBitNum}) not compatible.`);this.producedOverflow=!1,this.watcher=null,this.result=this._add(e,t)}_add(e,t){this.watcher=new ht,this.watcher=this.watcher.step("Edgecases");const i=e.expBitNum,n=e.manBitNum;console.log(e),console.log(t);const s=e.bitNum;if(e.isZero){const e=new it(i,n,[...t.arr]);return this.watcher=this.watcher.step("ResultEdgecase").saveVariable("edgecase","n2zero"),this.watcher=this.watcher.step("Result").saveVariable("result",e),e}if(t.isZero){const t=new it(i,n,[...e.arr]);return this.watcher=this.watcher.step("ResultEdgecase").saveVariable("edgecase","none"),this.watcher=this.watcher.step("Result").saveVariable("result",t),t}if(e.isNaN||t.isNaN||e.isInfinity&&t.isInfinity&&e.sign!==t.sign){const e=new it(i,n,Array(s).fill(1));return this.watcher=this.watcher.step("ResultEdgecase").saveVariable("edgecase","nan"),this.watcher=this.watcher.step("Result").saveVariable("result",e),e}if(e.isInfinity||t.isInfinity){const s=e.isInfinity?e.sign:t.sign,a=[s];a.push(...Array(i).fill(1)),a.push(...Array(n).fill(0));const o=new it(i,n,a);return this.watcher=this.watcher.step("ResultEdgecase").saveVariable("edgecase","inf"),this.watcher=this.watcher.step("Result").saveVariable("result",o),o}let a,o,r,l,c,u,h;e.exponent>=t.exponent?(a=e.exponent,o=t.exponent,r=[...e.mantissaBits],l=[...t.mantissaBits],c=e.sign,u=t.sign):(h=!0,a=t.exponent,o=e.exponent,r=[...t.mantissaBits],l=[...e.mantissaBits],c=t.sign,u=e.sign);const d=this._getDeltaExponent(a,o);if(this.watcher=this.watcher.step("CalculateDeltaE").saveVariable("switched",h).saveVariable("expN1",e.exponent).saveVariable("expN2",t.exponent).saveVariable("expN1Bits",[...e.exponentBits]).saveVariable("expN2Bits",[...t.exponentBits]).saveVariable("deltaE",d).saveVariable("preShift",[...l]),d>0)for(let _=0;_<Math.abs(d);_+=1)l.unshift(0),l.pop();const m=this._addMantissa(r,l,c,u,l.length,d,e.isDenormalized||t.isDenormalized),p=m.sign?1:0,f=m.normalizedMantissa,g=m.shift;if(m.isZero||g===f.length-1&&0===f[0]){const e=new it(i,n,Array(s).fill(0));return this.watcher=this.watcher.step("ResultEdgecase").saveVariable("edgecase","zero"),this.watcher=this.watcher.step("Result").saveVariable("result",e),e}let b=a+e.bias+g;if(b<=0){f.unshift(1),f.pop();for(let e=0;e<Math.abs(b);e+=1)f.unshift(0),f.pop();b=0}const v=this._getExponentBits(i,b);if(this.watcher=this.watcher.step("Normalize").saveVariable("normalizedMantissa",[...f]).saveVariable("shift",g).saveVariable("n1ExpBits",[...e.exponentBits]).saveVariable("finalExpBits",[...v]),b>=2**i-1){const e=[p];e.push(...Array(i).fill(1)),e.push(...Array(n).fill(0));const t=new it(i,n,e);return this.watcher=this.watcher.step("ResultEdgecase").saveVariable("edgecase","inf"),this.watcher=this.watcher.step("Result").saveVariable("result",t),t}this.watcher=this.watcher.step("ResultEdgecase").saveVariable("edgecase","none");const w=[p];w.push(...v),w.push(...f),console.log(i,n,w);const x=new it(i,n,w);return console.log(x),this.watcher=this.watcher.step("Result").saveVariable("result",x),x}_getDeltaExponent(e,t){return e-t}_addMantissa(e,t,i,n,s,a,o){this.watcher=this.watcher.step("AddMantissa").saveVariable("mantissa1",e).saveVariable("mantissa2",t).saveVariable("sign1",i).saveVariable("sign2",n).saveVariable("binNum",s);const r=!o&&e.length===t.length&&e.every(((e,i)=>e===t[i]));if(this.watcher=this.watcher.step("AddMantissa").saveVariable("equalMantissa",r),r&&i===n){const t=[...e];t.shift(),t.push(0);const n=1,s=i;return this.watcher=this.watcher.step("AddMantissa").saveVariable("addition","none").saveVariable("shift",0).saveVariable("sign",s).saveVariable("unnormalizedMantissa",[...e]).saveVariable("normalizedMantissa",[...t]),{sign:s,normalizedMantissa:t,shift:n}}if(r&&i!==n){const t=[];for(let i=0;i<e.length;i+=1)t.push(0);const n=0,s=i;return this.watcher=this.watcher.step("AddMantissa").saveVariable("addition","none").saveVariable("shift",0).saveVariable("sign",s).saveVariable("unnormalizedMantissa",[...t]).saveVariable("normalizedMantissa",[...t]),{sign:s,normalizedMantissa:t,shift:n,isZero:!0}}let l,c;if(a>0){l=new mt(2,s,e,s,!1);const a=i!==n&&!t.every((e=>0===e));c=new mt(2,s,t,s,a)}else l=new mt(2,s,e,s,1===i),c=new mt(2,s,t,s,1===n);this.watcher=this.watcher.step("AddMantissa").saveVariable("complement1",JSON.parse(JSON.stringify(l.watcher))),this.watcher=this.watcher.step("AddMantissa").saveVariable("complement2",JSON.parse(JSON.stringify(c.watcher))),console.log(l,c);const u=new pt(l,c);this.watcher=this.watcher.step("AddMantissa").saveVariable("addition",JSON.parse(JSON.stringify(u.watcher)));let h=u.getResult(),d=1===i;0===a&&(h=new mt(2,h.arr.length,[...h.arr],s,u.negativeResult),d=u.negativeResult);const m=[...h.arr];this.watcher=this.watcher.step("AddMantissa").saveVariable("unnormalizedMantissa",[...m]);let p=0;if(m.length>e.length&&(p=m.length-e.length),u.carryOutSet)p=1;else while(Math.abs(p)<=m.length&&0===m[0])m.shift(),m.push(0),p-=1;if(p===-m.length){const e=[...m];return this.watcher=this.watcher.step("AddMantissa").saveVariable("shift",p).saveVariable("sign",d).saveVariable("unnormalizedMantissa",[...e]),{sign:d,normalizedMantissa:e,shift:p,isZero:!0}}m.shift(),m.push(0);const f=Je(m,e.length-1);return this.watcher=this.watcher.step("AddMantissa").saveVariable("shift",p).saveVariable("sign",d).saveVariable("normalizedMantissa",[...f]),{sign:d,normalizedMantissa:f,shift:p,isZero:!1}}_calculateShift(e,t){if(t>=1)return t-1;let i=0;for(let n=1;n<e.length;n+=1)if(i-=1,1===e[n])break;return i}_getNormalizedMantissa(e,t,i){const n=[];for(let s=0;s<e;s+=1){const e=s+Math.max(-i,0)+1,a=e<t.length?t[e]:0;n.push(a)}return n}_getExponentBits(e,t){let i=t;const n=[];for(let s=0;s<e;s+=1)n.unshift(i%2),i=Math.floor(i/2);return n}getResult(){return this.result}}class gt{constructor(e,t){e.expBitNum!==t.expBitNum&&console.log(`SubtractionIEEE(Number, Number): expBitNum of n1(${e.expBitNum}) and expBitNum of n2(${t.expBitNum}) not compatible.`),e.manBitNum!==t.manBitNum&&console.log(`SubtractionIEEE(Number, Number): manBitNum of n1(${e.manBitNum}) and manBitNum of n2(${t.manBitNum}) not compatible.`),this.producedOverflow=!1,this.result=this._subtract(e,t)}_subtract(e,t){this.watcher=new ht;const i=[...t.arr];i[0]=0===i[0]?1:0;const n=new it(e.expBitNum,e.manBitNum,e.arr),s=new it(t.expBitNum,t.manBitNum,i);this.watcher=this.watcher.step("Input").saveVariable("op1Sign",n.sign).saveVariable("op1Sign",n.exponentBits).saveVariable("op1Sign",n.mantissaBits).saveVariable("op1Sign",s.sign).saveVariable("op1Sign",s.exponentBits).saveVariable("op1Sign",s.mantissaBits);const a=new ft(n,s);return this.watcher=this.watcher.step("Addition").saveVariable("addition",a.watcher),a.getResult()}getResult(){return this.result}}function bt(e){return e>=0&&e<=9?String.fromCharCode(e+"0".charCodeAt()):e>=10&&e<=35?String.fromCharCode(e+"A".charCodeAt()):""}class vt{constructor(e,t,i=0,n=!1){if(e<2||e>36)throw new Error(`NumberBaseNSigned.constructor(base, representation, ...): Base ${e} is not supported.`);if(this.base=e,this.offset=i,this.isNegative=n,this.arr=null,this.stringRepresentation=null,!this._checkArray(t))throw new Error("NumberBaseNSigned.constructor(base, representation, ...): representation contains invalid number.");this.arr=[...t],this._normalizeOffset(),this._normalizeArray(),this.stringRepresentation=this._constructString(this.arr)}_normalizeOffset(){while(this.offset<0)this.arr.push(0),this.offset+=1}_normalizeArray(){while(this.arr.length>this.offset+1&&0===this.arr[0])this.arr.splice(0,1);while(this.offset>0&&0===this.arr[this.arr.length-1])this.arr.splice(this.arr.length-1,1),this.offset-=1}_checkArray(e){for(let t=0;t<e.length;t+=1)if(e[t]<0||this.base<=e[t])return!1;return!0}_constructString(e){let t="";for(let i=0;i<e.length;i+=1)t+=bt(e[i]),e.length-1-i===this.offset&&this.offset>0&&(t+=".");return this.isNegative&&(t=`-${t}`),t}}class wt{constructor(e,t){if(e.base!==t.base)throw new Error(`ComparisonBaseNSigned.constructor(n1, n2): Base of n1(${e.base})\n        and base of n2(${t.base}) must be qual.`);this.result=this._compare(e,t)}_compare(e,t){if(1===e.arr.length&&1===t.arr.length&&0===e.arr[0]&&0===e.arr[0])return 0;if(e.isNegative&&!t.isNegative)return-1;if(!e.isNegative&&t.isNegative)return 1;const i=e.isNegative&&t.isNegative?-1:1;if(e.arr.length-e.offset>t.arr.length-t.offset)return i;if(e.arr.length-e.offset<t.arr.length-t.offset)return-1*i;let n=0;while(n<e.arr.length||n<t.arr.length){const s=n<e.arr.length?e.arr[n]:0,a=n<t.arr.length?t.arr[n]:0;if(s>a)return i;if(a>s)return-1*i;n+=1}return 0}getResult(){return this.result}}class xt{constructor(e,t){if(e.base!==t.base)throw new Error(`SubtractionBaseNSigned.constructor(n1, n2): Base of n1(${e.base}) and base of n2(${t.base}) must be qual.`);this.watcher=null,this.result=this._subtract(e,t)}_subtract(e,t){if(this.watcher=new ht,!e.isNegative&&t.isNegative||e.isNegative&&!t.isNegative){const i=new vt(t.base,t.arr,t.offset,!t.isNegative),n=new _t(e,i);return this.watcher=this.watcher.step("OperatorSwitch").saveVariable("addition",n.watcher),n.getResult()}const i=e.base,n=new vt(e.base,e.arr,e.offset,!1),s=new vt(t.base,t.arr,t.offset,!1),a=new wt(n,s).getResult();let o=null,r=null,l=null;a>=0?(r=e,l=t,o=e.isNegative&&t.isNegative):(r=t,l=e,o=!(e.isNegative&&t.isNegative)),this.watcher.step("GetSign").saveVariable("compareValue",a).saveVariable("signN1",e.isNegative).saveVariable("signN2",t.isNegative).saveVariable("isNegative",o);const c=[...r.arr],u=[...l.arr],h=Math.max(r.offset,l.offset);r.offset<h&&c.push(...Array(h-r.offset).fill(0)),l.offset<h&&u.push(...Array(h-l.offset).fill(0));const d=Math.max(c.length,u.length);c.length<d&&c.unshift(...Array(d-c.length).fill(0)),u.length<d&&u.unshift(...Array(d-u.length).fill(0));const m=[],p=[];m.unshift(0);for(let g=d-1;g>=0;g-=1){const e=c[g]-u[g]-m[0];p.unshift((e+i)%i),e<0?m.unshift(1):m.unshift(0)}const f=new vt(i,p,h,o);return this.watcher.step("Subtraction").saveVariable("op1",r).saveVariable("op2",l).saveVariable("op1Arr",[...c]).saveVariable("op2Arr",[...u]).saveVariable("carryArr",[...m]).saveVariable("resultArr",[...p]).saveVariable("result",f),this.watcher.step("Final").saveVariable("result",f),new vt(i,p,h,o)}getResult(){return this.result}}class _t{constructor(e,t){if(e.base!==t.base)throw new Error(`AdditionBaseNSigned.constructor(n1, n2): Base of n1(${e.base})\n        and base of n2(${t.base}) must be qual.`);this.watcher=null,this.result=this._add(e,t)}_add(e,t){if(this.watcher=new ht,!e.isNegative&&t.isNegative){const i=new vt(t.base,t.arr,t.offset),n=new xt(e,i);return this.watcher.step("OperatorSwitch").saveVariable("subtraction",n.watcher),n.getResult()}if(e.isNegative&&!t.isNegative){const i=new vt(e.base,e.arr,e.offset),n=new xt(t,i);return this.watcher.step("OperatorSwitch").saveVariable("subtraction",n.watcher),n.getResult()}const i=e.base,n=e.isNegative&&t.isNegative;this.watcher.step("GetSign").saveVariable("signN1",e.isNegative).saveVariable("signN2",t.isNegative).saveVariable("isNegative",n);const s=[...e.arr],a=[...t.arr],o=Math.max(e.offset,t.offset);e.offset<o&&s.push(...Array(o-e.offset).fill(0)),t.offset<o&&a.push(...Array(o-t.offset).fill(0));const r=Math.max(s.length,a.length);s.length<r&&s.unshift(...Array(r-s.length).fill(0)),a.length<r&&a.unshift(...Array(r-a.length).fill(0));const l=[],c=[];l.unshift(0);for(let h=r-1;h>=0;h-=1){const e=s[h]+a[h]+l[0];c.unshift(e%i),l.unshift(Math.floor(e/i))}l[0]>0&&c.unshift(l[0]);const u=new vt(i,c,o,n);return this.watcher.step("Addition").saveVariable("op1",e).saveVariable("op2",t).saveVariable("op1Arr",[...s]).saveVariable("op2Arr",[...a]).saveVariable("carryArr",[...l]).saveVariable("resultArr",[...c]).saveVariable("result",u),this.watcher.step("Final").saveVariable("result",u),new vt(i,c,o,n)}getResult(){return this.result}}class $t{constructor(e,t){if(t<0||t>=e.base)throw new Error(`MultiplicationBaseNSigned.constructor(n1, n2): d(${t}) is not a part of base of n1(${e.base}).`);this.result=this._multiply(e,t)}_multiply(e,t){const i=e.offset,n=e.base,s=e.isNegative,a=[0],o=[];for(let r=e.arr.length-1;r>=0;r-=1){const i=t*e.arr[r]+a[0];o.unshift(i%n),a.unshift(Math.floor(i/n))}return o.unshift(a[0]),new vt(n,o,i,s)}getResult(){return this.result}}class yt{constructor(e,t){if(e.base!==t.base)throw new Error(`MultiplicationBaseNSigned.constructor(n1, n2): Base of n1(${e.base}) and base of n2(${t.base}) must be qual.`);this.watcher=null,this.result=this._multiply(e,t)}_multiply(e,t){this.watcher=new ht,this.watcher.step("MultiplicationInput").saveVariable("n1Arr",[...e.arr]).saveVariable("n2Arr",[...t.arr]);const i=e.base,n=e.isNegative&&!t.isNegative||t.isNegative&&!e.isNegative;this.watcher.step("GetSign").saveVariable("signN1",e.isNegative).saveVariable("signN2",t.isNegative).saveVariable("isNegative",n);let s=new vt(i,[0],0,!1);this.watcher.step("Multiplication").saveVariable("num1",e).saveVariable("num2",t);const a=e.arr,o=t.arr;while(0===a[a.length-1]&&0===o[o.length-1]&&Math.min(e.arr.length,t.arr.length)>0)a.pop(),o.pop();if(this.watcher.step("MultiplicationInput").saveVariable("n1Arr",[...e.arr]).saveVariable("n2Arr",[...t.arr]).saveVariable("leftArr",[...a]).saveVariable("rightArr",[...o]),0===Math.min(e.arr.length,t.arr.length)){const e=new vt(i,[0]);return this.watcher.step("Result").saveVariable("result",e).saveVariable("resultArr",[...e.arr]),e}this.watcher.step("MultiplicationSteps").saveVariable("countSteps",t.arr.length);for(let l=0;l<t.arr.length;l+=1){const t=new vt(i,e.arr,l,!1),n=new $t(t,o[l]).getResult();this.watcher.step("MultiplicationSteps").saveVariable(`Step${l}_cur`,s).saveVariable(`Step${l}_toAdd`,n);for(let e=0;e<l;e+=1)n.arr.unshift(0);s=new _t(s,n).getResult()}this.watcher.step("MultFinal").saveVariable("cur",s);const r=new vt(i,s.arr,s.offset,n);return this.watcher.step("Result").saveVariable("result",r).saveVariable("resultArr",[...r.arr]),r}getResult(){return this.result}}class Et{constructor(e,t){e.expBitNum!==t.expBitNum&&console.log(`MultiplicationIEEE(Number, Number): expBitNum of n1(${e.expBitNum})\n        and expBitNum of n2(${t.expBitNum}) not compatible.`),e.manBitNum!==t.manBitNum&&console.log(`MultiplicationIEEE(Number, Number): manBitNum of n1(${e.manBitNum})\n        and manBitNum of n2(${t.manBitNum}) not compatible.`),this.producedOverflow=!1,this.result=this._multiply(e,t)}_multiply(e,t){this.watcher=new ht;const i=e.expBitNum,n=e.manBitNum,s=e.bitNum,a=(e.sign&&!t.sign||!e.sign&&t.sign)+0;if(this.watcher=this.watcher.step("MulMantissa").saveVariable("sign",a),e.isNaN||t.isNaN||e.isInfinity&&t.isZero||e.isZero&&t.isInfinity){const e=new it(i,n,Array(s).fill(1));return this.watcher=this.watcher.step("ResultEdgecase").saveVariable("edgecase","nan"),this.watcher=this.watcher.step("Result").saveVariable("result",e),e}if(e.isInfinity||t.isInfinity){const e=[a];e.push(...Array(i).fill(1)),e.push(...Array(n).fill(0));const t=new it(i,n,e);return this.watcher=this.watcher.step("ResultEdgecase").saveVariable("edgecase","inf"),this.watcher=this.watcher.step("Result").saveVariable("result",t),t}if(e.isZero||t.isZero){const e=[a];e.push(...Array(i).fill(0)),e.push(...Array(n).fill(0));const t=new it(i,n,e);return this.watcher=this.watcher.step("ResultEdgecase").saveVariable("edgecase","zero"),this.watcher=this.watcher.step("Result").saveVariable("result",t),t}const o=new vt(2,e.mantissaBits),r=new vt(2,t.mantissaBits),l=new yt(o,r);this.watcher=this.watcher.step("Multiplication").saveVariable("multiplication",l.watcher);const c=l.getResult(),u=c.digitNum,h=[...c.arr];this.watcher=this.watcher.step("MulMantissa").saveVariable("unnormalizedMantissa",h);for(let _=h.length;_<Math.max(e.mantissaBits.length,t.mantissaBits.length);_+=1)h.push(0);let d=u;while(d>1&&0===h[0])h.splice(0,1),d-=1;let m=c.arr.length-c.offset-o.arr.length;if(d>=1)m=d-1;else for(let _=0;_<h.length;_+=1){if(1===h[_])break;m-=1}if(this.watcher=this.watcher.step("MulMantissa").saveVariable("shift",m),m===h.length-1&&0===h[0]){const e=new it(i,n,Array(s).fill(0));return this.watcher=this.watcher.step("ResultEdgecase").saveVariable("edgecase","zero"),this.watcher=this.watcher.step("Result").saveVariable("result",e),e}let p=[];const f=!(h.length<=n)&&1===h[n+1];for(let _=0;_<n;_+=1){const e=_+Math.max(-m,0)+1,t=e<h.length?h[e]:0;p.push(t)}f&&(p=Je(p,n,f,e.base)),this.watcher=this.watcher.step("CalculateExp").saveVariable("E1",e.E).saveVariable("E2",t.E).saveVariable("bias",e.bias).saveVariable("notShifted",e.E+t.E-e.bias),this.watcher=this.watcher.step("MulMantissa").saveVariable("normalizedMantissa",p);let g=e.E+t.E-e.bias+m;if(g<=0){p.unshift(1),p.pop();for(let e=0;e<Math.abs(g);e+=1)p.unshift(0),p.pop();g=0}let b=g;const v=[];for(let _=0;_<i;_+=1)v.unshift(b%2),b=Math.floor(b/2);if(g>=2**i-1){const e=[a];e.push(...Array(i).fill(1)),e.push(...Array(n).fill(0));const t=new it(i,n,e);return this.watcher=this.watcher.step("ResultEdgecase").saveVariable("edgecase","inf"),this.watcher=this.watcher.step("Result").saveVariable("result",t),t}this.watcher=this.watcher.step("ResultEdgecase").saveVariable("edgecase","none");const w=[a];w.push(...v),w.push(...p);const x=new it(i,n,w);return this.watcher=this.watcher.step("Result").saveVariable("result",x),x}getResult(){return this.result}}class Ct{constructor(e,t,i){this.manBitNum=void 0!==i?i:null,e.base!==t.base&&console.log("DivisonBaseNComplement(Number, Number): Base of n1(".concat(e.base,") and base of n2(").concat(t.base,") are not compatible.")),e.digitNum!==t.digitNum&&console.log("DivisonBaseNComplement(Number, Number): DigitNum of n1(".concat(e.digitNum,") and digitNum of n2(").concat(t.digitNum,") are not compatible.")),this.watcher=null,this.producedOverflow=!1,this.firstNegativeStep=!1,this.result=this._divide(e,t)}_divide(e,t){this.watcher=new ht;const i=Math.max(e.offset,t.offset),n=e.arr.length+i+1;this.watcher.step("DivisionInput").saveVariable("n1Arr",[...e.arr]).saveVariable("n2Arr",[...t.arr]),this.watcher.step("DetermineSize").saveVariable("n1Offset",e.offset).saveVariable("n2Offset",t.offset).saveVariable("digitNum",e.digitNum).saveVariable("offset",i).saveVariable("digitsToTake",n);const s=[...e.arr];let a=[...t.arr];for(let m=0;m<t.arr.length-e.arr.length;m+=1)s.push(0);while(0===s[s.length-1]&&0===a[a.length-1])s.splice(-1,1),a.splice(-1,1);let o=[...s];const r=[];let l=!0,c=a.length-1,u=a.length,h=0;while(c<=2*this.manBitNum&&l){o.length>a.length&&(a=a.concat(Array(o.length-a.length).fill(0,0)));const n=new mt(e.base,o.length,o,i,!1),d=new mt(t.base,a.length,a,i,!0),m=new pt(n,d),p=m.getResult();0===h&&m.negativeResult&&(this.firstNegativeStep=!0),this.watcher.step("DivisionSteps").saveVariable(`Step${h}_Sub1`,[...o]).saveVariable(`Step${h}_Sub2`,[...a]).saveVariable(`Step${h}_SubRes`,[...p.arr]).saveVariable(`Step${h}_SubRes_isNegative`,m.negativeResult);const f=[...p.arr];f.every((e=>0===e))?(r.push(1),this.watcher.step("DivisionSteps").saveVariable(`Step${h}_SubRes_isZero`,!0),l=!1):(!1===m.negativeResult?(this.watcher.step("DivisionSteps").saveVariable(`Step${h}_SubRes_isZero`,!1),r.push(1),o=[...p.arr]):r.push(0),u>=s.length?o.push(0):(o.push(s[u-1]),u+=1),o.length>a.length&&a.unshift(0)),this.watcher.step("DivisionSteps").saveVariable(`Step${h}_ActRes`,[...r]),c+=1,h+=1}this.watcher.step("DivisionSteps").saveVariable("countSteps",h);const d=new vt(e.base,[...r],i,e.isNegative!==t.isNegative);return this.watcher.step("Result").saveVariable("digitsToTake",n).saveVariable("result",d).saveVariable("resultArr",[...r]),d}getResult(){return this.result}}class Mt{constructor(e,t){e.expBitNum!==t.expBitNum&&console.log("DivisionIEEE(Number, Number): expBitNum of n1(".concat(e.expBitNum,") and expBitNum of n2(").concat(t.expBitNum,") not compatible.")),e.manBitNum!==t.manBitNum&&console.log("DivisionIEEE(Number, Number): manBitNum of n1(".concat(e.manBitNum,") and manBitNum of n2(").concat(t.manBitNum,") not compatible.")),this.producedOverflow=!1,this.result=this._divide(e,t)}_divide(e,t){this.watcher=new ht;const i=e.expBitNum,n=e.manBitNum,s=e.bitNum,a=(e.sign&&!t.sign||!e.sign&&t.sign)+0;if(e.isNaN||t.isNaN||e.isInfinity&&t.isZero||e.isZero&&t.isInfinity){const e=new it(i,n,Array(s).fill(1));return this.watcher=this.watcher.step("ResultEdgecase").saveVariable("edgecase","nan"),this.watcher=this.watcher.step("Result").saveVariable("result",e),e}if(e.isInfinity&&t.isInfinity||e.isZero&&t.isZero){const e=new it(i,n,Array(s).fill(1));return this.watcher=this.watcher.step("ResultEdgecase").saveVariable("edgecase","nan"),this.watcher=this.watcher.step("Result").saveVariable("result",e),e}if(e.isInfinity&&!t.isInfinity||!e.isZero&&t.isZero){const e=[a];e.push(...Array(i).fill(1)),e.push(...Array(n).fill(0));const t=new it(i,n,e);return this.watcher=this.watcher.step("ResultEdgecase").saveVariable("edgecase","inf"),this.watcher=this.watcher.step("Result").saveVariable("result",t),t}if(!e.isInfinity&&t.isInfinity||e.isZero){const e=[a];e.push(...Array(i).fill(0)),e.push(...Array(n).fill(0));const t=new it(i,n,e);return this.watcher=this.watcher.step("ResultEdgecase").saveVariable("edgecase","zero"),this.watcher=this.watcher.step("Result").saveVariable("result",t),t}let o=0,r=!0;while(o<e.mantissaBits.length&&!0===r)e.mantissaBits[o]!==t.mantissaBits[o]&&(r=!1),o+=1;let l=[];const c=[];let u=0;if(this.watcher=this.watcher.step("Division").saveVariable("equalMantissa",r),!1===r){const a=new vt(2,e.mantissaBits,e.offset,!1),o=new vt(2,t.mantissaBits,t.offset,!1),r=new Ct(a,o,Math.max(e.manBitNum+1,t.manBitNum+1));this.watcher=this.watcher.step("Division").saveVariable("division",r.watcher);const h=r.getResult();l=[...h.arr];const d=r.manBitNum;this.watcher=this.watcher.step("Division").saveVariable("divMantissa",[...l]),l=Je(l,d);let m=0;while(m<l.length){if(1===l[m])break;m+=1,u-=1}if(r.firstNegativeStep&&(u-=1),u===l.length-1&&0===l[0]){const e=new it(i,n,Array(s).fill(0));return this.watcher=this.watcher.step("ResultEdgecase").saveVariable("edgecase","zero"),this.watcher=this.watcher.step("Result").saveVariable("result",e),e}for(let e=1;e<=n;e+=1){const t=e<l.length?l[e]:0;c.push(t)}}else for(let g=0;g<n;g+=1)c.push(0);let h=e.E-t.E+e.bias+u;if(h<=0){c.unshift(1),c.pop();for(let e=0;e<Math.abs(h);e+=1)c.unshift(0),c.pop();h=0}let d=h;const m=[];for(let g=0;g<i;g+=1)m.unshift(d%2),d=Math.floor(d/2);if(this.watcher=this.watcher.step("Exponent").saveVariable("E1",e.E).saveVariable("E2",t.E).saveVariable("Bias",e.bias).saveVariable("Shift",u).saveVariable("EUnshifted",e.E-t.E+e.bias).saveVariable("FinalE",h),this.watcher=this.watcher.step("Mantissa").saveVariable("unnormalizedMantissa",[...l]).saveVariable("normalizedMantissa",[...c]),h>=2**i-1){const e=[a];e.push(...Array(i).fill(1)),e.push(...Array(n).fill(0));const t=new it(i,n,e);return this.watcher=this.watcher.step("ResultEdgecase").saveVariable("edgecase","inf"),this.watcher=this.watcher.step("Result").saveVariable("result",t),t}this.watcher=this.watcher.step("ResultEdgecase").saveVariable("edgecase","none");const p=[a];p.push(...m),p.push(...c);const f=new it(i,n,p);return this.watcher=this.watcher.step("Result").saveVariable("edgecase","none").saveVariable("result",f),f}getResult(){return this.result}}function kt(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}class Tt{constructor(e,t){kt(this,Tt),this.exponentBits=e,this.numBits=t,this.actBit="",this.bitString="",this.result="",this.resultObject="",this.watcher="",this.negativeSummand=!1,this.negativeSubtrahend=!1,this.denominatorZero=!0,this.negativeMinuendSubtrahend=!1}computeSolution(e,t,i){if(""!==e&&""!==t){const n=nt(this.exponentBits,e),s=nt(this.exponentBits,t);console.log(n);let a=null;switch(this.negativeSummand=!1,this.negativeSubtrahend=!1,this.denominatorZero=!1,this.negativeMinuendSubtrahend=!1,i){case"add":0===n.sign&&0===s.sign?(a=new ft(n,s),this.resultObject=a.watcher.steps.Result.data.result):1===s.sign?(s.sign=0,s.arr[0]=0,this.negativeSummand=!0,1===n.sign&&(this.negativeMinuendSubtrahend=!0),a=new gt(n,s),this.resultObject=a.watcher.steps.Addition.data.addition.steps.Result.data.result):(this.negativeSummand=!0,n.sign=0,n.arr[0]=0,a=new gt(s,n),this.resultObject=a.watcher.steps.Addition.data.addition.steps.Result.data.result);break;case"mul":a=new Et(n,s),this.resultObject=a.watcher.steps.Result.data.result;break;case"sub":0===s.sign?1===n.sign?(this.negativeMinuendSubtrahend=!0,n.sign=0,n.arr[0]=0,s.sign=0,s.arr[0]=0,a=new ft(n,s),this.resultObject=a.watcher.steps.Result.data.result,this.resultObject.sign=1,this.resultObject.arr[0]=0):(a=new gt(n,s),this.resultObject=a.watcher.steps.Addition.data.addition.steps.Result.data.result):1===n.sign&&1===s.sign?(this.negativeSubtrahend=!0,a=new gt(n,s),this.resultObject=a.watcher.steps.Addition.data.addition.steps.Result.data.result):(this.negativeSubtrahend=!0,s.sign=0,s.arr[0]=0,a=new ft(n,s),this.resultObject=a.watcher.steps.Result.data.result);break;case"div":if(s.isZero)return void(this.denominatorZero=!0);a=new Mt(n,s),this.resultObject=a.watcher.steps.Result.data.result;break;default:}this.watcher=a.watcher;let o="";o=a.getResult().bitString,a.getResult().isNaN&&(o+=" is Nan"),a.getResult().isZero&&(o+=" is Zero"),a.getResult().isInfinity&&(o+=" is Inf"),this.result=o}}}var St={name:"FloatingPointArithmetic",components:{FSelect:Oe,Accordion:qe,AccordionItem:Ze,AttentionBanner:Fe},data(){const e=!1;let t=!1,i="add";e&&window.sessionStorage.getItem("FPF_operator")&&(i=window.sessionStorage.getItem("FPF_operator"),t=!0);let n="decimal";e&&window.sessionStorage.getItem("FPF_format1")&&(n=window.sessionStorage.getItem("FPF_format1"),t=!0);let s="decimal";e&&window.sessionStorage.getItem("FPF_format2")&&(s=window.sessionStorage.getItem("FPF_format2"),t=!0);let a="";e&&window.sessionStorage.getItem("FPF_inputNums1")&&(a=window.sessionStorage.getItem("FPF_inputNums1"),t=!0);let o="";e&&window.sessionStorage.getItem("FPF_inputNums2")&&(o=window.sessionStorage.getItem("FPF_inputNums2"),t=!0);let r=5;e&&window.sessionStorage.getItem("FPF_expBits")&&(r=parseInt(window.sessionStorage.getItem("FPF_expBits"),10),t=!0);let l=16;e&&window.sessionStorage.getItem("FPF_numBits")&&(l=parseInt(window.sessionStorage.getItem("FPF_numBits"),10),t=!0);const c=this.numBitsToBitRange(l);return{useCookies:e,selectedFormat:[n,"ieee",i,s,"ieee",c],mouseDown:!1,solution:"",solutionObject:"",inputNums:{0:a,1:o},nums:{0:"",1:""},exponentBits:r,numBits:l,containerWidth:500,solutionSteps:[],negativeSummand:!1,negativeSubtrahend:!1,negativeMinuendSubtrahend:!1,denominatorZero:!1,default:t,watcher:"",propVB:"",backVB:"",propE:"",backE:"",propM:"",backM:""}},computed:{falseFormatOutput(){return this.$t("falseFormat")},numLeft(){return this.checkAndConvertFormat(0)},numRight(){return this.checkAndConvertFormat(1)},solDescr(){const e=new Tt(this.exponentBits,this.numBits);this.nums[0]!==this.falseFormatOutput&&this.nums[1]!==this.falseFormatOutput&&e.computeSolution(this.nums[0],this.nums[1],this.selectedFormat[2]);const t=JSON.parse(JSON.stringify(e.watcher)),i=e.negativeMinuendSubtrahend,n=e.negativeSubtrahend,s=e.negativeSummand,a=e.denominatorZero;let o=[],r=[],l=[];if(!a){o=e.result;const t=new at(this,this.exponentBits,this.numBits,e.watcher);this.nums[0]!==this.falseFormatOutput&&this.nums[1]!==this.falseFormatOutput&&t.makeDescriptionArithmetic(this.nums[0],this.nums[1],o,this.selectedFormat[2]),l=t.result,r=e.resultObject}return this.setVariables(t,i,n,s,a,o,r),l},operationOptions(){return{add:`${this.$t("addition")} (+)`,sub:`${this.$t("subtraction")} (-)`,mul:`${this.$t("multiplication")} (*)`,div:`${this.$t("division")} (/)`}},formatOptions(){return{decimal:`${this.$t("decimal")}`,binary:`${this.$t("binary")}`,ieee:"IEEE"}},bitrangeOptions(){return{eight:"8 Bit",sixteen:"16 Bit",thirtytwo:"32 Bit"}}},mounted(){this.$nextTick((()=>{window.addEventListener("resize",(()=>{this.containerWidth=Math.min(500,window.innerWidth-250)})),window.addEventListener("unload",(()=>{this.containerWidth=Math.min(500,window.innerWidth-250)}))})),this.default&&(this.checkAndConvertFormat(0),this.checkAndConvertFormat(1),this.recalculate())},watch:{input(){this.saveVals()}},methods:{setVariables(e,t,i,n,s,a,o){this.watcher=e,this.negativeMinuendSubtrahend=t,this.negativeSubtrahend=i,this.negativeSummand=n,this.denominatorZero=s,this.solution=a,this.solutionObject=o},saveVals(){this.useCookies&&(window.sessionStorage.setItem("FPF_operator",this.selectedFormat[2]),window.sessionStorage.setItem("FPF_format1",this.selectedFormat[0]),window.sessionStorage.setItem("FPF_format2",this.selectedFormat[3]),window.sessionStorage.setItem("FPF_inputNums1",this.inputNums[0]),window.sessionStorage.setItem("FPF_inputNums2",this.inputNums[1]),window.sessionStorage.setItem("FPF_expBits",this.exponentBits),window.sessionStorage.setItem("FPF_numBits",this.numBits))},recalculate(){this.saveVals(),this.containerWidth=Math.min(500,window.innerWidth-250),this.convertFormat(0),this.convertFormat(1),this.$nextTick((()=>{window.MathJax&&window.MathJax.typeset()}))},numBitsToBitRange(e){return{8:"eight",16:"sixteen",32:"thirtytwo"}[e]},selectBitRange(e,t){this.selectedFormat[e]=t,"eight"===t?(this.numBits=8,this.exponentBits=3):"sixteen"===t?(this.numBits=16,this.exponentBits=5):"thirtytwo"===t&&(this.numBits=32,this.exponentBits=8),this.recalculate()},selectVal(e,t){this.selectedFormat[e]=t;const i=e>2?1:0;this.checkAndConvertFormat(i)},selectOp(e,t){this.selectedFormat[e]=t,this.recalculate()},checkFormat(e,t){let i=!1;const n=t.replace(/\s/g,"");if("ieee"===e&&n.length!==this.numBits)return!1;for(let s=0;s<n.length;s+=1){if("binary"===e&&!["0","1",",",".","-","+"].includes(n[s]))return!1;if("ieee"===e&&"0"!==n[s]&&"1"!==n[s])return!1;if("decimal"===e&&!["0","1","2","3","4","5","6","7","8","9",",",".","-","+"].includes(n[s]))return!1;if(("binary"===e||"decimal"===e)&&("+"===n[s]||"-"===n[s])&&s>1)return!1;if(["-","+"].includes(n[s])&&s>0)return!1;if(","===n[s]||"."===n[s]){if(i)return!1;i=!0}}return!!/\d/.test(n)},checkAndConvertFormat(e){const t=this.selectedFormat[3*e],i=this.inputNums[e];if(!this.checkFormat(t,i))return this.nums[e]=this.falseFormatOutput,this.falseFormatOutput;const n=this.convertFormat(e);return this.$nextTick((()=>{window.MathJax&&window.MathJax.typeset()})),n},downloadPdf(){this.recalculate();const e=new ct(this,this.exponentBits,this.numBits,this.watcher);e.generatePdf(this.inputNums[0],this.inputNums[1],this.solution,this.selectedFormat[2],this.selectedFormat[0],this.selectedFormat[3])},convertFormat(e){const t=this.selectedFormat[3*e],i=this.selectedFormat[3*e+1],n=this.inputNums[e],s=new Qe(this.exponentBits,this.numBits);if(0===n.length)return"";let a=n;return"binary"===t?"decimal"===i?(s.binToDec(n),a=s.result):"ieee"===i&&(s.binToIEEE(n),a=s.result):"decimal"===t?"binary"===i?(s.decToBin(n),a=s.result):"ieee"===i&&(s.decToBin(n),console.log(s.result),s.binToIEEE(s.result),a=s.result):"ieee"===t&&("binary"===i?(s.ieeeToBin(n),a=s.result):"decimal"===i&&(s.ieeeToBin(n),s.binToDec(s.result),a=s.result)),this.nums[e]=a,a},checkSolution(){const e=new rt(this.exponentBits);e.checkSolution(this.solutionObject,this.propVB,this.propE,this.propM),this.backVB=e.backVB,this.backE=e.backE,this.backM=e.backM},preventGlobalMouseEvents(){document.body.style["pointer-events"]="none"},restoreGlobalMouseEvents(){document.body.style["pointer-events"]="auto"},mouseupListener(e){this.restoreGlobalMouseEvents(),document.removeEventListener("mouseup",this.mouseupListener,{capture:!0}),document.removeEventListener("mousemove",this.sliderMouseMove,{capture:!0}),e.stopPropagation(),this.mouseDown=!1},captureMouseEvents(e){this.preventGlobalMouseEvents(),document.addEventListener("mouseup",this.mouseupListener,{capture:!0}),document.addEventListener("mousemove",this.sliderMouseMove,{capture:!0}),e.preventDefault(),e.stopPropagation()},sliderMouseDown(e){this.mouseDown=!0,this.xCoord=e.pageX,this.captureMouseEvents(e)},sliderMouseMove(e){if(this.mouseDown){const t=this.containerWidth/(this.numBits-1);e.pageX-this.xCoord>t&&(this.xCoord+=t,this.exponentBits+1<this.numBits-1&&(this.exponentBits+=1,this.nums[0]!==this.falseFormatOutput&&this.convertFormat(0),this.nums[1]!==this.falseFormatOutput&&this.convertFormat(1)),this.$nextTick((()=>{window.MathJax&&window.MathJax.typeset()}))),this.xCoord-e.pageX>t&&(this.xCoord-=t,this.exponentBits>2&&(this.exponentBits-=1,this.nums[0]!==this.falseFormatOutput&&this.convertFormat(0),this.nums[1]!==this.falseFormatOutput&&this.convertFormat(1)),this.$nextTick((()=>{window.MathJax&&window.MathJax.typeset()})))}},expandFraction(){this.exponentBits=Math.max(this.exponentBits-1,2),this.recalculate()},expandExponent(){this.exponentBits=Math.min(this.exponentBits+1,this.numBits-2),this.recalculate()}}};const Nt=(0,z.A)(St,[["render",ke],["__scopeId","data-v-2abae55c"]]);var Bt=Nt;const Ft={class:"fp-exercise pageContainer"},Lt={class:"title"},At={class:"bodyContainer"},Vt={class:"introduction"},It={class:"floatingPointInput"},Dt={class:"floatingPointInput"},Pt=["innerHTML"],Ot={class:"solutionArea"},jt={class:"solutionInput"},Rt={class:"solutionInput"},zt={class:"solutionInput"},Wt={style:{position:"relative"}},qt={id:"solution"},Ht=["innerHTML"],Ut=["innerHTML"];function Kt(e,t,i,s,a,o){const r=(0,m.g2)("FSelect"),l=(0,m.g2)("AttentionBanner"),c=(0,m.g2)("AccordionItem"),u=(0,m.g2)("Accordion");return(0,m.uX)(),(0,m.CE)("div",Ft,[(0,m.Lk)("h3",Lt,(0,p.v_)(e.$t("exercises")),1),(0,m.Lk)("div",At,[(0,m.Lk)("p",Vt,(0,p.v_)(e.$t("fpExerciseIntro")),1),(0,m.Lk)("h4",null,(0,p.v_)(e.$t("generateEx")),1),(0,m.Lk)("div",null,[(0,m.Lk)("div",It,[(0,m.Lk)("h5",null,(0,p.v_)(e.$t("randomExercise"))+":",1),(0,m.bF)(r,{sel:a.selectedFormat[0],onInput:o.selectOp,num:0,options:o.operationOptions},null,8,["sel","onInput","options"]),t[6]||(t[6]=(0,m.Lk)("div",{class:"divMargin"},null,-1)),(0,m.Lk)("button",{onClick:t[0]||(t[0]=(...e)=>o.generateExercise&&o.generateExercise(...e))},(0,p.v_)(e.$t("generate")),1)]),(0,m.Lk)("div",Dt,[(0,m.Lk)("h5",null,(0,p.v_)(e.$t("fp_from_archive"))+":",1),(0,m.bF)(r,{options:o.archivedExerciseTitles,sel:0,onInput:o.selectArchivedExercise,ref:"archivedExercisesFPDropDownMenu"},null,8,["options","onInput"]),t[7]||(t[7]=(0,m.Lk)("div",{class:"divMargin"},null,-1)),(0,m.Lk)("button",{onClick:t[1]||(t[1]=(...e)=>o.loadArchivedExercise&&o.loadArchivedExercise(...e))},(0,p.v_)(e.$t("load")),1)])]),(0,m.Lk)("div",{id:"exerciseField",innerHTML:o.exerciseText},null,8,Pt),(0,m.Lk)("h4",null,(0,p.v_)(e.$t("ownSolution")),1),(0,m.bF)(l,{text:e.$t("attRound")},null,8,["text"]),(0,m.Lk)("div",Ot,[(0,m.Lk)("div",jt,[(0,m.Lk)("p",null,(0,p.v_)(e.$t("signBit")),1),(0,m.bo)((0,m.Lk)("input",{id:"propVB",class:(0,p.C4)(a.backVB),"onUpdate:modelValue":t[2]||(t[2]=e=>a.propVB=e)},null,2),[[n.Jo,a.propVB]])]),t[8]||(t[8]=(0,m.Lk)("div",{class:"divMargin"},null,-1)),(0,m.Lk)("div",Rt,[(0,m.Lk)("p",null,(0,p.v_)(e.$t("exponentBits")),1),(0,m.bo)((0,m.Lk)("input",{id:"propE",class:(0,p.C4)(a.backE),"onUpdate:modelValue":t[3]||(t[3]=e=>a.propE=e)},null,2),[[n.Jo,a.propE]])]),t[9]||(t[9]=(0,m.Lk)("div",{class:"divMargin"},null,-1)),(0,m.Lk)("div",zt,[(0,m.Lk)("p",null,(0,p.v_)(e.$t("fractionBits")),1),(0,m.bo)((0,m.Lk)("input",{id:"propM",class:(0,p.C4)(a.backM),"onUpdate:modelValue":t[4]||(t[4]=e=>a.propM=e)},null,2),[[n.Jo,a.propM]])]),t[10]||(t[10]=(0,m.Lk)("div",{class:"divMargin"},null,-1)),(0,m.Lk)("button",{id:"checkSolution",onClick:t[5]||(t[5]=(...e)=>o.checkSolution&&o.checkSolution(...e))},(0,p.v_)(e.$t("check")),1)]),(0,m.Lk)("h4",null,(0,p.v_)(e.$t("correctSolution")),1),(0,m.Lk)("div",Wt,[(0,m.bF)(l,{text:e.$t("attSolve")},null,8,["text"])]),(0,m.Lk)("div",qt,[(0,m.bF)(u,{solutionDescription:o.solDescr},{default:(0,m.k6)((()=>[((0,m.uX)(!0),(0,m.CE)(m.FK,null,(0,m.pI)(o.solDescr,(e=>((0,m.uX)(),(0,m.Wv)(c,{key:e.name},{"accordion-item-title":(0,m.k6)((()=>[(0,m.eW)((0,p.v_)(e.name),1)])),"accordion-item-body":(0,m.k6)((()=>[(0,m.Lk)("span",{innerHTML:e.text},null,8,Ht),null!=e.subpanels?((0,m.uX)(),(0,m.Wv)(u,{key:0},{default:(0,m.k6)((()=>[((0,m.uX)(!0),(0,m.CE)(m.FK,null,(0,m.pI)(e.subpanels,(e=>((0,m.uX)(),(0,m.Wv)(c,{key:e.name},{"accordion-item-title":(0,m.k6)((()=>[(0,m.eW)((0,p.v_)(e.name),1)])),"accordion-item-body":(0,m.k6)((()=>[(0,m.Lk)("span",{innerHTML:e.text},null,8,Ut)])),_:2},1024)))),128))])),_:2},1024)):(0,m.Q3)("",!0)])),_:2},1024)))),128))])),_:1},8,["solutionDescription"])])])])}function Gt(e){return[{title:`${e.t("complementExample")}`,handle:"complementExample",data:{fp1:"0 01110 1100100000",fp2:"1 01001 1001010111",op:"add"}},{title:`${e.t("shiftZero")}`,handle:"shiftZero",data:{fp1:"0 10010 0101111100",fp2:"1 00010 0000100011",op:"add"}},{title:`${e.t("doubleNegative")}`,handle:"doubleNegative",data:{fp1:"1 01101 0111001010",fp2:"1 01100 0100000010",op:"add"}},{title:`${e.t("denormalized")}`,handle:"denormalized",data:{fp1:"1 00110 0010101010",fp2:"1 11011 0011111100",op:"div"}}]}function Xt(e){return Gt(e).map((e=>e.title))}function Zt(e,t){return Gt(e)[t]}function Jt(e,t){const i=Gt(e);for(let n=0;n<i.length;n+=1)if(i[n].handle===t)return n;return-1}function Yt(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}class Qt{constructor(e,t){Yt(this,Qt),this.exponentBits=e,this.numBits=t,this.actBit="",this.bitString="",this.result=""}generateRandomBit(){this.actBit=Math.round(Math.random())}generateRandomBits(e){let t="";for(let i=0;i<e;i+=1)this.generateRandomBit(),t+=this.actBit;this.bitString=t}generateRandomIEEE(){this.generateRandomBit();const e=this.actBit;this.generateRandomBits(this.exponentBits);const t=this.bitString;this.generateRandomBits(this.numBits-1-this.exponentBits);const i=this.bitString;this.result=`${e} ${t} ${i}`}}var ei={name:"FloatingPointExercises",components:{FSelect:Oe,Accordion:qe,AccordionItem:Ze,AttentionBanner:Fe},data(){const e=!1;let t=!1,i="";e&&window.sessionStorage.getItem("Exer_fp1")&&(i=window.sessionStorage.getItem("Exer_fp1"),t=!0);let n="";e&&window.sessionStorage.getItem("Exer_fp2")&&(n=window.sessionStorage.getItem("Exer_fp2"),t=!0);let s="add";e&&window.sessionStorage.getItem("Exer_operator")&&(s=window.sessionStorage.getItem("Exer_operator"),t=!0);let a=5;e&&window.sessionStorage.getItem("Exer_expBits")&&(a=parseInt(window.sessionStorage.getItem("Exer_expBits"),10),t=!0);let o=16;return e&&window.sessionStorage.getItem("Exer_numBits")&&(o=parseInt(window.sessionStorage.getItem("Exer_numBits"),10),t=!0),{useCookies:e,selectedFormat:[s],mouseDown:!1,exponentBits:a,numBits:o,propVB:"",backVB:"",propE:"",backE:"",propM:"",backM:"",solution:"",solutionObject:"",containerWidth:500,watcher:"",solutionSteps:[],fp1:i,fp2:n,default:t,archivedExerciseSelectedIndex:0}},mounted(){this.loadExerciseFromURL(),this.$nextTick((()=>{this.default&&this.drawExercise()}))},computed:{archivedExerciseTitles(){return Xt(this.$i18n)},operationOptions(){return{add:`${this.$t("addition")} (+)`,sub:`${this.$t("subtraction")} (-)`,mul:`${this.$t("multiplication")} (*)`,div:`${this.$t("division")} (/)`}},solDescr(){console.log("Print",this.exponentBits,this.numBits,this.fp1,this.fp2);const e=new Tt(this.exponentBits,this.numBits);e.computeSolution(this.fp1,this.fp2,this.selectedFormat[0]);const t=e.watcher,i=new at(this,this.exponentBits,this.numBits,t);return i.makeDescriptionArithmetic(this.fp1,this.fp2,e.result,this.selectedFormat[0]),this.setVariables(t,e.result,e.resultObject),i.result},exerciseText(){if(""===this.fp1)return"";const e=this.selectedFormat[0],t={add:[this.$t("addition"),"+"],mul:[this.$t("multiplication"),"\\cdot"],sub:[this.$t("subtraction"),"-"],div:[this.$t("division"),"/"]};console.log(e),console.log("Info",{op1:t[e][0],op2:t[e][1]});const i=this.$t("fpExerciseText",{op1:t[e][0],op2:t[e][1]});return console.log(i),`${i} \n\n          \\( fp_1 = \\text{${this.fp1}} \\)\n\n          \\( fp_2 = \\text{${this.fp2}} \\)`}},updated(){this.$nextTick((()=>{window.MathJax&&window.MathJax.typeset()}))},methods:{setVariables(e,t,i){this.watcher=e,this.solution=t,this.solutionObject=i},selectArchivedExercise(e,t){this.archivedExerciseSelectedIndex=t},loadArchivedExercise(){const e=this.archivedExerciseSelectedIndex;if(e<0)return;const t=Zt(this.$i18n,e).data;this.fp1=t.fp1,this.fp2=t.fp2,this.selectedFormat[0]=t.op,this.prepareExercise()},saveVals(){this.useCookies&&(window.sessionStorage.setItem("Exer_fp1",this.fp1),window.sessionStorage.setItem("Exer_fp2",this.fp2),window.sessionStorage.setItem("Exer_operator",this.selectedFormat[0]),window.sessionStorage.setItem("Exer_expBits",this.exponentBits),window.sessionStorage.setItem("Exer_numBits",this.numBits))},downloadPdf(){this.useCookies&&(window.sessionStorage.setItem("FPF_operator",this.selectedFormat[0]),window.sessionStorage.setItem("FPF_format1","ieee"),window.sessionStorage.setItem("FPF_format2","ieee"),window.sessionStorage.setItem("FPF_inputNums1",this.fp1),window.sessionStorage.setItem("FPF_inputNums2",this.fp2),window.sessionStorage.setItem("FPF_expBits",this.exponentBits),window.sessionStorage.setItem("FPF_numBits",this.numBits));const e=new ct(this,this.exponentBits,this.numBits,this.watcher);e.generatePdf(this.fp1,this.fp2,this.solution,this.selectedFormat[0],"ieee","ieee")},checkSolution(){const e=new rt(this.exponentBits);e.checkSolution(this.solutionObject,this.propVB,this.propE,this.propM),this.backVB=e.backVB,this.backE=e.backE,this.backM=e.backM},drawExercise(){this.$nextTick((()=>{window.MathJax&&window.MathJax.typeset()}))},prepareExercise(){this.saveVals(),this.drawExercise()},generateExercise(){const e=new Qt(this.exponentBits,this.numBits);e.generateRandomIEEE(),this.fp1=e.result,e.generateRandomIEEE(),this.fp2=e.result,console.log(this.fp1,this.fp2),this.prepareExercise()},selectVal(e,t){this.selectedFormat[e]=t;const i=e>2?1:0;this.checkAndConvertFormat(i)},selectOp(e,t){this.selectedFormat[e]=t},loadExerciseFromURL(){if(!this.$route.query)return;const e=this.$route.query.load;if(!e)return;const t=Jt(this.$i18n,e);-1!==t?(this.selectArchivedExercise(0,t),this.loadArchivedExercise(),this.$nextTick((()=>{this.$refs.archivedExercisesFPDropDownMenu.setSelected(t)}))):console.error("Unknown BooleanFunctionMinimizer-exercise handle: ",e)}}};const ti=(0,z.A)(ei,[["render",Kt],["__scopeId","data-v-74fd1a38"]]);var ii=ti;const ni={class:"fp-exercise pageContainer"},si={class:"title"},ai={class:"bodyContainer"},oi={class:"introduction"},ri={class:"introduction"},li={class:"floatingPointFormatSelection"},ci=["innerHTML"],ui={class:"solutionArea"},hi={class:"solutionInput"},di={class:"solutionInput"},mi={class:"solutionInput"},pi={style:{position:"relative"}},fi={id:"solution"},gi=["innerHTML"],bi=["innerHTML"];function vi(e,t,i,s,a,o){const r=(0,m.g2)("AttentionBanner"),l=(0,m.g2)("AccordionItem"),c=(0,m.g2)("Accordion");return(0,m.uX)(),(0,m.CE)("div",ni,[(0,m.Lk)("h3",si,(0,p.v_)(e.$t("conversion")),1),(0,m.Lk)("div",ai,[(0,m.Lk)("p",oi,(0,p.v_)(e.$t("fpConvIntro")),1),(0,m.Lk)("h4",null,(0,p.v_)(e.$t("fpformat")),1),(0,m.Lk)("p",ri,(0,p.v_)(e.$t("fpFormatSelectionSimple")),1),(0,m.Lk)("div",li,[(0,m.Lk)("div",{class:"formatContainer",onMousemove:t[3]||(t[3]=(...e)=>o.sliderMouseMove&&o.sliderMouseMove(...e))},[t[14]||(t[14]=(0,m.Lk)("div",{class:"sign"},"VB",-1)),(0,m.Lk)("div",{class:"exponent",style:(0,p.Tr)({width:60+this.exponentBits*(this.containerWidth/(this.numBits-1))+"px"})},[(0,m.Lk)("div",{onClick:t[0]||(t[0]=(...e)=>o.expandFraction&&o.expandFraction(...e)),class:"expandExponent"},t[12]||(t[12]=[(0,m.Lk)("div",{class:"arrowLeft"},[(0,m.Lk)("div",{class:"arrowMask"})],-1)])),(0,m.eW)(" E("+(0,p.v_)(a.exponentBits)+") ",1),(0,m.Lk)("div",{onMousedown:t[1]||(t[1]=(...e)=>o.sliderMouseDown&&o.sliderMouseDown(...e)),class:"slider"},null,32)],4),(0,m.Lk)("div",{class:"fraction",style:(0,p.Tr)({width:60+(this.numBits-this.exponentBits-1)*(this.containerWidth/(this.numBits-1))+"px"})},[(0,m.Lk)("div",{onClick:t[2]||(t[2]=(...e)=>o.expandExponent&&o.expandExponent(...e)),class:"expandFraction"},t[13]||(t[13]=[(0,m.Lk)("div",{class:"arrowRight"},[(0,m.Lk)("div",{class:"arrowMask"})],-1)])),(0,m.eW)(" M("+(0,p.v_)(a.numBits-a.exponentBits-1)+") ",1)],4)],32),(0,m.Lk)("div",{class:"mobile_formatContainer",onMousemove:t[6]||(t[6]=(...e)=>o.sliderMouseMove&&o.sliderMouseMove(...e))},[t[15]||(t[15]=(0,m.Lk)("div",{class:"mobile_sign"},"Sign(1)",-1)),(0,m.Lk)("div",{onClick:t[4]||(t[4]=(...e)=>o.expandExponent&&o.expandExponent(...e)),class:"mobile_exponent"}," Exponent("+(0,p.v_)(a.exponentBits)+") ↑ ",1),(0,m.Lk)("div",{onClick:t[5]||(t[5]=(...e)=>o.expandFraction&&o.expandFraction(...e)),class:"mobile_fraction"}," Mantisse("+(0,p.v_)(a.numBits-a.exponentBits-1)+") ↓ ",1)],32)]),(0,m.Lk)("h4",null,(0,p.v_)(e.$t("generateEx")),1),t[19]||(t[19]=(0,m.Lk)("div",{class:"divMargin"},null,-1)),(0,m.Lk)("button",{onClick:t[7]||(t[7]=(...e)=>o.generateExercise&&o.generateExercise(...e))},(0,p.v_)(e.$t("generate")),1),(0,m.Lk)("div",{id:"exerciseField",innerHTML:o.exerciseText},null,8,ci),(0,m.Lk)("h4",null,(0,p.v_)(e.$t("ownSolution")),1),(0,m.Lk)("div",ui,[(0,m.Lk)("div",hi,[(0,m.Lk)("p",null,(0,p.v_)(e.$t("signBit")),1),(0,m.bo)((0,m.Lk)("input",{id:"propVB",class:(0,p.C4)(a.backVB),"onUpdate:modelValue":t[8]||(t[8]=e=>a.propVB=e)},null,2),[[n.Jo,a.propVB]])]),t[16]||(t[16]=(0,m.Lk)("div",{class:"divMargin"},null,-1)),(0,m.Lk)("div",di,[(0,m.Lk)("p",null,(0,p.v_)(e.$t("exponentBits")),1),(0,m.bo)((0,m.Lk)("input",{id:"propE",class:(0,p.C4)(a.backE),"onUpdate:modelValue":t[9]||(t[9]=e=>a.propE=e)},null,2),[[n.Jo,a.propE]])]),t[17]||(t[17]=(0,m.Lk)("div",{class:"divMargin"},null,-1)),(0,m.Lk)("div",mi,[(0,m.Lk)("p",null,(0,p.v_)(e.$t("fractionBits")),1),(0,m.bo)((0,m.Lk)("input",{id:"propM",class:(0,p.C4)(a.backM),"onUpdate:modelValue":t[10]||(t[10]=e=>a.propM=e)},null,2),[[n.Jo,a.propM]])]),t[18]||(t[18]=(0,m.Lk)("div",{class:"divMargin"},null,-1)),(0,m.Lk)("button",{id:"checkSolution",onClick:t[11]||(t[11]=(...e)=>o.checkSolution&&o.checkSolution(...e))},(0,p.v_)(e.$t("check")),1)]),(0,m.Lk)("h4",null,(0,p.v_)(e.$t("correctSolution")),1),(0,m.Lk)("div",pi,[(0,m.bF)(r,{text:e.$t("attSolve")},null,8,["text"])]),(0,m.Lk)("div",fi,[(0,m.bF)(c,{solutionDescription:o.solDescr},{default:(0,m.k6)((()=>[((0,m.uX)(!0),(0,m.CE)(m.FK,null,(0,m.pI)(o.solDescr,(e=>((0,m.uX)(),(0,m.Wv)(l,{key:e.name},{"accordion-item-title":(0,m.k6)((()=>[(0,m.eW)((0,p.v_)(e.name),1)])),"accordion-item-body":(0,m.k6)((()=>[(0,m.Lk)("span",{innerHTML:e.text},null,8,gi),null!=e.subpanels?((0,m.uX)(),(0,m.Wv)(c,{key:0},{default:(0,m.k6)((()=>[((0,m.uX)(!0),(0,m.CE)(m.FK,null,(0,m.pI)(e.subpanels,(e=>((0,m.uX)(),(0,m.Wv)(l,{key:e.name},{"accordion-item-title":(0,m.k6)((()=>[(0,m.eW)((0,p.v_)(e.name),1)])),"accordion-item-body":(0,m.k6)((()=>[(0,m.Lk)("span",{innerHTML:e.text},null,8,bi)])),_:2},1024)))),128))])),_:2},1024)):(0,m.Q3)("",!0)])),_:2},1024)))),128))])),_:1},8,["solutionDescription"])])])])}var wi={name:"FloatingPointConversion",components:{Accordion:qe,AccordionItem:Ze,AttentionBanner:Fe},data(){const e=!1;let t=!1,i="";e&&window.sessionStorage.getItem("Conv_fp1")&&(i=window.sessionStorage.getItem("Conv_fp1"),t=!0);let n=5;e&&window.sessionStorage.getItem("Conv_expBits")&&(n=parseInt(window.sessionStorage.getItem("Conv_expBits"),10),t=!0);let s=16;return e&&window.sessionStorage.getItem("Conv_numBits")&&(s=parseInt(window.sessionStorage.getItem("Conv_numBits"),10),t=!0),{useCookies:e,selectedFormat:"",mouseDown:!1,solution:"",generated:!1,solutionObject:"",solutionSteps:[],exponentBits:n,numBits:s,containerWidth:500,watcher:"",propVB:"",backVB:"",propE:"",backE:"",propM:"",backM:"",fp1:i,default:t}},computed:{solDescr(){if(""===this.fp1)return[];const e=new Qe(this.exponentBits,this.numBits);e.decToBin(this.fp1.toString()),e.binToIEEE(e.result);const t=nt(this.exponentBits,e.result);console.log(t),this.setVariables(t),this.$nextTick((()=>{window.MathJax&&window.MathJax.typeset()}));const i=new at(this,this.exponentBits,this.numBits,"");return i.makeDescriptionConversion(this.solutionObject),i.result},exerciseText(){return""===this.fp1?"":`${this.$t("conversionExercise1")} \\( fp= \\text{${this.fp1}} \\) ${this.$t("conversionExercise2")} ${this.exponentBits}`}},mounted(){this.$nextTick((()=>{window.addEventListener("resize",(()=>{this.containerWidth=Math.min(500,window.innerWidth-250)})),window.addEventListener("unload",(()=>{this.containerWidth=Math.min(500,window.innerWidth-250)})),this.default&&(this.drawExercise(),this.generated=!0)}))},methods:{setVariables(e){this.solutionObject=e},saveVals(){this.useCookies&&(window.sessionStorage.setItem("Conv_fp1",this.fp1),window.sessionStorage.setItem("Conv_expBits",this.exponentBits),window.sessionStorage.setItem("Conv_numBits",this.numBits))},generateExercise(){let e=(Math.floor(100*Math.random())+Math.random()).toFixed(4);Math.random()<.5&&(e*=-1),this.fp1=e,this.generated=!0,this.saveVals()},checkSolution(){const e=new rt(this.exponentBits);e.checkSolution(this.solutionObject,this.propVB,this.propE,this.propM),this.backVB=e.backVB,this.backE=e.backE,this.backM=e.backM},preventGlobalMouseEvents(){document.body.style["pointer-events"]="none"},restoreGlobalMouseEvents(){document.body.style["pointer-events"]="auto"},mouseupListener(e){this.restoreGlobalMouseEvents(),document.removeEventListener("mouseup",this.mouseupListener,{capture:!0}),document.removeEventListener("mousemove",this.sliderMouseMove,{capture:!0}),e.stopPropagation(),this.mouseDown=!1},captureMouseEvents(e){this.preventGlobalMouseEvents(),document.addEventListener("mouseup",this.mouseupListener,{capture:!0}),document.addEventListener("mousemove",this.sliderMouseMove,{capture:!0}),e.preventDefault(),e.stopPropagation()},sliderMouseDown(e){this.mouseDown=!0,this.xCoord=e.pageX,this.captureMouseEvents(e)},sliderMouseMove(e){if(this.mouseDown){const t=this.containerWidth/(this.numBits-1);e.pageX-this.xCoord>t&&(this.xCoord+=t,this.exponentBits+1<this.numBits-1&&(this.exponentBits+=1)),this.xCoord-e.pageX>t&&(this.xCoord-=t,this.exponentBits>2&&(this.exponentBits-=1))}},expandFraction(){this.exponentBits=Math.max(this.exponentBits-1,2),this.generated&&this.saveVals()},expandExponent(){this.exponentBits=Math.min(this.exponentBits+1,this.numBits-2),this.generated&&this.saveVals()}}};const xi=(0,z.A)(wi,[["render",vi],["__scopeId","data-v-33c8e9d6"]]);var _i=xi;const $i=["conversion","exercises","arithmetic"];var yi=(0,m.pM)({name:"TinyTabs",components:{fpc:_i,fpe:ii,fpa:Bt,Tabs:a.Tabs,Tab:a.Tab,TabPanels:a.TabPanels,TabPanel:a.TabPanel},data(){return{selectedTab:"arithmetic"}},setup(){const e=(0,Q.Kh)({selectedTab:$i[1]});return{tabs:$i,...(0,Q.QW)(e)}}});const Ei=(0,z.A)(yi,[["render",Y]]);var Ci=Ei;const Mi={class:"polyadic"},ki={class:"title"},Ti={class:"title"},Si={class:"title"};function Ni(e,t,i,n,s,a){const o=(0,m.g2)("tab"),r=(0,m.g2)("tabs"),l=(0,m.g2)("pce"),c=(0,m.g2)("tab-panel"),u=(0,m.g2)("pcf"),h=(0,m.g2)("paf"),d=(0,m.g2)("tab-panels");return(0,m.uX)(),(0,m.CE)("div",Mi,[(0,m.bF)(r,{modelValue:e.selectedTab,"onUpdate:modelValue":t[0]||(t[0]=t=>e.selectedTab=t)},{default:(0,m.k6)((()=>[((0,m.uX)(!0),(0,m.CE)(m.FK,null,(0,m.pI)(e.tabs,((t,i)=>((0,m.uX)(),(0,m.Wv)(o,{key:`t${i}`,val:t,label:e.$t(t),indicator:!0},null,8,["val","label"])))),128))])),_:1},8,["modelValue"]),(0,m.bF)(d,{modelValue:e.selectedTab,"onUpdate:modelValue":t[1]||(t[1]=t=>e.selectedTab=t),animate:!1,swipeable:!1},{default:(0,m.k6)((()=>[(0,m.bF)(c,{val:"conversionExercise"},{default:(0,m.k6)((()=>[(0,m.Lk)("h3",ki,(0,p.v_)(e.$t("conversionExercise")),1),(0,m.bF)(l)])),_:1}),(0,m.bF)(c,{val:"conversion"},{default:(0,m.k6)((()=>[(0,m.Lk)("h3",Ti,(0,p.v_)(e.$t("conversion")),1),(0,m.bF)(u)])),_:1}),(0,m.bF)(c,{val:"arithmeticFree"},{default:(0,m.k6)((()=>[(0,m.Lk)("h3",Si,(0,p.v_)(e.$t("arithmetic")),1),(0,m.bF)(h)])),_:1})])),_:1},8,["modelValue"])])}const Bi={class:"fp-exercise pageContainer"},Fi={class:"bodyContainer"},Li={class:"introduction"},Ai=["innerHTML"],Vi={style:{position:"relative"}},Ii={id:"solution"},Di=["innerHTML"],Pi=["innerHTML"];function Oi(e,t,i,n,s,a){const o=(0,m.g2)("AttentionBanner"),r=(0,m.g2)("AccordionItem"),l=(0,m.g2)("Accordion");return(0,m.uX)(),(0,m.CE)("div",Bi,[(0,m.Lk)("div",Fi,[(0,m.Lk)("p",Li,(0,p.v_)(e.$t("polyConvGenIntro")),1),(0,m.Lk)("h4",null,(0,p.v_)(e.$t("generateEx")),1),(0,m.Lk)("button",{onClick:t[0]||(t[0]=(...e)=>a.generateExercise&&a.generateExercise(...e))},(0,p.v_)(e.$t("generate")),1),(0,m.Lk)("div",{id:"exerciseField",innerHTML:a.exerciseText},null,8,Ai),(0,m.Lk)("h4",null,(0,p.v_)(e.$t("correctSolution")),1),(0,m.Lk)("div",Vi,[(0,m.bF)(o,{text:e.$t("attSolve")},null,8,["text"])]),(0,m.Lk)("div",Ii,[(0,m.bF)(l,{solutionDescription:a.solDescr},{default:(0,m.k6)((()=>[((0,m.uX)(!0),(0,m.CE)(m.FK,null,(0,m.pI)(a.solDescr,(e=>((0,m.uX)(),(0,m.Wv)(r,{key:e.name},{"accordion-item-title":(0,m.k6)((()=>[(0,m.eW)((0,p.v_)(e.name),1)])),"accordion-item-body":(0,m.k6)((()=>[(0,m.Lk)("span",{innerHTML:e.text},null,8,Di),null!=e.subpanels?((0,m.uX)(),(0,m.Wv)(l,{key:0},{default:(0,m.k6)((()=>[((0,m.uX)(!0),(0,m.CE)(m.FK,null,(0,m.pI)(e.subpanels,(e=>((0,m.uX)(),(0,m.Wv)(r,{key:e.name},{"accordion-item-title":(0,m.k6)((()=>[(0,m.eW)((0,p.v_)(e.name),1)])),"accordion-item-body":(0,m.k6)((()=>[(0,m.Lk)("span",{innerHTML:e.text},null,8,Pi)])),_:2},1024)))),128))])),_:2},1024)):(0,m.Q3)("",!0)])),_:2},1024)))),128))])),_:1},8,["solutionDescription"])])])])}class ji{constructor(e,t){if(e<=1)throw new TypeError("Polyadic Number: Invalid power given, has to be greater 1.");if(this.power=16===e?16:e,this.comma=t.length,!this._checkArray(t))throw new TypeError("Polyadic Number: Invalid representation given.");this.arr=[...t],this._actualizeValues(),this.isNegative=!1,this.watcher=new ht}_actualizeValues(){this._checkArray(this.arr),this.value=this._getValue(),this.bitString=this.arr.join(""),this.valueString=this._constructValString()}_checkArray(e){this.comma=e.length;let t=0;for(let i=0;i<e.length;i+=1){if(e[i]<0||e[i]>=this.power)return!1;if((","===e[i]||"."===e[i])&&(this.comma=i,t+=1,t>1))return!1}return!0}_getValue(){let e=0;if("-"===this.arr[0]?(this.sign="-",e=1):"+"===this.arr[0]?(this.sign="+",e=1):this.sign="+",10===this.power)return parseFloat(this.arr.join(""));let t=0,i=0;for(let n=this.comma-1;n>=e;n-=1)t+=parseInt(this.arr[n],this.power)*this.power**i,i+=1;i=1;for(let n=this.comma+1;n<this.arr.length;n+=1)t+=parseInt(this.arr[n],this.power)*(1/this.power)**i,i+=1;return"-"===this.sign?-t:t}_constructValString(){return`${this.value}`}_additionOneDigit(e,t=0){const i=this.arr.join("").split(".");let n=[],s=[];Array.isArray(i)&&2===i.length?(n=i[0].split(""),s=i[1].split("")):n=i[0].split("");let a=0,o=e,r=!1;if(t<0){for(let e=0;e<Math.abs(t)+1-s.length;e+=1)s.push("0");for(let e=Math.abs(t)-1;e>=0;e-=1){let t=0;if(t=16===this.power?parseInt(s[e],16)+parseInt(o,16):parseInt(s[e],10)+parseInt(o,10),!(t>=this.power)){s[e]=t.toString(this.power).toUpperCase(),r=!0;break}a=t-this.power,s[e]=a.toString(this.power).toUpperCase(),o=1,this.watcher=this.watcher.step("constructResult").saveVariable(`overflowAfterComma${e}`,1)}}if(!r||t>=0){let e=n.length-1;if(t>=0){for(let e=0;e<t+1-n.length;e+=1)n.unshift("0");e=n.length-1-t}for(let t=e;t>=0;t-=1){let e=0;if(e=16===this.power?parseInt(n[t],16)+parseInt(o,16):parseInt(n[t],10)+parseInt(o,10),!(e>=this.power)){n[t]=e.toString(this.power).toUpperCase();break}a=e-this.power,n[t]=a.toString(this.power).toUpperCase(),o=1,this.watcher=this.watcher.step("constructResult").saveVariable(`overflowBeforeComma${t}`,1),0===t&&n.unshift("1")}}const l=[];n.map((e=>l.push(e))),Array.isArray(i)&&2===i.length&&(l.push("."),s.map((e=>l.push(e)))),this.arr=l}_subtractOneDigit(e,t=0){const i=this.arr.join("").split(".");let n=[],s=[];Array.isArray(i)&&2===i.length?(n=i[0].split(""),s=i[1].split("")):n=i[0].split("");let a=0,o=e;if(t>=0&&n.length<t+1){this.isNegative=!0;for(let e=0;e<t+1-n.length;e+=1)n.unshift("0")}else(t>=0&&n.length===t+1&&parseInt(n[t],this.power)-parseInt(o,this.power)<0||t<0&&0===n.length&&s.length+t<0)&&(this.isNegative=!0);let r=!1;if(this.watcher=this.watcher.step("constructResult").saveVariable("digit",e).saveVariable("exp",t),t<0){for(let e=0;e<Math.abs(t)-s.length;e+=1)s.push("0");for(let e=Math.abs(t)-1;e>=0;e-=1){let t=0;if(t=16===this.power?parseInt(s[e],16)-parseInt(o,16):parseInt(s[e],10)-parseInt(o,10),!(t<0)){s[e]=t.toString(this.power).toUpperCase(),r=!0,this.watcher=this.watcher.step("constructResult").saveVariable(`underflowAfterComma${e}`,0);break}a=Math.abs(t),s[e]=(this.power-a).toString(this.power).toUpperCase(),o=1,0===n.length&&(0===e||1===e&&"0"===s[0])&&(this.isNegative=!0),this.watcher=this.watcher.step("constructResult").saveVariable(`underflowAfterComma${e}`,1)}}if(!r||t>=0){let e=n.length-1;if(t>=0){for(let e=0;e<t+1-n.length;e+=1)n.unshift("0");e=n.length-1-t}for(let t=e;t>=0;t-=1){let e=0;if(e=16===this.power?parseInt(n[t],16)-parseInt(o,16):parseInt(n[t],10)-parseInt(o,10),!(e<0)){n[t]=e.toString(this.power).toUpperCase(),this.watcher=this.watcher.step("constructResult").saveVariable(`underflowBeforeComma${t}`,0);break}a=Math.abs(e),n[t]=(this.power-a).toString(this.power).toUpperCase(),o=1,(0===t||1===t&&"0"===n[0])&&(this.isNegative=!0),this.watcher=this.watcher.step("constructResult").saveVariable(`underflowBeforeComma${t}`,1)}}const l=[];n.map((e=>l.push(e))),Array.isArray(i)&&2===i.length&&(l.push("."),s.map((e=>l.push(e)))),this.arr=l}_additionFloat(e){this.watcher=this.watcher.step("Input").saveVariable("operator","+").saveVariable("bitString1",this.bitString).saveVariable("bitString2",e);const t=e.split(".");if(Array.isArray(t)&&2===t.length){const e=t[1].split("");this.watcher=this.watcher.step("Input").saveVariable("afterComma",[...e]);for(let t=e.length-1;t>=0;t-=1)this.watcher=this.watcher.step("constructResult").saveVariable(`digitAfterComma${t}`,e[t]).saveVariable(`expAfterComma${t}`,-t-1),this._additionOneDigit(e[t],-t-1)}const i=t[0].split("").reverse();this.watcher=this.watcher.step("Input").saveVariable("beforeComma",[...i].reverse());for(let n=0;n<i.length;n+=1)this.watcher=this.watcher.step("constructResult").saveVariable(`digitBeforeComma${n}`,i[n]).saveVariable(`expBeforComma${n}`,-n-1),this._additionOneDigit(i[n],n);this._actualizeValues(),this.watcher=this.watcher.step("Result").saveVariable("array",[...this.arr]).saveVariable("bitString",this.bitString).saveVariable("value",this.value).saveVariable("valueString",this.valueString).saveVariable("sign",this.sign).saveVariable("comma",this.comma)}_subtractionFloat(e){this.watcher=this.watcher.step("Input").saveVariable("operator","-").saveVariable("bitString1",this.bitString).saveVariable("bitString2",e);const t=e.toString().split(".");if(Array.isArray(t)&&2===t.length){const e=t[1].split("");this.watcher=this.watcher.step("Input").saveVariable("afterComma",[...e]);for(let t=e.length-1;t>=0;t-=1)this._subtractOneDigit(e[t],-t-1)}const i=t[0].split("").reverse();this.watcher=this.watcher.step("Input").saveVariable("beforeComma",[...i].reverse());const n=Math.max(i.length-this.comma,0);this.arr=Array(n).fill("0").concat(this.arr);for(let s=0;s<i.length;s+=1)this._subtractOneDigit(i[s],s);if(this.isNegative){this.arr[this.arr.length-1]=(parseInt(this.arr[this.arr.length-1],this.power)-1).toString(this.power).toUpperCase();for(let e=0;e<this.arr.length;e+=1){const t=this.arr[e];"-"!==t&&"."!==t&&","!==t&&(this.arr[e]=(this.power-parseInt(t,this.power)-1).toString(this.power).toUpperCase())}this.arr.unshift("-"),this.isNegative=!1}this._actualizeValues(),this.watcher=this.watcher.step("Result").saveVariable("array",[...this.arr]).saveVariable("bitString",this.bitString).saveVariable("value",this.value).saveVariable("valueString",this.valueString).saveVariable("sign",this.sign).saveVariable("comma",this.comma)}}class Ri{constructor(e,t){e.power!==t.power&&(console.log(`AdditionPolyadic(Number, Number): power of n1(${e.power})\n            and power of n2(${t.power}) not compatible.`),process.exit(1)),this.result=this._add(e,t),this.watcher=JSON.parse(JSON.stringify(this.result.watcher))}_add(e,t){let i="";if("+"===e.sign&&"+"===t.sign)i=new ji(e.power,e.bitString),i._additionFloat(t.bitString);else if("+"===e.sign&&"-"===t.sign){i=new ji(e.power,e.bitString);const n=t.bitString.substring(1);i._subtractionFloat(n)}else if("-"===e.sign&&"+"===t.sign){const n=t.bitString.substring(1),s=t.bitString.substring(1);s.shift();const a=new ji(e.power,n);a._additionFloat(s);let o=a.bitString;o=`-${o}`,i=new ji(e.power,o)}return i}getResult(){return this.result}}class zi{constructor(e,t){e.power!==t.power&&(console.log(`SubtractionPolyadic(Number, Number): power of n1(${e.power})\n            and power of n2(${t.power}) not compatible.`),process.exit(1)),this.result=this._sub(e,t),this.watcher=JSON.parse(JSON.stringify(this.result.watcher))}_sub(e,t){let i;if("+"===e.sign&&"+"===t.sign)i=new ji(e.power,e.bitString),i._subtractionFloat(t.bitString);else if("+"===e.sign&&"-"===t.sign){i=new ji(e.power,e.bitString);const n=t.bitString.substring(1);i._additionFloat(n)}else if("-"===e.sign&&"+"===t.sign){const n=e.bitString.substring(1),s=new ji(e.power,n);s._additionFloat(t.bitString);let a=s.bitString;a=`-${a}`,i=new ji(e.power,a)}return i}getResult(){return this.result}}class Wi{constructor(e,t){if(this.modus="",e.power===t&&console.log("ConversionPolyadicNumbers(Number, Int): Source and destination power is equal."),16===e.power&&2===t)this.watcher=new ht,this.watcher=this.watcher.step("Modus").saveVariable("modus","ShortcutHexToBin"),this.modus="ShortcutHexToBin",this.solution=this._shortcutHexToBin(e);else if(2===e.power&&16===t)this.watcher=new ht,this.watcher=this.watcher.step("Modus").saveVariable("modus","ShortcutBinToHex"),this.modus="ShortcutBinToHex",this.solution=this._shortcutBinToHex(e);else if(this.watcher=[new ht,new ht],10===t)this.watcher[0]=this.watcher[0].step("Modus").saveVariable("modus","PowerToTen"),this.modus="PowerToTen",this.solution=this._convertPowerToTen(e);else if(10===e.power)this.watcher[1]=this.watcher[1].step("Modus").saveVariable("modus","TenToPower"),this.modus="TenToPower",this.solution=this._convertTenToPower(e,t);else{this.watcher[0]=this.watcher[0].step("Modus").saveVariable("modus","PowerToPower"),this.modus="PowerToPower",this.watcher[1]=this.watcher[1].step("Modus").saveVariable("modus","PowerToPower");const i=this._convertPowerToTen(e);this.solution=this._convertTenToPower(i,t)}}_convertPowerToTen(e){this.watcher[0]=this.watcher[0].step("Input").saveVariable("number",e);let t=0;"-"===e.arr[0]?(this.sign="-",t=1):"+"===e.arr[0]?(this.sign="+",t=1):this.sign="+",this.watcher[0]=this.watcher[0].step("ConstructNumber").saveVariable("sign",this.sign);let i=0,n=0;for(let a=e.comma-1;a>=t;a-=1){const t=parseInt(e.arr[a],e.power)*e.power**n;i+=t,this.watcher[0]=this.watcher[0].step("ConstructNumber").saveVariable(`beforeComma${n}In`,e.arr[a]).saveVariable(`beforeComma${n}Res`,t),n+=1}this.watcher[0]=this.watcher[0].step("ConstructNumber").saveVariable("stepsBeforeComma",n),n=1;for(let a=e.comma+1;a<e.arr.length;a+=1){const t=parseInt(e.arr[a],e.power)*(1/e.power)**n;i+=t,this.watcher[0]=this.watcher[0].step("ConstructNumber").saveVariable(`afterComma${n-1}In`,e.arr[a]).saveVariable(`afterComma${n-1}Res`,t),n+=1}if(this.watcher[0]=this.watcher[0].step("ConstructNumber").saveVariable("stepsAfterComma",n-1),"-"===this.sign){const e=new ji(10,(-i).toString());return this.watcher[0]=this.watcher[0].step("Result").saveVariable("resultValue",-i).saveVariable("resultNumber",e),e}const s=new ji(10,i.toString());return this.watcher[0]=this.watcher[0].step("Result").saveVariable("resultValue",i).saveVariable("resultNumber",s),s}_convertTenToPower(e,t){this.watcher[1]=this.watcher[1].step("Input").saveVariable("number",e).saveVariable("power",t),this.watcher[1]=this.watcher[1].step("ConstructNumber").saveVariable("sign",e.sign);const i=Math.floor(Math.abs(e.value));let n="",s=0,a=[i,1];this.watcher[1]=this.watcher[1].step("ConstructNumber").saveVariable("beforeCommaVal",i);while(a[0]>0)a=this._divisionWithRemain(a[0],t,10),this.watcher[1]=this.watcher[1].step("ConstructNumber").saveVariable(`beforeComma${s}Div`,a[0]).saveVariable(`beforeComma${s}Remain`,a[1]),s+=1,16===t&&(a[1]=a[1].toString(16).toUpperCase()),n=a[1]+n;this.watcher[1]=this.watcher[1].step("ConstructNumber").saveVariable("stepsBeforeComma",s),0===s&&(n="0");let o,r="";if(s=0,e.value.toString().indexOf(".")>=0){const n=e.value.toString().split(".")[1].length;a=[(Math.abs(e.value)-i).toFixed(n),1];const o=[a[0]];this.watcher[1]=this.watcher[1].step("ConstructNumber").saveVariable("isPeriodic",!1).saveVariable("periodicStart",0).saveVariable("periodicEnd",9).saveVariable("afterCommaVal",a[0]);while(a[0]>0&&s<9){a=this._multiplicationStepFrom10(a[0],t,n),this.watcher[1]=this.watcher[1].step("ConstructNumber").saveVariable(`afterComma${s}Mul`,a[0]).saveVariable(`afterComma${s}Remain`,a[1]),16===t&&(a[1]=a[1].toString(16).toUpperCase()),r+=a[1];const e=o.indexOf(a[0].toString());if(e>=0){this.watcher[1]=this.watcher[1].step("ConstructNumber").saveVariable("isPeriodic",!0).saveVariable("periodicStart",e).saveVariable("periodicEnd",s),s+=1;break}o.push(a[0].toString()),s+=1}}this.watcher[1]=this.watcher[1].step("ConstructNumber").saveVariable("stepsAfterComma",s),o=""!==r?`${n}.${r}`:n,"-"===e.sign&&(o=`-${o}`);const l=new ji(t,o);return this.watcher[1]=this.watcher[1].step("Result").saveVariable("resultValue",o).saveVariable("resultNumber",l),l}_divisionWithRemain(e,t,i){let n=0,s=0;while(parseInt((n*t).toString(10),i)<=e)s=parseInt((e-parseInt((n*t).toString(10),i)).toString(10),i),n+=1;return[n-1,s]}_multiplicationStepFrom10(e,t,i){const n=parseFloat((parseFloat(e)*parseFloat(t)).toFixed(i));return n>=1?[parseFloat((n-Math.floor(n)).toFixed(i)),Math.floor(n)]:[n,0]}_shortcutHexToBin(e){this.watcher=this.watcher.step("Input").saveVariable("number",e),"-"===e.arr[0]?this.sign="-":(e.arr[0],this.sign="+"),this.watcher=this.watcher.step("ConstructNumber").saveVariable("sign",this.sign);const t=e.arr;"-"!==e.arr[0]&&"+"!==e.arr[0]||t.shift();let i="",n=!1,s=0;t.forEach((e=>{if("."===e)i+=".",n=!0,this.watcher=this.watcher.step("ConstructNumber").saveVariable("stepsBeforeComma",s),s=0;else{const t=parseInt(e,16).toString(2).padStart(4,"0");i+=t,this.watcher=n?this.watcher.step("ConstructNumber").saveVariable(`afterComma${s}`,t):this.watcher.step("ConstructNumber").saveVariable(`beforeComma${s}`,t),s+=1}})),this.watcher=n?this.watcher.step("ConstructNumber").saveVariable("stepsAfterComma",s):this.watcher.step("ConstructNumber").saveVariable("stepsBeforeComma",s).saveVariable("stepsAfterComma",0),"-"===this.sign&&(i=`-${i}`);const a=new ji(2,i);return this.watcher=this.watcher.step("Result").saveVariable("resultValue",i).saveVariable("resultNumber",a),a}_shortcutBinToHex(e){this.watcher=this.watcher.step("Input").saveVariable("number",e),"-"===e.arr[0]?this.sign="-":(e.arr[0],this.sign="+");let t=e.comma,i=e.arr.join("");if("-"!==e.arr[0]&&"+"!==e.arr[0]||(i=i.slice(1),t-=1),t<i.length-1){const e=i.length,n=t,s=e-t-1;let a="";if(n%4!==0)for(let t=0;t<4-n%4;t+=1)a+="0";let o="";if(s%4!==0)for(let t=0;t<4-s%4;t+=1)o+="0";i=a+i+o}else{let e="";if(t%4!==0)for(let i=0;i<4-t%4;i+=1)e+="0";i=e+i}let n="",s=!1,a=0,o="",r=0;while(r<=i.length)if(o.length<4&&"."!==i[r])o+=i[r],r+=1;else if(0===o.length&&"."===i[r])n+=".",s=!0,this.watcher=this.watcher.step("ConstructNumber").saveVariable("stepsBeforeComma",a),a=0,r+=1;else{const e=parseInt(o,2).toString(16).toUpperCase();n+=e,this.watcher=s?this.watcher.step("ConstructNumber").saveVariable(`afterComma${a}Bin`,o).saveVariable(`afterComma${a}Hex`,e):this.watcher.step("ConstructNumber").saveVariable(`beforeComma${a}Bin`,o).saveVariable(`beforeComma${a}Hex`,e),o="",a+=1}this.watcher=s?this.watcher.step("ConstructNumber").saveVariable("stepsAfterComma",a):this.watcher.step("ConstructNumber").saveVariable("stepsBeforeComma",a).saveVariable("stepsAfterComma",0),"-"===this.sign&&(n=`-${n}`);const l=new ji(16,n);return this.watcher=this.watcher.step("Result").saveVariable("resultValue",n).saveVariable("resultNumber",l),l}}function qi(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}class Hi{constructor(){qi(this,Hi),this.result="",this.resultObject="",this.watcher="",this.modus=""}convertFormat(e,t,i){if(""!==e){const n=new ji(t,e.toString(t)),s=new Wi(n,i);this.modus=s.modus,this.result=s.solution.bitString,this.watcher=s.watcher,Array.isArray(this.watcher)?"PowerToTen"===this.modus?this.resultObject=this.watcher[0].steps.Result.data.resultNumber:this.resultObject=this.watcher[1].steps.Result.data.resultNumber:this.resultObject=this.watcher.steps.Result.data.resultNumber}}calcArithmeticSolution(e,t,i,n){const s=new ji(i,e.toString(i)),a=new ji(i,t.toString(i));switch(n){case"add":const e=new Ri(s,a);this.result=e.result.bitString,this.resultObject=e.result,this.watcher=JSON.parse(JSON.stringify(e.watcher));break;case"sub":const t=new zi(s,a);this.result=t.result.bitString,this.resultObject=t.result,this.watcher=JSON.parse(JSON.stringify(t.watcher));break;default:}}}function Ui(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}class Ki{constructor(e,t){Ui(this,Ki),this.imp=e,this.tableTenToPowerBeforeComma="",this.tableTenToPowerAfterComma="",this.tablePowerToTen="",this.tableShortcut="",this.result=[],this.watcher=t}getTableTenToPowerBeforeComma(){const e="{ccccccc}",t=[],i=this.watcher[1].steps.ConstructNumber.data.stepsBeforeComma;if(0===i)this.tableTenToPowerBeforeComma=`\\text{${this.imp.$t("noValuesBeforeComma")}}`;else{t.push(`\\begin{array} ${e}`),t.push(`${this.imp.$t("numerator")}&:&${this.imp.$t("newBasis")}`),t.push(`&=&${this.imp.$t("quotient")}&+&${this.imp.$t("remainder")}\\\\ \\hline `);let n=this.watcher[1].steps.ConstructNumber.data.beforeCommaVal;const s=this.watcher[1].steps.Input.data.power;let a=this.watcher[1].steps.ConstructNumber.data.beforeComma0Div,o=this.watcher[1].steps.ConstructNumber.data.beforeComma0Remain;t.push(`${n}&:&${s}&=&${a}&+&${o}\\\\`),n=a;for(let e=1;e<i;e+=1)a=this.watcher[1].steps.ConstructNumber.data[`beforeComma${e}Div`],o=this.watcher[1].steps.ConstructNumber.data[`beforeComma${e}Remain`],t.push(`${n}&:&${s}&=&${a}&+&${o}\\\\`),n=a;t.push("\\end{array}"),this.tableTenToPowerBeforeComma=t.join("")}}getTableTenToPowerAfterComma(){const e="{ccccccc}",t=[],i=this.watcher[1].steps.ConstructNumber.data.isPeriodic,n=this.watcher[1].steps.ConstructNumber.data.periodicStart,s=this.watcher[1].steps.ConstructNumber.data.periodicEnd;if(0===this.watcher[1].steps.ConstructNumber.data.stepsAfterComma)this.tableTenToPowerAfterComma=`\\text{${this.imp.$t("noValuesAfterComma")}}`;else{const a=Math.min(this.watcher[1].steps.ConstructNumber.data.stepsAfterComma-1,s);t.push(`\\begin{array} ${e}`),t.push(`${this.imp.$t("factor")}&*&${this.imp.$t("newBasis")}`),t.push(`&=&${this.imp.$t("quotient")}&+&${this.imp.$t("remainder")}\\\\ \\hline `);let o=this.watcher[1].steps.ConstructNumber.data.afterCommaVal;const r=this.watcher[1].steps.Input.data.power;for(let e=0;e<=a;e+=1){const s=this.watcher[1].steps.ConstructNumber.data[`afterComma${e}Mul`],a=this.watcher[1].steps.ConstructNumber.data[`afterComma${e}Remain`];i&&e>=n?t.push(`${o}&*&${r}&=&${s}&+&\\overline{${a}}\\\\`):t.push(`${o}&*&${r}&=&${s}&+&${a}\\\\`),o=s}t.push("\\end{array}"),this.tableTenToPowerAfterComma=t.join("")}}getTablePowerToTen(){const e=this.watcher[0].steps.Input.data.number.power,t=this.watcher[0].steps.ConstructNumber.data.stepsBeforeComma,i=this.watcher[0].steps.ConstructNumber.data.stepsAfterComma,n=this.watcher[0].steps.Result.data.resultValue,s="{c|cc}",a=[];a.push(`\\begin{array} ${s}`),a.push(`${this.imp.$t("calcStep")}&&${this.imp.$t("summands")}\\\\ \\hline `);for(let o=t-1;o>=0;o-=1){const t=[this.watcher[0].steps.ConstructNumber.data[`beforeComma${o}In`],`* ${e}^${o}`].join(""),n=`${this.watcher[0].steps.ConstructNumber.data[`beforeComma${o}Res`]}`;0===o&&0===i?a.push(`${t}&+&${n}\\\\`):a.push(`${t}&&${n}\\\\`)}for(let o=0;o<i;o+=1){const t=[this.watcher[0].steps.ConstructNumber.data[`afterComma${o}In`],`* \\frac{1}{${e}^${o+1}}`].join(""),n=`${this.watcher[0].steps.ConstructNumber.data[`afterComma${o}Res`]}`;o!==i-1?a.push(`${t}&&${n}\\\\`):a.push(`${t}&+&${n}\\\\`)}a.push("\\hline"),a.push(`&&${n}`),a.push("\\end{array}"),this.tablePowerToTen=a.join("")}getTableShortcutHexToBin(){const e=this.watcher.steps.ConstructNumber.data.stepsBeforeComma,t=this.watcher.steps.ConstructNumber.data.stepsAfterComma,i=this.watcher.steps.ConstructNumber.data.sign;let n=this.watcher.steps.Input.data.number.bitString;const s=["{"];"-"===i&&s.push("c");for(let l=0;l<e;l+=1)s.push("c|");if(t>0){s.push("c|");for(let e=1;e<t;e+=1)s.push("c|")}s[s.length-1]=s[s.length-1].substring(0,s[s.length-1].length-1),s.push("}");const a=[];a.push(`\\begin{array} ${s.join("")}`);const o=[];"-"===i&&(o.push("- \\Big(&"),n=n.substring(1));for(let l=0;l<e;l+=1)o.push(`${n[l]}&`);if(t>0){o.push(".&");for(let i=e+1;i<=t+e;i+=1)o.push(`${n[i]}&`)}o[o.length-1]=o[o.length-1].substring(0,o[o.length-1].length-1),"-"===i&&o.push("\\Big)"),o.push("\\\\ \\hline "),a.push(o.join(""));const r=[];"-"===i&&r.push("- \\Big(&");for(let l=0;l<e;l+=1)r.push([this.watcher.steps.ConstructNumber.data[`beforeComma${l}`],"&"].join(""));if(t>0){r.push(".&");for(let e=0;e<t;e+=1)r.push([this.watcher.steps.ConstructNumber.data[`afterComma${e}`],"&"].join(""))}r[r.length-1]=r[r.length-1].substring(0,r[r.length-1].length-1),"-"===i&&r.push("\\Big)"),a.push(r.join("")),a.push("\\end{array}"),this.tableShortcut=a.join("")}getTableShortcutBinToHex(){const e=this.watcher.steps.ConstructNumber.data.stepsBeforeComma,t=this.watcher.steps.ConstructNumber.data.stepsAfterComma,i=this.watcher.steps.ConstructNumber.data.sign,n=["{"];"-"===i&&n.push("c");for(let r=0;r<e;r+=1)n.push("c|");if(t>0){n.push("c|");for(let e=0;e<t;e+=1)n.push("c|")}n[n.length-1]=n[n.length-1].substring(0,n[n.length-1].length-1),n.push("}");const s=[];s.push(`\\begin{array} ${n.join("")}`);const a=[];"-"===i&&a.push("- \\Big(&");for(let r=0;r<e;r+=1)a.push([this.watcher.steps.ConstructNumber.data[`beforeComma${r}Bin`],"&"].join(""));if(t>0){a.push(".&");for(let e=0;e<t;e+=1)a.push([this.watcher.steps.ConstructNumber.data[`afterComma${e}Bin`],"&"].join(""))}a[a.length-1]=a[a.length-1].substring(0,a[a.length-1].length-1),"-"===i&&a.push("\\Big)"),a.push("\\\\ \\hline "),s.push(a.join(""));const o=[];"-"===i&&o.push("- \\Big(&");for(let r=0;r<e;r+=1)o.push([this.watcher.steps.ConstructNumber.data[`beforeComma${r}Hex`],"&"].join(""));if(t>0){o.push(".&");for(let e=0;e<t;e+=1)o.push([this.watcher.steps.ConstructNumber.data[`afterComma${e}Hex`],"&"].join(""))}o[o.length-1]=o[o.length-1].substring(0,o[o.length-1].length-1),"-"===i&&o.push("\\Big)"),s.push(o.join("")),s.push("\\end{array}"),this.tableShortcut=s.join("")}makeDescription(e,t){let i;i=Array.isArray(this.watcher)?"PowerToTen"===e?this.watcher[0].steps.Result.data.resultNumber:this.watcher[1].steps.Result.data.resultNumber:this.watcher.steps.Result.data.resultNumber,"ShortcutHexToBin"===e?(this.getTableShortcutHexToBin(),this.result.push({name:`${this.imp.$t("conversion")}`,text:`${this.imp.$t("shortcutHexToBin")}`,subpanels:[{name:`${this.imp.$t("doConversion")}`,text:`\\(${this.tableShortcut}\\)`}]})):"ShortcutBinToHex"===e?(this.getTableShortcutBinToHex(),this.result.push({name:`${this.imp.$t("conversion")}`,text:`${this.imp.$t("shortcutBinToHex")}`,subpanels:[{name:`${this.imp.$t("doConversion")}`,text:`\\(${this.tableShortcut}\\)`}]})):"PowerToTen"===e?(this.getTablePowerToTen(),this.result.push({name:`${this.imp.$t("conversion")}`,text:`${this.imp.$t("PowerToTen")}`,subpanels:[{name:`${this.imp.$t("summation")}`,text:`\\(${this.tablePowerToTen}\\)`}]})):"TenToPower"===e?(this.getTableTenToPowerBeforeComma(),this.getTableTenToPowerAfterComma(),console.log(this.tableTenToPowerBeforeComma),this.result.push({name:`${this.imp.$t("conversion")}`,text:`${this.imp.$t("TenToPower")}`,subpanels:[{name:`1) ${this.imp.$t("divisionAlgorithm")}`,text:`\\(${this.tableTenToPowerBeforeComma}\\)</br></br> ${this.imp.$t("polyadicDivisionDescription")}`},{name:`2) ${this.imp.$t("multiplicationAlgorithm")}`,text:`\\(${this.tableTenToPowerAfterComma}\\)</br></br> ${this.imp.$t("polyadicMultiplicationDescription")}`}]})):"PowerToPower"===e?(this.getTablePowerToTen(),this.getTableTenToPowerBeforeComma(),this.getTableTenToPowerAfterComma(),console.log(this.tableTenToPowerBeforeComma),this.result.push({name:`${this.imp.$t("conversion")}`,text:`${this.imp.$t("PowerToPower")}`,subpanels:[{name:`1) ${this.imp.$t("summation")}`,text:`\\(${this.tablePowerToTen}\\)`},{name:`2) ${this.imp.$t("divisionAlgorithm")}`,text:`\\(${this.tableTenToPowerBeforeComma}\\)</br></br> ${this.imp.$t("polyadicDivisionDescription")}`},{name:`3) ${this.imp.$t("multiplicationAlgorithm")}`,text:`\\(${this.tableTenToPowerAfterComma}\\)</br></br> ${this.imp.$t("polyadicMultiplicationDescription")}`}]})):console.log("FAILURE: Not implemented Modus!");let n=i.bitString;if("PowerToPower"===e||"TenToPower"===e){const e=this.watcher[1].steps.ConstructNumber.data.isPeriodic;if(e){const e=this.watcher[1].steps.ConstructNumber.data.periodicStart,t=this.watcher[1].steps.ConstructNumber.data.periodicEnd,i=n.split(".");let s=`${i[0]}.`;for(let n=0;n<e;n+=1)s+=i[1][n];s+="\\overline{";for(let n=e;n<=t;n+=1)s+=i[1][n];s+="}",n=s}}this.result.push({name:this.imp.$t("solution"),text:[`${this.imp.$t("solution")}: `,`\\(${n}\\) `,`\\(\\hspace{2cm} \\)${this.imp.$t("value")} (${this.imp.$t("decimal")}): \\(${i.value}\\)`].join("")})}}function Gi(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}class Xi{constructor(e,t){Gi(this,Xi),this.imp=e,this.watcher=t,this.modus=this.imp.modus,this.description=new Ki(this.imp,this.watcher),this.description.makeDescription(this.modus,this.imp.selectedFormat)}getStyle(){let e="";e+="<style scoped>",e+=".MathJax { font-size: 11px !important; } ",e+="#body { size: A4; padding-top: 2cm; margin-top: 2cm; margin-bottom: 0.5cm; }",e+="#page :first { size: A4; margin-top: 0; margin-bottom: 0.5cm; }",e+="#header1 { color: black; font-family: arial; font-size: 28px; font-weight: bold;break-after: always; margin-left: auto; margin-right: auto; margin-bottom: 0.5cm;margin-top: 0.5cm} ",e+="#header2 { color: black; font-family: arial; font-size: 16px; font-weight: bold;text-align: left; margin-left: 1cm; margin-right: 1cm; margin-top: 0.5cm} ",e+="#header3 { color: black; font-family: arial; font-size: 13px;  text-align: left;margin-left: 0; margin-right: 0; margin-top: 0.5cm; margin-bottom: 0.25cm;font-style: italic} ",e+="#txt { color: black; font-family: arial; font-size: 12px; text-align: left;margin-left: 1cm; margin-right: 1cm} ",e+="#ctr { color: black; font-family: arial; font-size: 12px; text-align: center; margin-left: auto; margin-right: auto} ",e+="ul, ol{ display: block; list-style-type: decimal; list-style-type: disc;  margin-top: 1em; margin-bottom: 1em; margin-left: 1cm; margin-right: 1cm;padding-left: 0.3cm;}",e+="li { color: black; font-family: arial; font-size: 12px; text-align: left;} ",e+="#tab1 { width:60%; border-spacing: 5px; padding: 15px;border-collapse: collapse; margin-left:auto; margin-right:auto; text-align: center} ",e+="th { font-weight: bold; text-size: 12px; font-family: arial;border-bottom: 1px solid gray} ",e+="tr, td { text-size: 12px; font-family: arial} ",e+="td:first-child, th:first-child { text-size: 12px; border-right: 1px solid gray} ",e+="#page-break { display: block; page-break-before: always; padding-bottom: 2cm} ",e+="#foot { position: fixed; left: 0; bottom: 0; width: auto; color: lightgray; text-align: center; margin-bottom: 0.7cm; margin-left: 0.7cm; margin-right: 0.7cm; font-size: 10px; border-top: 1px solid lightgray} ",e+="</style>",this.style=e}getHeader(){let e="";e+=`<div id="header1">${this.imp.$t("gti")}</div>`,e+=`<ctr>${this.imp.$t("example")} ${this.imp.$t("approach")}: ${this.imp.$t("conversion")} \\( ${this.imp.inputNum} \\) ${this.imp.$t(`${this.imp.selectedFormat[0]}`)} \\(\\rightarrow\\) ${this.imp.$t(`${this.imp.selectedFormat[1]}`)}</ctr>`,this.header=e}getDisclaimer(){let e="";e+=`<div id="foot">${this.imp.$t("disclaimer")}</div>`,this.disclaimer=e}getValues(){let e="";e+=`<div id="header2">${this.imp.$t("values")}</div>`,e+='<table id="tab1">',e+="<tr>",e+="<th></th>",e+=`<th>${this.imp.$t("values")}</th>`,e+="</tr>",e+="<tr>",e+=`<td>${this.imp.$t("number")}</td>`,e+=`<td>${this.imp.inputNum}</td>`,e+="</tr>",e+="<tr>",e+=`<td>${this.imp.$t("firstFormat")}</td>`,e+=`<td>${this.imp.$t(this.imp.selectedFormat[0])}</td>`,e+="</tr>",e+="<tr>",e+=`<td>${this.imp.$t("secondFormat")}</td>`,e+=`<td>${this.imp.$t(this.imp.selectedFormat[1])}</td>`,e+="</tr>",e+="</table>",this.values=e}generatePdf(e="PolyadicNumbers"){let t;t=Array.isArray(this.imp.watcher)?"PowerToTen"===this.modus?this.imp.watcher[0].steps.Result.data.resultNumber:this.imp.watcher[1].steps.Result.data.resultNumber:this.imp.watcher.steps.Result.data.resultNumber,this.getStyle(),this.getHeader(),this.getDisclaimer(),this.getValues();let i="<style scoped>#scoped-content { width:100%; justify-content: center; }</style>";i+='<div id="scoped-content">',i+=this.style,i+=this.header,i+=this.values,i+=`<div id="header2">${this.imp.$t("conversion")}</div>`,i+="<ul>","ShortcutHexToBin"===this.modus?(this.description.getTableShortcutHexToBin(),i+=`<div style="margin-bottom:1cm;">${this.imp.$t("shortcutHexToBin")}</div>`,i+='<div id="ctr">\\(',i+=this.description.tableShortcut,i+="\\)</div>"):"ShortcutBinToHex"===this.modus?(this.description.getTableShortcutBinToHex(),i+=`<div style="margin-bottom:1cm;">${this.imp.$t("shortcutBinToHex")}</div>`,i+='<div id="ctr">\\(',i+=this.description.tableShortcut,i+="\\)</div>"):"PowerToTen"===this.modus?(this.description.getTablePowerToTen(),i+=`<div style="margin-bottom:1cm;">${this.imp.$t("PowerToTen")}</div>`,i+='<div id="ctr">\\(',i+=this.description.tablePowerToTen,i+="\\)</div>"):"TenToPower"===this.modus?(this.description.getTableTenToPowerBeforeComma(),this.description.getTableTenToPowerAfterComma(),i+=`<div style="margin-bottom:1cm;">${this.imp.$t("TenToPower")}</div>`,i+=`<li><div id="header3">${this.imp.$t("divisionAlgorithm")} :</div>`,i+='<div id="ctr">\\(',i+=this.description.tableTenToPowerBeforeComma,i+="\\)</div>",i+="</li>",i+=`<li><div id="header3">${this.imp.$t("multiplicationAlgorithm")} :</div>`,i+='<div id="ctr">\\(',i+=this.description.tableTenToPowerAfterComma,i+="\\)</div>",i+="</li>"):"PowerToPower"===this.modus?(this.description.getTablePowerToTen(),this.description.getTableTenToPowerBeforeComma(),this.description.getTableTenToPowerAfterComma(),i+=`<div style="margin-bottom:1cm;">${this.imp.$t("PowerToPower")}</div>`,i+=`<li><div id="header3">${this.imp.$t("summation")} :</div>`,i+='<div id="ctr">\\(',i+=this.description.tablePowerToTen,i+="\\)</div>",i+="</li>",i+=`<li><div id="header3">${this.imp.$t("divisionAlgorithm")} :</div>`,i+='<div id="ctr">\\(',i+=this.description.tableTenToPowerBeforeComma,i+="\\)</div>",i+="</li>",i+=`<li><div id="header3">${this.imp.$t("multiplicationAlgorithm")} :</div>`,i+='<div id="ctr">\\(',i+=this.description.tableTenToPowerAfterComma,i+="\\)</div>",i+="</li>"):console.log("FAILURE: Not implemented Modus!"),i+="</ul>",i+="</div>";let n=t.bitString;if("PowerToPower"===this.modus||"TenToPower"===this.modus){const e=this.imp.watcher[1].steps.ConstructNumber.data.isPeriodic;if(e){const e=this.imp.watcher[1].steps.ConstructNumber.data.periodicStart,t=this.imp.watcher[1].steps.ConstructNumber.data.periodicEnd,i=n.split(".");let s=`${i[0]}.`;for(let n=0;n<e;n+=1)s+=i[1][n];s+="\\overline{";for(let n=e;n<=t;n+=1)s+=i[1][n];s+="}",n=s}}i+=`<div id="header2">${this.imp.$t("solution")}</div>`,i+=`${this.imp.$t("correctSolution")}: \\(${n}\\) &ensp;`,i+=`${this.imp.$t("value")}: \\(${t.value}\\)`,i+=this.disclaimer,this.string=i;const s=this.string,a=ou.resolve({name:e});ou.replace({name:"DescriptionPDF",params:{math:s,returnRoute:a.href}})}}function Zi(e){switch(e){case"binary":return 2;case"ternary":return 3;case"quaternary":return 4;case"quinary":return 5;case"senary":return 6;case"septenary":return 7;case"octal":return 8;case"novenary":return 9;case"decimal":return 10;case"hex":return 16;default:return 0}}var Ji={name:"PolyadicConversionExercise",components:{Accordion:qe,AccordionItem:Ze,AttentionBanner:Fe},data(){return{selectedFormat:["decimal","binary"],power:[10,10],mouseDown:!1,solution:"",generated:!1,solutionObject:"",solutionSteps:[],containerWidth:500,watcher:"",prop:"",back:"",inputNum:"",modus:""}},computed:{falseFormatOutput(){return this.$t("falseFormat")},solDescr(){return this.solutionSteps},formatOptions(){return{decimal:`${this.$t("decimal")} (${this.$t("systemInBase")}  10)`,binary:`${this.$t("binary")} (${this.$t("systemInBase")} 2)`,ternary:`${this.$t("ternary")} (${this.$t("systemInBase")} 3)`,quaternary:`${this.$t("quaternary")} (${this.$t("systemInBase")} 4)`,quinary:`${this.$t("quinary")} (${this.$t("systemInBase")} 5)`,senary:`${this.$t("senary")} (${this.$t("systemInBase")} 6)`,septenary:`${this.$t("septenary")} (${this.$t("systemInBase")} 7)`,octal:`${this.$t("octal")} (${this.$t("systemInBase")} 8)`,novenary:`${this.$t("novenary")} (${this.$t("systemInBase")} 9)`,hex:`${this.$t("hexadecimal")} (${this.$t("systemInBase")} 16)`}},exerciseText(){return""===this.inputNum?"":`${this.$t("polyadicExercise1")} ${this.formatOptions[this.selectedFormat[0]]} ${this.inputNum} ${this.$t("polyadicExercise3")} ${this.formatOptions[this.selectedFormat[1]]}.`}},mounted(){this.$nextTick((()=>{window.addEventListener("resize",(()=>{this.containerWidth=Math.min(500,window.innerWidth-250)})),window.addEventListener("unload",(()=>{this.containerWidth=Math.min(500,window.innerWidth-250)})),this.default&&(this.recalculate(),this.drawExercise(),this.generated=!0)}))},methods:{recalculate(){this.computeSolution(),this.$nextTick((()=>{window.MathJax&&window.MathJax.typeset()}))},drawExercise(){this.$nextTick((()=>{window.MathJax&&window.MathJax.typeset()}))},generateExercise(){const e=Object.keys(this.formatOptions),t=e[Math.floor(Math.random()*e.length)],i=e.indexOf(t);i>-1&&e.splice(i,1);const n=e[Math.floor(Math.random()*e.length)];this.selectedFormat=[t,n];let s="";const a=Math.floor(1+3*Math.random()),o=Math.floor(4*Math.random());this.power[0]=Zi(t),this.power[1]=Zi(n);const r=[];for(let l=0;l<this.power[0];l+=1)r.push(l.toString(this.power[0]));if(a>0)for(let l=0;l<a;l+=1)s+=r[Math.floor(Math.random()*r.length)];else s="0";if(s=s.replace(/^0+(?=\d)/,""),o>0){s+=".";for(let e=0;e<o;e+=1)s+=r[Math.floor(Math.random()*r.length)]}(o>0||o>0)&&Math.random()<.5&&(s=`-${s}`),s=s.toUpperCase(),this.inputNum=s,this.generated=!0,this.recalculate(),this.drawExercise()},downloadPdf(){this.recalculate();const e=new Xi(this,this.watcher);e.generatePdf()},computeSolution(){const e=new Hi;e.convertFormat(this.inputNum,this.power[0],this.power[1]),this.watcher=JSON.parse(JSON.stringify(e.watcher)),this.solution=e.result;const t=new Ki(this,this.watcher);t.makeDescription(e.modus,this.selectedFormat),this.solutionSteps=t.result,this.solutionObject=e.resultObject,this.modus=e.modus},checkSolution(){this.solutionObject.bitStrint===this.propSol?this.backSol="correctInput":this.backSol="incorrectInput"},preventGlobalMouseEvents(){document.body.style["pointer-events"]="none"},restoreGlobalMouseEvents(){document.body.style["pointer-events"]="auto"},mouseupListener(e){this.restoreGlobalMouseEvents(),document.removeEventListener("mouseup",this.mouseupListener,{capture:!0}),document.removeEventListener("mousemove",this.sliderMouseMove,{capture:!0}),e.stopPropagation(),this.mouseDown=!1},captureMouseEvents(e){this.preventGlobalMouseEvents(),document.addEventListener("mouseup",this.mouseupListener,{capture:!0}),document.addEventListener("mousemove",this.sliderMouseMove,{capture:!0}),e.preventDefault(),e.stopPropagation()}}};const Yi=(0,z.A)(Ji,[["render",Oi],["__scopeId","data-v-0bc3fbec"]]);var Qi=Yi;const en={class:"fp-arithmetic bodyContainer"},tn={class:"introduction"},nn={id:"fpOperationTable",class:"fpOperationTable"},sn={class:"container"},an={class:"polyadicTable"},on={class:"solutionInput"},rn=["placeholder"],ln={class:"solutionArea"},cn={class:"solutionInput"},un={style:{position:"relative"}},hn={id:"solution"},dn=["innerHTML"],mn=["innerHTML"];function pn(e,t,i,s,a,o){const r=(0,m.g2)("FSelect"),l=(0,m.g2)("AttentionBanner"),c=(0,m.g2)("AccordionItem"),u=(0,m.g2)("Accordion");return(0,m.uX)(),(0,m.CE)("div",en,[(0,m.Lk)("p",tn,(0,p.v_)(e.$t("polyConvIntro")),1),(0,m.Lk)("div",nn,[(0,m.Lk)("div",sn,[(0,m.Lk)("table",an,[(0,m.Lk)("tbody",null,[(0,m.Lk)("tr",null,[(0,m.Lk)("td",null,[(0,m.Lk)("div",on,[(0,m.Lk)("p",null,(0,p.v_)(e.$t("input")),1),(0,m.bo)((0,m.Lk)("input",{id:"InputNumber","onUpdate:modelValue":t[0]||(t[0]=e=>a.inputNum=e),placeholder:this.$t("inputNumber"),onInput:t[1]||(t[1]=e=>o.checkFormat(e.target.value)),class:(0,p.C4)(a.backFormat)},null,42,rn),[[n.Jo,a.inputNum]])])]),(0,m.Lk)("td",null,[(0,m.Lk)("p",null,(0,p.v_)(e.$t("firstFormat")),1),(0,m.bF)(r,{num:0,sel:a.selectedFormat[0],onInput:o.selectFormat,options:o.formatOptions},null,8,["sel","onInput","options"])]),(0,m.Lk)("td",null,[(0,m.Lk)("p",null,(0,p.v_)(e.$t("secondFormat")),1),(0,m.bF)(r,{num:1,sel:a.selectedFormat[1],onInput:o.selectFormat,options:o.formatOptions},null,8,["sel","onInput","options"])])])])])])]),(0,m.Lk)("div",ln,[(0,m.Lk)("div",cn,[(0,m.Lk)("p",null,(0,p.v_)(e.$t("ownSolution")),1),(0,m.bo)((0,m.Lk)("input",{id:"propSol",class:(0,p.C4)(a.backSol),"onUpdate:modelValue":t[2]||(t[2]=e=>a.propSol=e)},null,2),[[n.Jo,a.propSol]])]),t[4]||(t[4]=(0,m.Lk)("div",{class:"divMargin"},null,-1)),(0,m.Lk)("button",{id:"checkSolution",onClick:t[3]||(t[3]=(...e)=>o.checkSolution&&o.checkSolution(...e))},(0,p.v_)(e.$t("check")),1)]),(0,m.Lk)("h4",null,(0,p.v_)(e.$t("correctSolution")),1),(0,m.Lk)("div",un,[(0,m.bF)(l,{text:e.$t("attSolve")},null,8,["text"])]),(0,m.Lk)("div",hn,[(0,m.bF)(u,{solutionDescription:o.solDescr},{default:(0,m.k6)((()=>[((0,m.uX)(!0),(0,m.CE)(m.FK,null,(0,m.pI)(o.solDescr,(e=>((0,m.uX)(),(0,m.Wv)(c,{key:e.name},{"accordion-item-title":(0,m.k6)((()=>[(0,m.eW)((0,p.v_)(e.name),1)])),"accordion-item-body":(0,m.k6)((()=>[(0,m.Lk)("span",{innerHTML:e.text},null,8,dn),null!=e.subpanels?((0,m.uX)(),(0,m.Wv)(u,{key:0},{default:(0,m.k6)((()=>[((0,m.uX)(!0),(0,m.CE)(m.FK,null,(0,m.pI)(e.subpanels,(e=>((0,m.uX)(),(0,m.Wv)(c,{key:e.name},{"accordion-item-title":(0,m.k6)((()=>[(0,m.eW)((0,p.v_)(e.name),1)])),"accordion-item-body":(0,m.k6)((()=>[(0,m.Lk)("span",{innerHTML:e.text},null,8,mn)])),_:2},1024)))),128))])),_:2},1024)):(0,m.Q3)("",!0)])),_:2},1024)))),128))])),_:1},8,["solutionDescription"])]),t[5]||(t[5]=(0,m.Lk)("div",{id:"jaxHelper"},null,-1))])}var fn={name:"PolyadicConversionFree",components:{FSelect:Oe,Accordion:qe,AccordionItem:Ze,AttentionBanner:Fe},data(){const e=!1;let t=!1,i="decimal";e&&window.sessionStorage.getItem("PCF_format1")&&(i=window.sessionStorage.getItem("PCF_format1"),t=!0);let n="decimal";e&&window.sessionStorage.getItem("PCF_format2")&&(n=window.sessionStorage.getItem("PCF_format2"),t=!0);let s="";return e&&window.sessionStorage.getItem("PCF_inputNum")&&(s=window.sessionStorage.getItem("PCF_inputNum"),t=!0),{useCookies:e,selectedFormat:[i,n],power:[10,10],mouseDown:!1,solution:"",solutionObject:"",inputNum:s,solutionSteps:[],default:t,watcher:"",propSol:"",backSol:"",backFormat:"",modus:""}},computed:{falseFormatOutput(){return this.$t("falseFormat")},solDescr(){return this.solutionSteps},formatOptions(){return{decimal:`${this.$t("decimal")} (${this.$t("basis")} 10)`,binary:`${this.$t("binary")} (${this.$t("basis")} 2)`,ternary:`${this.$t("ternary")} (${this.$t("basis")} 3)`,quaternary:`${this.$t("quaternary")} (${this.$t("basis")} 4)`,quinary:`${this.$t("quinary")} (${this.$t("basis")} 5)`,senary:`${this.$t("senary")} (${this.$t("basis")} 6)`,septenary:`${this.$t("septenary")} (${this.$t("basis")} 7)`,octal:`${this.$t("octal")} (${this.$t("basis")} 8)`,novenary:`${this.$t("novenary")} (${this.$t("basis")} 9)`,hex:`${this.$t("hexadecimal")} (${this.$t("basis")} 16)`}}},mounted(){this.default&&(this.power[0]=Zi(this.selectedFormat[0]),this.power[1]=Zi(this.selectedFormat[1]),this.checkFormat(this.inputNum))},watch:{input(){this.saveVals()}},methods:{saveVals(){this.useCookies&&(window.sessionStorage.setItem("PCF_format1",this.selectedFormat[0]),window.sessionStorage.setItem("PCF_format2",this.selectedFormat[1]),window.sessionStorage.setItem("PCF_inputNum",this.inputNum))},recalculate(){this.saveVals(),this.computeSolution(),this.$nextTick((()=>{window.MathJax&&window.MathJax.typeset()}))},selectFormat(e,t){this.selectedFormat[e]=t,this.power[e]=Zi(t),this.checkFormat(this.inputNum)},checkFormat(e){this.backFormat="";const t=this.selectedFormat[0],i=e.replace(/\s/g,"").toUpperCase();let n=!1;this.backSol="";for(let s=0;s<i.length;s+=1){switch(t){case"binary":if(!["0","1",",",".","-","+"].includes(i[s]))return this.backFormat="incorrectInput",!1;break;case"ternary":if(!["0","1","2",",",".","-","+"].includes(i[s]))return this.backFormat="incorrectInput",!1;break;case"quaternary":if(!["0","1","2","3",",",".","-","+"].includes(i[s]))return this.backFormat="incorrectInput",!1;break;case"quinary":if(!["0","1","2","3","4",",",".","-","+"].includes(i[s]))return this.backFormat="incorrectInput",!1;break;case"senary":if(!["0","1","2","3","4","5",",",".","-","+"].includes(i[s]))return this.backFormat="incorrectInput",!1;break;case"septenary":if(!["0","1","2","3","4","5","6",",",".","-","+"].includes(i[s]))return this.backFormat="incorrectInput",!1;break;case"octal":if(!["0","1","2","3","4","5","6","7",",",".","-","+"].includes(i[s]))return this.backFormat="incorrectInput",!1;break;case"novenary":if(!["0","1","2","3","4","5","6","7","8",",",".","-","+"].includes(i[s]))return this.backFormat="incorrectInput",!1;break;case"decimal":if(!["0","1","2","3","4","5","6","7","8","9",",",".","-","+"].includes(i[s]))return this.backFormat="incorrectInput",!1;break;case"hex":if(!["0","1","2","3","4","5","6","7","8","9","A","B","C","D","E","F",",",".","-","+"].includes(i[s]))return this.backFormat="incorrectInput",!1;break;default:}if(("+"===i[s]||"-"===i[s])&&s>0)return this.backFormat="incorrectInput",!1;if("."===i[s]||","===i[s]){if(!1!==n)return this.backFormat="incorrectInput",!1;n=!0}}return this.recalculate(),!0},downloadPdf(){this.recalculate();const e=new Xi(this,this.watcher);e.generatePdf()},computeSolution(){const e=new Hi;console.log(this.power,this.selectedFormat),e.convertFormat(this.inputNum,this.power[0],this.power[1]),this.watcher=JSON.parse(JSON.stringify(e.watcher)),this.solution=e.result;const t=new Ki(this,this.watcher);t.makeDescription(e.modus,this.selectedFormat),this.solutionSteps=t.result,this.solutionObject=e.resultObject,this.modus=e.modus},checkSolution(){this.solution===this.propSol?this.backSol="correctInput":this.backSol="incorrectInput"},preventGlobalMouseEvents(){document.body.style["pointer-events"]="none"},restoreGlobalMouseEvents(){document.body.style["pointer-events"]="auto"},mouseupListener(e){this.restoreGlobalMouseEvents(),document.removeEventListener("mouseup",this.mouseupListener,{capture:!0}),document.removeEventListener("mousemove",this.sliderMouseMove,{capture:!0}),e.stopPropagation(),this.mouseDown=!1},captureMouseEvents(e){this.preventGlobalMouseEvents(),document.addEventListener("mouseup",this.mouseupListener,{capture:!0}),document.addEventListener("mousemove",this.sliderMouseMove,{capture:!0}),e.preventDefault(),e.stopPropagation()},sliderMouseDown(e){this.mouseDown=!0,this.xCoord=e.pageX,this.captureMouseEvents(e)}}};const gn=(0,z.A)(fn,[["render",pn],["__scopeId","data-v-3e06ed0c"]]);var bn=gn;const vn={class:"fp-arithmetic bodyContainer"},wn={class:"introduction"},xn={id:"fpOperationTable",class:"fpOperationTable"},_n={class:"container"},$n={class:"polyadicTable"},yn={class:"solutionInput"},En=["placeholder"],Cn={class:"solutionInput"},Mn=["placeholder"],kn={class:"solutionArea"},Tn={class:"solutionInput"},Sn={style:{position:"relative"}},Nn={id:"solution"},Bn=["innerHTML"],Fn=["innerHTML"];function Ln(e,t,i,s,a,o){const r=(0,m.g2)("FSelect"),l=(0,m.g2)("AttentionBanner"),c=(0,m.g2)("AccordionItem"),u=(0,m.g2)("Accordion");return(0,m.uX)(),(0,m.CE)("div",vn,[(0,m.Lk)("p",wn,(0,p.v_)(e.$t("polyFreeIntro")),1),(0,m.Lk)("div",xn,[(0,m.Lk)("div",_n,[(0,m.Lk)("table",$n,[(0,m.Lk)("tbody",null,[(0,m.Lk)("tr",null,[(0,m.Lk)("td",null,[(0,m.Lk)("div",yn,[(0,m.Lk)("p",null,(0,p.v_)(e.$t("input"))+" 1",1),(0,m.bo)((0,m.Lk)("input",{id:"InputNumber1","onUpdate:modelValue":t[0]||(t[0]=e=>a.inputNums[0]=e),placeholder:this.$t("inputNumber"),onInput:t[1]||(t[1]=e=>o.selectVal(0,e.target.value)),class:(0,p.C4)(a.backFormat)},null,42,En),[[n.Jo,a.inputNums[0]]])])]),(0,m.Lk)("td",null,[(0,m.Lk)("div",Cn,[(0,m.Lk)("p",null,(0,p.v_)(e.$t("input"))+" 2",1),(0,m.bo)((0,m.Lk)("input",{id:"InputNumber2","onUpdate:modelValue":t[2]||(t[2]=e=>a.inputNums[1]=e),placeholder:this.$t("inputNumber"),onInput:t[3]||(t[3]=e=>o.selectVal(1,e.target.value)),class:(0,p.C4)(a.backFormat)},null,42,Mn),[[n.Jo,a.inputNums[1]]])])]),(0,m.Lk)("td",null,[(0,m.Lk)("p",null,(0,p.v_)(e.$t("firstFormat")),1),(0,m.bF)(r,{num:0,sel:a.selectedFormat,onInput:o.selectFormat,options:o.formatOptions},null,8,["sel","onInput","options"])]),(0,m.Lk)("td",null,[(0,m.Lk)("p",null,(0,p.v_)(e.$t("operand")),1),(0,m.bF)(r,{sel:a.operator,onInput:o.selectOperator,options:o.operationOptions},null,8,["sel","onInput","options"])])])])])])]),(0,m.Lk)("div",kn,[(0,m.Lk)("div",Tn,[(0,m.Lk)("p",null,(0,p.v_)(e.$t("ownSolution")),1),(0,m.bo)((0,m.Lk)("input",{id:"propSol",class:(0,p.C4)(a.backSol),"onUpdate:modelValue":t[4]||(t[4]=e=>a.propSol=e)},null,2),[[n.Jo,a.propSol]])]),t[6]||(t[6]=(0,m.Lk)("div",{class:"divMargin"},null,-1)),(0,m.Lk)("button",{id:"checkSolution",onClick:t[5]||(t[5]=(...e)=>o.checkSolution&&o.checkSolution(...e))},(0,p.v_)(e.$t("check")),1)]),(0,m.Lk)("h4",null,(0,p.v_)(e.$t("correctSolution")),1),(0,m.Lk)("div",Sn,[(0,m.bF)(l,{text:e.$t("attSolve")},null,8,["text"])]),(0,m.Lk)("div",Nn,[(0,m.bF)(u,{solutionDescription:o.solDescr},{default:(0,m.k6)((()=>[((0,m.uX)(!0),(0,m.CE)(m.FK,null,(0,m.pI)(o.solDescr,(e=>((0,m.uX)(),(0,m.Wv)(c,{key:e.name},{"accordion-item-title":(0,m.k6)((()=>[(0,m.eW)((0,p.v_)(e.name),1)])),"accordion-item-body":(0,m.k6)((()=>[(0,m.Lk)("span",{innerHTML:e.text},null,8,Bn),null!=e.subpanels?((0,m.uX)(),(0,m.Wv)(u,{key:0},{default:(0,m.k6)((()=>[((0,m.uX)(!0),(0,m.CE)(m.FK,null,(0,m.pI)(e.subpanels,(e=>((0,m.uX)(),(0,m.Wv)(c,{key:e.name},{"accordion-item-title":(0,m.k6)((()=>[(0,m.eW)((0,p.v_)(e.name),1)])),"accordion-item-body":(0,m.k6)((()=>[(0,m.Lk)("span",{innerHTML:e.text},null,8,Fn)])),_:2},1024)))),128))])),_:2},1024)):(0,m.Q3)("",!0)])),_:2},1024)))),128))])),_:1},8,["solutionDescription"])]),t[7]||(t[7]=(0,m.Lk)("div",{id:"jaxHelper"},null,-1))])}function An(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}class Vn{constructor(e,t){An(this,Vn),this.imp=e,this.table="",this.result=[],this.watcher=t}getAdditionTable(){let e=this.watcher.steps.Input.data.bitString1;const t=this.watcher.steps.Input.data.beforeComma;let i=this.watcher.steps.Input.data.afterComma;null==i&&(i=[]);const n=this.watcher.steps.Result.data.bitString,s=n.split("."),a=e.split(".");e=`${"0".repeat(s[0].length-a[0].length)}${e}`;for(let d=t.length;d<s[0].length;d+=1)t.unshift("0");if(Array.isArray(s)&&null!=s[1]){Array.isArray(a)&&null!=a[1]&&(e=`${e}${"0".repeat(s[1].length-a[1].length)}`);for(let e=i.length;e<s[1].length;e+=1)i.push("0")}const o=["&"],r=["+&"],l=["&"],c=["&"],u=`{${"c".repeat(n.length)}}`;for(let d=0;d<e.length;d+=1)o.push(` ${e[d]}`),o.push("&");console.log(this.watcher.steps);let h=!1;for(let d=0;d<t.length;d+=1){if(r.push(` ${t[d]}`),d!==t.length-1){let e=0;e=null!=this.watcher.steps.constructResult.data["overflowBeforeComma0"]?this.watcher.steps.constructResult.data[`overflowBeforeComma${d}`]:this.watcher.steps.constructResult.data[`overflowBeforeComma${d+1}`],null==e?e=" ":h=!0,l.push(`\\scriptsize{${e}} &`)}else if(null!=this.watcher.steps.constructResult.data["overflowAfterComma0"]){const e=this.watcher.steps.constructResult.data["overflowAfterComma0"];l.push(`\\scriptsize{${e}} &`),h=!0}else l.push("&");r.push("&")}i.length>0&&(r.push(" .&"),l.push(" &"));for(let d=0;d<i.length-1;d+=1){if(r.push(` ${i[d]}`),d!==t.length-1){let e=this.watcher.steps.constructResult.data[`overflowAfterComma${d+1}`];null==e?e=" ":h=!0,l.push(`\\scriptsize{${e}} &`)}else l.push("&");r.push("&")}r.push(` ${i[i.length-1]}`),l.push(" ");for(let d=0;d<n.length;d+=1)c.push(` ${n[d]}`),c.push("&");o.pop(),o.push(" \\\\ "),r.pop(),r.push(" \\\\ "),l.pop(),l.push(" \\\\ "),c.pop(),this.table=[`\\begin{array} ${u}`,`${o.join("")}`,`${r.join("")}`],h&&this.table.push(`${l.join("")}`),this.table.push("\\hline"),this.table.push(`${c.join("")}`),this.table.push("\\end{array}"),this.table=this.table.join("")}additionDescription(e,t,i){this.getAdditionTable(),this.result.push({name:`${this.imp.$t("addition")}`,text:`\\(${this.table}\\)`})}getMultiplicationTable(){const e=[],t=this.watcher;if(t.steps.Result.data.result.isNaN)this.table=`\\text{${this.imp.$t("solutionIsNan")}}`;else{const t=mulWatcher.steps.MultiplicationSteps.data,i=mulWatcher.steps.MultiplicationInput.data.leftArr,n=mulWatcher.steps.MultiplicationInput.data.rightArr;while(0===i[i.length-1])i.pop();const s=i.length;while(0===n[n.length-1])n.pop();const a=n.length,o=Math.min(t.countSteps,a),r=mulWatcher.steps.Result.data.resultArr,l=t.Step0_toAdd.arr.length;let c=Math.max(s+o,s+a,a+o)+3;e.push("{"),e.push("c|");for(let g=0;g<c;g+=1)e.push("c");e.push("c"),e.push("}");const u=[`&&${i.join("&")}`];u[0]+="&\\times&",u[0]+=n.join("&");for(let e=i.length+n.length+1;e<c;e+=1)u[0]+="&";let h=new convertFormat.FormatConversions(this.exponentBits,this.numBits);h.binToDec(i.join(""));const d=h.result;h.binToDec(n.join(""));const m=h.result;u[0]+=`\\ (${d}_{10} * ${m}_{10})\\\\`,u[0]+="\\hline";for(let e=0;e<o;e+=1){u.push(`${e}&+`);let n=t[`Step${e}_toAdd`].arr;const s=n.every((e=>0===e));s||(n=i),l-n.length>0&&(n=n.concat(Array(l-n.length).fill(0,0)));for(let t=0;t<e;t+=1)u[u.length-1]+="&";u[u.length-1]=u[u.length-1],u[u.length-1]+="&",u[u.length-1]+=n.join("&");for(let t=n.length+e;t<c;t+=1)u[u.length-1]+="&";const a=r.length-n.length-1;a>0&&(n=n.concat(Array(a).fill(0,0))),h=new convertFormat.FormatConversions(this.exponentBits,this.numBits),h.binToDec(n.join(""));const o=h.result*2**-e;u[u.length-1]+=`\\ (${o}_{10})`,u[u.length-1]+="\\\\ "}u.push("\\hline"),u.push("\\mathcal{L}&");let p=1;for(let e=r.length;e<=l;e+=1)u.push("&"),p+=1;u[u.length-1]+=`${r.join("&")}`,p+=r.length;for(let e=p;e<=c;e+=1)u[u.length-1]+="&";h=new convertFormat.FormatConversions(this.exponentBits,this.numBits),h.binToDec(r.join(""));const f=h.result;u[u.length-1]+=`&\\ (${f}_{10})`,this.table=[`\\begin{array} ${e.join("")}`,u.join(""),"\\end{array}"].join("")}}multiplicationDescription(e,t,i){}getSubtractionTable(){const e=this.watcher.steps.Addition.data.addition,t=e.steps.AddMantissa.data.mantissa1,i=e.steps.AddMantissa.data.mantissa2,n=e.steps.AddMantissa.data.addition.steps.Addition.data.op1Arr,s=e.steps.AddMantissa.data.addition.steps.Addition.data.op2Arr,a=e.steps.AddMantissa.data.addition.steps.Addition.data.carryArr,o=e.steps.AddMantissa.data.addition.steps.Addition.data.resultArr,r=e.steps.AddMantissa.data.binNum,l=[],c=[],u=[],h=[],d=[],m=[];0===e.steps.AddMantissa.data.sign1&&1===e.steps.AddMantissa.data.sign2?(l.push("&"),c.push("-&")):1===e.steps.AddMantissa.data.sign1&&0===e.steps.AddMantissa.data.sign2?(l.push("-&"),c.push("+&")):(l.push("-&"),c.push("-&")),u.push("&"),h.push("+&"),d.push("=&"),m.push("{");for(let p=t.length;p<=r;p+=1)t.unshift(0);for(let p=i.length;p<=r;p+=1)i.unshift(0);for(let p=n.length;p<=r;p+=1)n.unshift(0);for(let p=s.length;p<=r;p+=1)s.unshift(0);for(let p=a.length;p<=r;p+=1)a.unshift(0);for(let p=0;p<r;p+=1)m.push("c"),l.push(` ${t[p]}`),l.push("&"),c.push(` ${i[p]}`),c.push("&"),u.push(` ${n[p]}`),u.push("&"),h.push(` ${s[p]}_{${a[p]}}`),h.push("&"),d.push(` ${o[p]}`),d.push("&");m.push("}"),l.pop(),l.push("\\\\ "),c.pop(),c.push("\\\\ "),u.pop(),u.push("\\\\ "),h.pop(),h.push("\\\\ "),d.pop(),this.table=[`\\begin{array} ${m.join("")}`,`${l.join("")}`,`${c.join("")}`,"\\hline_{Complement}",`${u.join("")}`,`${h.join("")}`,"\\hline",`${d.join("")}`,"\\end{array}"].join("")}subtractionDescription(e,t,i){this.getSubtractionTable(),this.result.push({name:`${this.imp.$t("subtraction")}`,text:`\\(${this.table}\\)`})}getDivisionTable(){const e=[];if(this.watcher.steps.Result.data.result.isNaN)this.table=`${this.imp.$t("solutionIsNan")}`;else{const t=this.watcher.steps.Division.data.division,i=t.steps.DivisionSteps.data,n=i.countSteps,s=t.steps.DivisionInput.data.n1Arr,a=i.Step0_Sub2,o=a.length,r=t.steps.Result.data.resultArr;let l=Math.max(i[`Step${n-1}_SubRes`].length-2,i.Step0_Sub1.length+i.Step0_Sub2.length);l=l+o+2,e.push("{"),e.push("c|");for(let h=0;h<l;h+=1)e.push("c");e.push("|c"),e.push("}");const c=[`&&${i.Step0_Sub1.join("&")}`];c[0]+="&:&",c[0]+=a.join("&");for(let e=s.length+a.length+1;e<l;e+=1)c[0]+="&";c[0]+="\\\\";let u=0;for(let e=0;e<n;e+=1){if(c.push("&&"),c.push(`${e}&&`),0!==u){const t=i[`Step${e-1}_Sub1`];for(let i=0;i<e-1;i+=1)t[i]=" ";c[c.length-2]+=t.join("&"),c[c.length-2]+="& 0";for(let n=i[`Step${e-1}_Sub1`].length+1;n<l;n+=1)c[c.length-2]+="&";e>0&&(c[c.length-2]+="\\Sigma < 0 \\rightarrow 0"),c[c.length-3]=c[c.length-3].replace("-","<")}else{const t=i[`Step${e}_Sub1`];for(let i=0;i<e-u;i+=1)t[i]=" ";c[c.length-2]+=t.join("&");for(let n=i[`Step${e}_Sub1`].length;n<l;n+=1)c[c.length-2]+="&";e>0&&(c[c.length-2]+="\\Sigma > 0 \\rightarrow 1")}for(let t=0;t<e;t+=1)c[c.length-1]+="&";c[c.length-1]=c[c.length-1].slice(0,-1),c[c.length-1]+="-&",c[c.length-1]+=a.join("&");for(let t=o+e;t<l;t+=1)c[c.length-1]+="&";0!==u&&(c[c.length-1]+=`\\hookrightarrow {\\scriptstyle ${this.imp.$t("repeatMinuend")}}`),c[c.length-2]+="\\\\ ",c[c.length-1]+="\\\\ ",c[c.length-1]+="\\hline",i[`Step${e}_SubRes_isNegative`]?u+=1:u=0}c.push("\\mathcal{L}&&"),c[c.length-1]+=`${r[0]},& ${r.slice(1,r.length).join("&")}`,c[c.length-1]+="&";for(let e=r.length;e<l-2;e+=1)c[c.length-1]+="&";0!==u?(c[c.length-1]+="&\\Sigma < 0 \\rightarrow 0",c[c.length-2]=c[c.length-2].replace("-","<")):c[c.length-1]+="&\\Sigma > 0 \\rightarrow 1",this.table=[`\\begin{array} ${e.join("")}`,c.join(""),"\\end{array}"].join("")}}divisionDescription(e,t,i){}makeDescription(e,t,i,n){const s=new ji(i,e),a=new ji(i,t);switch(n){case"add":"+"===s.sign&&"+"===a.sign?this.additionDescription(s,a,i):"-"===a.sign?(a.sign="+",a.arr.shift(),this.subtractionDescription(s,a,i)):this.subtractionDescription(s,a,i);break;case"mul":this.multiplicationDescription(s,a,i);break;case"sub":"-"===s.sign&&"+"===a.sign?(this.negativeMinuendSubtrahend=!0,s.sign="+",s.arr.shift(),this.additionDescription(s,a,i)):"+"===s.sign&&"+"===a.sign?this.subtractionDescription(s,a,i):(a.sign="+",a.arr.shift(),this.additionDescription(s,a,i));break;case"div":this.divisionDescription(s,a,i);break;default:}const o=this.watcher.steps.Result.data.bitString,r=this.watcher.steps.Result.data.value;this.result.push({name:this.imp.$t("solution"),text:[`${this.imp.$t("solution")}: `,`\\(${o}\\) `,`\\(\\hspace{2cm} \\)${this.imp.$t("value")} (${this.imp.$t("decimal")}): \\(${r}\\)`].join("")})}}var In={name:"PolyadicConversionFree",components:{FSelect:Oe,Accordion:qe,AccordionItem:Ze,AttentionBanner:Fe},data(){const e=!1;let t=!1,i="decimal";e&&window.sessionStorage.getItem("PAF_format")&&(i=window.sessionStorage.getItem("PAF_format"),t=!0);let n="";e&&window.sessionStorage.getItem("PAF_inputNums1")&&(n=window.sessionStorage.getItem("PAF_inputNums2"),t=!0);let s="";e&&window.sessionStorage.getItem("PAF_inputNums2")&&(s=window.sessionStorage.getItem("PAF_inputNums2"),t=!0);let a="add";return e&&window.sessionStorage.getItem("PAF_operator")&&(a=window.sessionStorage.getItem("PAF_operator"),t=!0),{useCookies:e,selectedFormat:i,operator:a,mouseDown:!1,solution:"",solutionObject:"",inputNums:[n,s],solutionSteps:[],default:t,watcher:"",propSol:"",backSol:"",backFormat:["",""],modus:""}},computed:{falseFormatOutput(){return this.$t("falseFormat")},power(){return Zi(this.selectedFormat)},solDescr(){return this.solutionSteps},operationOptions(){return{add:`${this.$t("addition")} (+)`}},formatOptions(){return{decimal:`${this.$t("decimal")} (${this.$t("basis")} 10)`,binary:`${this.$t("binary")} (${this.$t("basis")} 2)`,ternary:`${this.$t("ternary")} (${this.$t("basis")} 3)`,quaternary:`${this.$t("quaternary")} (${this.$t("basis")} 4)`,quinary:`${this.$t("quinary")} (${this.$t("basis")} 5)`,senary:`${this.$t("senary")} (${this.$t("basis")} 6)`,septenary:`${this.$t("septenary")} (${this.$t("basis")} 7)`,octal:`${this.$t("octal")} (${this.$t("basis")} 8)`,novenary:`${this.$t("novenary")} (${this.$t("basis")} 9)`,hex:`${this.$t("hexadecimal")} (${this.$t("basis")} 16)`}}},mounted(){this.default&&this.recalculate()},watch:{input(){this.saveVals()}},methods:{saveVals(){this.useCookies&&(window.sessionStorage.setItem("PAF_format",this.selectedFormat),window.sessionStorage.setItem("PAF_inputNums1",this.inputNums[0]),window.sessionStorage.setItem("PAF_inputNums2",this.inputNums[1]),window.sessionStorage.setItem("PAF_operator",this.operator))},recalculate(){this.saveVals(),this.computeSolution(),this.$nextTick((()=>{window.MathJax&&window.MathJax.typeset()}))},selectOperator(e,t){this.operator=t,this.recalculate()},selectFormat(e,t){this.selectedFormat=t,this.checkFormat(this.inputNums[0])&&this.checkFormat(this.inputNums[1])&&this.recalculate()},selectVal(e,t){this.inputNums[e]=t,this.checkFormat(this.inputNums[e])&&this.recalculate()},checkFormat(e){this.backFormat="";const t=this.selectedFormat,i=e.replace(/\s/g,"");let n=!1;for(let s=0;s<i.length;s+=1){switch(t){case"binary":if(!["0","1",",",".","-","+"].includes(i[s]))return this.backFormat="incorrectInput",!1;break;case"ternary":if(!["0","1","2",",",".","-","+"].includes(i[s]))return this.backFormat="incorrectInput",!1;break;case"quaternary":if(!["0","1","2","3",",",".","-","+"].includes(i[s]))return this.backFormat="incorrectInput",!1;break;case"quinary":if(!["0","1","2","3","4",",",".","-","+"].includes(i[s]))return this.backFormat="incorrectInput",!1;break;case"senary":if(!["0","1","2","3","4","5",",",".","-","+"].includes(i[s]))return this.backFormat="incorrectInput",!1;break;case"septenary":if(!["0","1","2","3","4","5","6",",",".","-","+"].includes(i[s]))return this.backFormat="incorrectInput",!1;break;case"octal":if(!["0","1","2","3","4","5","6","7",",",".","-","+"].includes(i[s]))return this.backFormat="incorrectInput",!1;break;case"novenary":if(!["0","1","2","3","4","5","6","7","8",",",".","-","+"].includes(i[s]))return this.backFormat="incorrectInput",!1;break;case"decimal":if(!["0","1","2","3","4","5","6","7","8","9",",",".","-","+"].includes(i[s]))return this.backFormat="incorrectInput",!1;break;case"hex":if(!["0","1","2","3","4","5","6","7","8","9","A","B","C","D","E","F",",",".","-","+"].includes(i[s]))return this.backFormat="incorrectInput",!1;break;default:}if("-"===i[s])return this.backFormat="incorrectInput",!1;if(("+"===i[s]||"-"===i[s])&&s>1)return this.backFormat="incorrectInput",!1;if("."===i[s]||","===i[s]){if(!1!==n)return this.backFormat="incorrectInput",!1;n=!0}}return!0},downloadPdf(){this.recalculate();const e=new Xi(this,this.watcher);e.generatePdf()},computeSolution(){const e=new Hi;e.calcArithmeticSolution(this.inputNums[0].replace(",","."),this.inputNums[1].replace(",","."),this.power,this.operator),this.watcher=JSON.parse(JSON.stringify(e.watcher)),this.solution=e.result;const t=new Vn(this,this.watcher);t.makeDescription(this.inputNums[0].replace(",","."),this.inputNums[1].replace(",","."),this.power,this.operator),this.solutionSteps=t.result,this.solutionObject=e.resultObject,this.modus=e.modus,this.$nextTick((()=>{window.MathJax&&window.MathJax.typeset()}))},checkSolution(){this.solution===this.propSol?this.backSol="correctInput":this.backSol="incorrectInput"},preventGlobalMouseEvents(){document.body.style["pointer-events"]="none"},restoreGlobalMouseEvents(){document.body.style["pointer-events"]="auto"},mouseupListener(e){this.restoreGlobalMouseEvents(),document.removeEventListener("mouseup",this.mouseupListener,{capture:!0}),document.removeEventListener("mousemove",this.sliderMouseMove,{capture:!0}),e.stopPropagation(),this.mouseDown=!1},captureMouseEvents(e){this.preventGlobalMouseEvents(),document.addEventListener("mouseup",this.mouseupListener,{capture:!0}),document.addEventListener("mousemove",this.sliderMouseMove,{capture:!0}),e.preventDefault(),e.stopPropagation()},sliderMouseDown(e){this.mouseDown=!0,this.xCoord=e.pageX,this.captureMouseEvents(e)}}};const Dn=(0,z.A)(In,[["render",Ln],["__scopeId","data-v-f4c89ba0"]]);var Pn=Dn;const On=["conversionExercise","conversion","arithmeticFree"];var jn=(0,m.pM)({name:"TinyTabs",components:{pce:Qi,pcf:bn,paf:Pn,Tabs:a.Tabs,Tab:a.Tab,TabPanels:a.TabPanels,TabPanel:a.TabPanel},data(){return{selectedTab:"conversionExercise"}},setup(){const e=(0,Q.Kh)({selectedTab:On[1]});return{tabs:On,...(0,Q.QW)(e)}}});const Rn=(0,z.A)(jn,[["render",Ni]]);var zn=Rn;const Wn={class:"mainarea"},qn=["innerHTML"],Hn={class:"boolean-function-input-container"},Un={class:"exercise-selection-container"},Kn={class:"exercise-selection-container-subsection"},Gn=["innerHTML"],Xn={class:"exercise-selection-container-subsection"},Zn=["innerHTML"],Jn={key:0,class:"exercise-selection-container-subsection"},Yn={class:"errormessage"},Qn=["innerHTML"],es=["innerHTML"],ts={class:"exercise-selection-container-subsection"},is={class:"boolean-function-input-container-divider"},ns=["innerHTML"],ss={key:1},as={key:2,class:"bf-main-accordion-container"},os={style:{"padding-top":"3px","padding-right":"10px"}},rs={style:{"padding-top":"3px","padding-left":"10px"}},ls={class:"overflowXContainer"},cs=["innerHTML"],us={class:"overflowXContainer"},hs=["innerHTML"],ds={style:{"text-align":"left"}},ms={class:"quine-classes-toggle-switch-container"},ps=["innerHTML"],fs=["innerHTML"],gs={class:"smallTopBottomMargin"},bs=["innerHTML"],vs={class:"termcollection"},ws=["innerHTML"],xs=["innerHTML"],_s=["innerHTML"],$s=["innerHTML"],ys=["innerHTML"],Es={key:1,class:"horizontalbarfull"},Cs={class:"overflowXContainer"},Ms=["innerHTML"],ks={class:"overflowXContainer"},Ts=["innerHTML"],Ss={class:"primeTableContainer"},Ns={class:"bf-primetable"},Bs=["innerHTML"],Fs=["innerHTML"],Ls={class:"bf-primetable-controls"},As=["disabled"],Vs={class:"control-text"},Is=["disabled"],Ds={class:"explanation-text"},Ps=["innerHTML"],Os=["innerHTML"],js={class:"bf-petrick-statement-container"},Rs={key:0,class:"infoblob-wrapper"},zs=["innerHTML"],Ws=["innerHTML"],qs={key:0},Hs={class:"overflowXContainer"},Us=["innerHTML"],Ks={class:"overflowXContainer"},Gs=["innerHTML"],Xs={class:"bf-petrick-statement-container"},Zs=["innerHTML"],Js=["innerHTML"],Ys={style:{"padding-left":"1em"}},Qs={class:"bf-petrick-statement-container"},ea=["innerHTML"],ta=["innerHTML"],ia={style:{"padding-left":"1em"}};function na(e,t,i,s,a,o){const r=(0,m.g2)("InfoBlob"),l=(0,m.g2)("FSelect"),c=(0,m.g2)("TabComponent"),u=(0,m.g2)("BooleanFunctionInputDevice"),h=(0,m.g2)("ToggleSwitch"),d=(0,m.g2)("KVDiagr"),f=(0,m.g2)("TruthTable"),g=(0,m.g2)("AccordionItem"),b=(0,m.g2)("Accordion");return(0,m.uX)(),(0,m.CE)("div",null,[(0,m.Lk)("div",Wn,[(0,m.Lk)("h3",null,[(0,m.eW)((0,p.v_)(e.$t("functionMin")),1),(0,m.bF)(r,null,{default:(0,m.k6)((()=>[(0,m.Lk)("span",{innerHTML:e.$t("bf_infoblob_functionMin")},null,8,qn)])),_:1})]),(0,m.Lk)("div",Hn,[(0,m.Lk)("div",Un,[(0,m.bF)(c,{tabs:["archive","formula","randomExercise"]},{archive:(0,m.k6)((()=>[(0,m.Lk)("div",Kn,[(0,m.Lk)("span",{innerHTML:e.$t("archive")},null,8,Gn),(0,m.bF)(l,{options:o.archivedExerciseTitles,sel:0,onInput:o.selectArchivedExercise,class:"leftMargin10 fselect_broad",ref:"archivedExercisesDropDownMenu"},null,8,["options","onInput"]),(0,m.Lk)("button",{onClick:t[0]||(t[0]=(...e)=>o.loadArchivedExercise&&o.loadArchivedExercise(...e))},(0,p.v_)(e.$t("load")),1)])])),formula:(0,m.k6)((()=>[(0,m.Lk)("div",Xn,[(0,m.Lk)("span",{innerHTML:e.$t("formula")},null,8,Zn),(0,m.bo)((0,m.Lk)("input",{"onUpdate:modelValue":t[1]||(t[1]=e=>a.stringInterpreterFormula=e),class:"leftMargin10",size:"17"},null,512),[[n.Jo,a.stringInterpreterFormula]]),(0,m.Lk)("button",{class:"leftMargin10",onClick:t[2]||(t[2]=e=>o.loadBFFromString(a.stringInterpreterFormula))},(0,p.v_)(e.$t("translate_big")),1)]),a.loadFromFormula_formulaError?((0,m.uX)(),(0,m.CE)("div",Jn,[(0,m.Lk)("span",Yn,[(0,m.Lk)("span",{innerHTML:`${e.$t("bf_error_at_symbol")} `},null,8,Qn),(0,m.Lk)("span",null," '"+(0,p.v_)(a.loadFromFormula_formulaErrorDetails.found)+"' ",1),(0,m.Lk)("span",{innerHTML:` ${e.$t("at_position")} `},null,8,es),(0,m.Lk)("span",null,(0,p.v_)(a.loadFromFormula_formulaErrorDetails.location.start.column),1)])])):(0,m.Q3)("",!0)])),randomExercise:(0,m.k6)((()=>[(0,m.Lk)("div",ts,[(0,m.Lk)("span",null,(0,p.v_)(e.$t("goal"))+":",1),(0,m.bF)(l,{options:o.randomExercisesGoalsTitles,class:"leftMargin10",sel:0,onInput:o.selectRandomExerciseGoal},null,8,["options","onInput"])]),(0,m.Lk)("div",null,[(0,m.Lk)("span",null,(0,p.v_)(e.$t("difficultyUC"))+":",1),(0,m.bF)(l,{options:o.randomExercisesDifficulties,sel:0,class:"leftMargin10",onInput:o.selectRandomExerciseDifficulty},null,8,["options","onInput"]),(0,m.Lk)("button",{onClick:t[3]||(t[3]=(...e)=>o.generateRandomExercise&&o.generateRandomExercise(...e))},(0,p.v_)(e.$t("load")),1)])])),_:1})]),(0,m.Lk)("p",is,(0,p.v_)(e.$t("bf_infotext_or_interact_with_kv"))+":",1),(0,m.Lk)("div",null,[(0,m.bF)(u,{class:"bfInputDevice",ref:"childBooleanFunctionInputDevice"},null,512)]),(0,m.Lk)("button",{class:"boolean-function-button-optimize",onClick:t[4]||(t[4]=e=>o.optimize())},(0,p.v_)(e.$t("doCalculation")),1)]),t[16]||(t[16]=(0,m.Lk)("div",{class:"horizontalbar"},null,-1)),!0===this.showMsgKVDiagramMustNotBeEmptyOrFull?((0,m.uX)(),(0,m.CE)("span",{key:0,innerHTML:e.$t("bf_infotext_kv_must_not_be_empty")},null,8,ns)):!1===this.someOptimizationsFinished?((0,m.uX)(),(0,m.CE)("span",ss,(0,p.v_)(e.$t("bf_infotext_what_to_do")),1)):((0,m.uX)(),(0,m.CE)("div",as,[(0,m.Lk)("span",os,(0,p.v_)(e.$t("minterms")),1),(0,m.bF)(h,{onToggle:o.toggleMinMaxTerms,checkedDefault:"false"},null,8,["onToggle"]),(0,m.Lk)("span",rs,(0,p.v_)(e.$t("maxterms")),1),(0,m.bF)(b,null,{default:(0,m.k6)((()=>[(0,m.bF)(g,null,{"accordion-item-title":(0,m.k6)((()=>[(0,m.eW)((0,p.v_)(e.$t("kvDiagram"))+" / "+(0,p.v_)(e.$t("truthtable")),1)])),"accordion-item-body":(0,m.k6)((()=>[(0,m.bF)(d,{ref:"resultKVDiagram",modifiable:!1,onRequestingKvdiagramDataAfterReactivation:t[5]||(t[5]=e=>o.updateResultKVDiagram()),numVariables:this.resultNumVars,varNames:this.$refs.childBooleanFunctionInputDevice.currentVarNames,class:"accordion-body-element-halfer blurred",onClickedSomewhere:o.unblurDOM},null,8,["numVariables","varNames","onClickedSomewhere"]),(0,m.bF)(f,{ref:"resultTruthTable",modifiable:!1,onRequestingBfAfterReactivation:t[6]||(t[6]=e=>o.updateResultTruthtable()),numVariables:this.resultNumVars,varNames:this.$refs.childBooleanFunctionInputDevice.currentVarNames,class:"accordion-body-element-halfer blurred",onClickedSomewhere:o.unblurDOM},null,8,["numVariables","varNames","onClickedSomewhere"])])),_:1}),(0,m.bF)(g,null,{"accordion-item-title":(0,m.k6)((()=>[(0,m.eW)((0,p.v_)(e.$t("bf_normal_forms")),1)])),"accordion-item-body":(0,m.k6)((()=>[(0,m.bF)(b,{class:"emptyAccordionParentBody"},{default:(0,m.k6)((()=>[(0,m.bF)(g,null,{"accordion-item-title":(0,m.k6)((()=>[(0,m.eW)((0,p.v_)(e.$t("bf_disjunctiveNormalForm"))+" (DNF) ",1)])),"accordion-item-body":(0,m.k6)((()=>[(0,m.Lk)("span",null,(0,p.v_)(e.$t("bf_disjunctiveNormalForm_explanation")),1),(0,m.Lk)("div",ls,[(0,m.Lk)("span",{class:"svg-text",innerHTML:o.toSvg(a.dnf)},null,8,cs)])])),_:1}),(0,m.bF)(g,null,{"accordion-item-title":(0,m.k6)((()=>[(0,m.eW)((0,p.v_)(e.$t("bf_conjunctiveNormalForm"))+" (KNF) ",1)])),"accordion-item-body":(0,m.k6)((()=>[(0,m.Lk)("span",null,(0,p.v_)(e.$t("bf_conjunctiveNormalForm_explanation")),1),(0,m.Lk)("div",us,[(0,m.Lk)("span",{class:"svg-text",innerHTML:o.toSvg(a.knf)},null,8,hs)])])),_:1})])),_:1})])),_:1}),(0,m.bF)(g,null,{"accordion-item-title":(0,m.k6)((()=>[(0,m.eW)((0,p.v_)(e.$t("bf_quineMCCluskeyClasses")),1)])),"accordion-item-body":(0,m.k6)((()=>[(0,m.Lk)("span",ds,(0,p.v_)(e.$t("bf_quineMCCluskeyClasses_explanation")),1),(0,m.Lk)("div",ms,[(0,m.Lk)("div",null,[(0,m.bF)(h,{onToggle:o.changeQuineClassesDisplayStyle,checkedDefault:"true"},null,8,["onToggle"]),(0,m.Lk)("span",null,[(0,m.eW)((0,p.v_)(e.$t("colorCoding"))+" ",1),(0,m.bF)(r,null,{default:(0,m.k6)((()=>[(0,m.Lk)("span",{innerHTML:e.$t("bf_infoblob_quineMCCluskeyClasses_colorCoding")},null,8,ps)])),_:1})])]),(0,m.Lk)("div",null,[(0,m.bF)(h,{onToggle:o.changeQuineClassesBinaryDisplayStyle,checkedDefault:"false"},null,8,["onToggle"]),(0,m.Lk)("span",null,[t[10]||(t[10]=(0,m.eW)("01-0 ")),(0,m.bF)(r,null,{default:(0,m.k6)((()=>[(0,m.Lk)("span",{innerHTML:e.$t("bf_infoblob_quineMCCluskeyClasses_01")},null,8,fs)])),_:1})])])]),(0,m.Lk)("div",gs,(0,p.v_)(e.$t("bf_infotest_click_on_hidden_areas_to_make_visible"))+":",1),((0,m.uX)(!0),(0,m.CE)(m.FK,null,(0,m.pI)(a.quineClassesCurrent,((e,i)=>((0,m.uX)(),(0,m.CE)("div",{key:`quineClassLayerMin_${i}`},[i<a.quineClassesCurrent.length-1?((0,m.uX)(),(0,m.CE)("div",{key:0,class:"blurred",onMousedown:t[7]||(t[7]=(...e)=>o.unblurDOM&&o.unblurDOM(...e))},[((0,m.uX)(!0),(0,m.CE)(m.FK,null,(0,m.pI)(a.quineClassesCurrent[i],((e,t)=>((0,m.uX)(),(0,m.CE)("div",{key:`quineClassLayerInnerMin_${t}`,class:"quine-class-single-class-container"},[(0,m.Lk)("span",{class:"svg-text",innerHTML:o.toSvg(`Q _{${a.quineClassesCurrent.length-i-1},\\ ${a.quineClassesCurrent[i].length-t-1}}:\\{`)},null,8,bs),(0,m.Lk)("span",vs,[((0,m.uX)(!0),(0,m.CE)(m.FK,null,(0,m.pI)(a.quineClassesCurrent[i][t],((e,n)=>((0,m.uX)(),(0,m.CE)("span",{key:`quineClassTermMin_${n}`},[a.quineClassesCurrent[i][t][n][1]?((0,m.uX)(),(0,m.CE)(m.FK,{key:1},[a.quineClassesColorfulDisplayStyle?((0,m.uX)(),(0,m.CE)("span",{key:1,class:"svg-text term quine-classes-reduced-term-colored",innerHTML:o.toSvg(a.quineClassesCurrent[i][t][n][a.quineClassesBinaryDisplayStyle?2:0])},null,8,_s)):((0,m.uX)(),(0,m.CE)("span",{key:0,class:"svg-text term .quine-classes-reduced-term-crossed",innerHTML:o.toSvg(`\\cancel{${a.quineClassesCurrent[i][t][n][a.quineClassesBinaryDisplayStyle?2:0]}}`)},null,8,xs))],64)):((0,m.uX)(),(0,m.CE)("span",{key:0,class:"svg-text term",innerHTML:o.toSvg(a.quineClassesCurrent[i][t][n][a.quineClassesBinaryDisplayStyle?2:0])},null,8,ws)),n<a.quineClassesCurrent[i][t].length-1?((0,m.uX)(),(0,m.CE)("span",{key:2,innerHTML:o.toSvg(",")},null,8,$s)):(0,m.Q3)("",!0)])))),128))]),(0,m.Lk)("span",{class:"svg-text",innerHTML:o.toSvg("\\}")},null,8,ys)])))),128))],32)):(0,m.Q3)("",!0),i<a.quineClassesCurrent.length-2?((0,m.uX)(),(0,m.CE)("div",Es)):(0,m.Q3)("",!0)])))),128))])),_:1}),(0,m.bF)(g,null,{"accordion-item-title":(0,m.k6)((()=>[(0,m.eW)((0,p.v_)(e.$t("bf_primeTerms")),1)])),"accordion-item-body":(0,m.k6)((()=>[(0,m.eW)((0,p.v_)(e.$t("bf_primeTerms_explanation"))+" ",1),(0,m.bF)(b,null,{default:(0,m.k6)((()=>[(0,m.bF)(g,null,{"accordion-item-title":(0,m.k6)((()=>[(0,m.eW)((0,p.v_)(e.$t("bf_primeImplicants")),1)])),"accordion-item-body":(0,m.k6)((()=>[(0,m.eW)((0,p.v_)(e.$t("bf_bf_primeImplicants_explanation"))+" ",1),t[11]||(t[11]=(0,m.Lk)("br",null,null,-1)),(0,m.Lk)("div",Cs,[((0,m.uX)(!0),(0,m.CE)(m.FK,null,(0,m.pI)(a.primeTermsMin.length,(e=>((0,m.uX)(),(0,m.CE)("span",{key:`primeTermMinID_${e}`},[(0,m.Lk)("span",{class:"svg-text term",innerHTML:o.toSvg(`${a.primeTermsMin[e-1]}${e-1<a.primeTermsMin.length-1?",":""}`)},null,8,Ms)])))),128))])])),_:1}),(0,m.bF)(g,null,{"accordion-item-title":(0,m.k6)((()=>[(0,m.eW)((0,p.v_)(e.$t("bf_primeImplicates")),1)])),"accordion-item-body":(0,m.k6)((()=>[(0,m.eW)((0,p.v_)(e.$t("bf_primeImplicates_explanation"))+" ",1),t[12]||(t[12]=(0,m.Lk)("br",null,null,-1)),(0,m.Lk)("div",ks,[((0,m.uX)(!0),(0,m.CE)(m.FK,null,(0,m.pI)(a.primeTermsMax.length,(e=>((0,m.uX)(),(0,m.CE)("span",{key:`primeTermMaxID_${e}`},[(0,m.Lk)("span",{class:"svg-text term",innerHTML:o.toSvg(`${a.primeTermsMax[e-1]}${e-1<a.primeTermsMax.length-1?",":""}`)},null,8,Ts)])))),128))])])),_:1})])),_:1})])),_:1}),(0,m.bF)(g,null,{"accordion-item-title":(0,m.k6)((()=>[(0,m.eW)((0,p.v_)(e.$t("bf_primeCoverTable")),1)])),"accordion-item-body":(0,m.k6)((()=>[(0,m.Lk)("div",Ss,[(0,m.Lk)("table",Ns,[(0,m.Lk)("thead",null,[(0,m.Lk)("tr",null,[t[13]||(t[13]=(0,m.Lk)("td",null,null,-1)),(0,m.Lk)("td",{class:(0,p.C4)(o.primeTableColorMatrixObj.matrix[0][0])}," PI ",2),((0,m.uX)(!0),(0,m.CE)(m.FK,null,(0,m.pI)(a.primeTableCurrent.baseTerms,((e,t)=>((0,m.uX)(),(0,m.CE)("th",{key:`primeTableCurrentTR_${t}`,class:(0,p.C4)([o.primeTableColorMatrixObj.matrix[t+1][0],0===o.primeTableColorMatrixObj.highlightedCellRow&&o.primeTableColorMatrixObj.highlightedCellColumn===t+1?"primetable-highlighted-cell":""])},(0,p.v_)(o.primeTableBaseTermIndices[t]),3)))),128)),(0,m.Lk)("th",{innerHTML:o.toSvg("c_{i}"),class:"svg-text"},null,8,Bs)])]),(0,m.Lk)("tbody",null,[((0,m.uX)(!0),(0,m.CE)(m.FK,null,(0,m.pI)(a.primeTableCurrent.primeTerms,((e,t)=>((0,m.uX)(),(0,m.CE)("tr",{key:`primeTableCurrentRow_${t}`},[(0,m.Lk)("td",null,(0,p.v_)(o.nthLetter(t+1)),1),(0,m.Lk)("th",{class:(0,p.C4)(["svg-text",[o.primeTableColorMatrixObj.matrix[0][t+1],o.primeTableColorMatrixObj.highlightedCellRow===t+1&&0===o.primeTableColorMatrixObj.highlightedCellColumn?"primetable-highlighted-cell":""]]),innerHTML:o.toSvg(e.toLatex(a.literalNames))},null,10,Fs),((0,m.uX)(!0),(0,m.CE)(m.FK,null,(0,m.pI)(a.primeTableCurrent.coverTable.length,(e=>((0,m.uX)(),(0,m.CE)("td",{key:`primeTableCurrentCell_${t}_${e}`,class:(0,p.C4)(o.primeTableColorMatrixObj.matrix[e][t+1])},[!0===a.primeTableCurrent.coverTable[e-1][t]?((0,m.uX)(),(0,m.CE)("span",{key:0,class:(0,p.C4)(o.primeTableColorMatrixObj.highlightedCellRow===t+1&&o.primeTableColorMatrixObj.highlightedCellColumn===e?"primetable-highlighted-cell":"")}," X ",2)):(0,m.Q3)("",!0)],2)))),128)),(0,m.Lk)("td",null,(0,p.v_)(a.primeTableCurrent.primeTerms[t].getTerms().length),1)])))),128))])])]),(0,m.Lk)("div",Ls,[(0,m.Lk)("button",{onClick:t[8]||(t[8]=(...e)=>o.primetableStepBackward&&o.primetableStepBackward(...e)),disabled:0===a.primetableCurrentStepIndex}," ← ",8,As),(0,m.Lk)("span",Vs,[(0,m.eW)((0,p.v_)(e.$t("step"))+" ",1),(0,m.Lk)("span",null,(0,p.v_)(a.primetableCurrentStepIndex)+" / "+(0,p.v_)(a.primetableStepsAmount),1)]),(0,m.Lk)("button",{onClick:t[9]||(t[9]=(...e)=>o.primetableStepForward&&o.primetableStepForward(...e)),disabled:a.primetableCurrentStepIndex===a.primetableStepsAmount}," → ",8,Is)]),(0,m.Lk)("div",Ds,[(0,m.Lk)("div",{class:"hiddenLongText",innerHTML:this.$t("bf_covertable_step_description_initial",{ifMinTermsEinstelleElseNullstelle:this.$t("bf_einstelle"),ifMinTermsEinstellenElseNullstellen:this.$t("bf_einstelle"),ifMinTermsNullstelleElseEinstelle:this.$t("bf_einstelle"),ifMinTermsNullstellenElseEinstellen:this.$t("bf_einstelle")})},null,8,Ps),(0,m.Lk)("div",{class:"bf-primetable-step-explanation",innerHTML:o.primeTableCurrentExplanation},null,8,Os)])])),_:1}),(0,m.bF)(g,{expandableSideways:!0},{"accordion-item-title":(0,m.k6)((()=>[(0,m.eW)((0,p.v_)(e.$t("bf_petrickExpression")),1)])),"accordion-item-body":(0,m.k6)((()=>[(0,m.Lk)("div",js,[a.petrickStatementCurrent.steps.length>4?((0,m.uX)(),(0,m.CE)("span",Rs,[(0,m.bF)(r,null,{default:(0,m.k6)((()=>[(0,m.Lk)("span",{innerHTML:e.$t("bf_infoblob_petrick_statement"),class:"petrick-statement-infoblob-ol"},null,8,zs)])),_:1})])):(0,m.Q3)("",!0),((0,m.uX)(!0),(0,m.CE)(m.FK,null,(0,m.pI)(a.petrickStatementCurrent.steps,((e,t)=>((0,m.uX)(),(0,m.CE)("div",{key:t,class:"bf-petrick-statement-subcontainer"},[(0,m.Lk)("span",{innerHTML:o.toSvg(`${e.bf.toLatex("ABCDEFGHIJKLMNOPQRSTUVPXYZ".split(""),!1)} = 1`)},null,8,Ws),t<a.petrickStatementCurrent.steps.length-1?((0,m.uX)(),(0,m.CE)("span",qs," | "+(0,p.v_)(o.getTextFromPetrickStatementActionType(a.petrickStatementCurrent.steps[t+1].actionType)),1)):(0,m.Q3)("",!0)])))),128))])])),_:1}),(0,m.bF)(g,null,{"accordion-item-title":(0,m.k6)((()=>[(0,m.eW)((0,p.v_)(e.$t("bf_minimalForms")),1)])),"accordion-item-body":(0,m.k6)((()=>[(0,m.bF)(b,{class:"emptyAccordionParentBody"},{default:(0,m.k6)((()=>[(0,m.bF)(g,null,{"accordion-item-title":(0,m.k6)((()=>[(0,m.eW)((0,p.v_)(e.$t("bf_disjunctiveMinimalForm"))+" (DMF) ",1)])),"accordion-item-body":(0,m.k6)((()=>[(0,m.eW)((0,p.v_)(e.$t("bf_disjunctiveMinimalForm_explanation"))+" ",1),t[14]||(t[14]=(0,m.Lk)("br",null,null,-1)),(0,m.Lk)("div",Hs,[(0,m.Lk)("span",{class:"svg-text",innerHTML:o.toSvg(a.dmf)},null,8,Us)])])),_:1}),(0,m.bF)(g,null,{"accordion-item-title":(0,m.k6)((()=>[(0,m.eW)((0,p.v_)(e.$t("bf_conjunctiveMinimalForm"))+" (KMF) ",1)])),"accordion-item-body":(0,m.k6)((()=>[(0,m.eW)((0,p.v_)(e.$t("bf_conjunctiveMinimalForm_explanation"))+" ",1),t[15]||(t[15]=(0,m.Lk)("br",null,null,-1)),(0,m.Lk)("div",Ks,[(0,m.Lk)("span",{class:"svg-text",innerHTML:o.toSvg(a.kmf)},null,8,Gs)])])),_:1})])),_:1})])),_:1}),(0,m.bF)(g,null,{"accordion-item-title":(0,m.k6)((()=>[(0,m.eW)((0,p.v_)(e.$t("bf_nandnorification")),1)])),"accordion-item-body":(0,m.k6)((()=>[(0,m.bF)(b,{class:"emptyAccordionParentBody"},{default:(0,m.k6)((()=>[(0,m.bF)(g,{expandableSideways:!0},{"accordion-item-title":(0,m.k6)((()=>[(0,m.eW)((0,p.v_)(e.$t("bf_nandification")),1)])),"accordion-item-body":(0,m.k6)((()=>[(0,m.Lk)("div",Xs,[(0,m.Lk)("div",{innerHTML:o.toSvg(a.nandOriginalBF.toLatex(this.$refs.childBooleanFunctionInputDevice.currentVarNames,!1)),class:"nandnor-line"},null,8,Zs),((0,m.uX)(!0),(0,m.CE)(m.FK,null,(0,m.pI)(a.optimizationNAND.steps,((e,t)=>((0,m.uX)(),(0,m.CE)("div",{key:t,class:""},[((0,m.uX)(!0),(0,m.CE)(m.FK,null,(0,m.pI)(e,((e,i)=>((0,m.uX)(),(0,m.CE)("div",{key:`${t}_${i}`,class:"nandnor-line"},[(0,m.Lk)("span",{innerHTML:o.toSvg(e.bf.toLatex(this.$refs.childBooleanFunctionInputDevice.currentVarNames,!1))},null,8,Js),(0,m.Lk)("span",Ys," | "+(0,p.v_)(o.getTextFromNANDificationStep(e.actionType)),1)])))),128))])))),128))])])),_:1}),(0,m.bF)(g,{expandableSideways:!0},{"accordion-item-title":(0,m.k6)((()=>[(0,m.eW)((0,p.v_)(e.$t("bf_norification")),1)])),"accordion-item-body":(0,m.k6)((()=>[(0,m.Lk)("div",Qs,[(0,m.Lk)("div",{innerHTML:o.toSvg(a.norOriginalBF.toLatex(this.$refs.childBooleanFunctionInputDevice.currentVarNames,!1)),class:"nandnor-line"},null,8,ea),((0,m.uX)(!0),(0,m.CE)(m.FK,null,(0,m.pI)(a.optimizationNOR.steps,((e,t)=>((0,m.uX)(),(0,m.CE)("div",{key:t,class:""},[((0,m.uX)(!0),(0,m.CE)(m.FK,null,(0,m.pI)(e,((e,i)=>((0,m.uX)(),(0,m.CE)("div",{key:`${t}_${i}`,class:"nandnor-line"},[(0,m.Lk)("span",{innerHTML:o.toSvg(e.bf.toLatex(this.$refs.childBooleanFunctionInputDevice.currentVarNames,!1))},null,8,ta),(0,m.Lk)("span",ia," | "+(0,p.v_)(o.getTextFromNORificationStep(e.actionType)),1)])))),128))])))),128))])])),_:1})])),_:1})])),_:1})])),_:1})]))])])}class sa{constructor(e,t){this._id=e,this._negated=t}getId(){return this._id}isNegated(){return this._negated}setNegated(e){this._negated=e}computeString(e,t="+",i="",n,s,a="(",o=")"){return this.isNegated()?n+e[this.getId()]+s:e[this.getId()]}clone(){return new sa(this._id,this._negated)}equals(e){return e instanceof sa&&(this.getId()===e.getId()&&this.isNegated()===e.isNegated())}amountLiterals(){return 1}computeOutput(e){return!(this._id>=e.length)&&(this._negated?!Number(e[this._id]):1===Number(e[this._id]))}getIDs(e){null==e.find((e=>e===this._id))&&e.push(this._id)}toString(){return`@${this._id}`}}const aa="*",oa="+",ra="~";class la{constructor(e,t){this._terms=t||[],this._logicOperator=e}addTerm(e){this._terms.push(e)}setTerm(e,t){this._terms[e]=t}setLogicOperator(e){this._logicOperator=e}setTerms(e){this._terms=e}injectTermBeforeIndex(e,t){this._terms.splice(e,0,t)}getTerms(){return this._terms}spliceTerms(e,t){this._terms.splice(e,t)}getLogicOperator(){return this._logicOperator}equals(e,t=!1,i=!1){if(!(e instanceof la))return!1;if(this.getLogicOperator()!==e.getLogicOperator()||this.getTerms().length!==e.getTerms().length)return!1;if(t){for(let n=0;n<this.getTerms().length;n+=1)if(!this.getTerms()[n].equals(e.getTerms()[n],i,i))return!1}else{for(let t=0;t<this.getTerms().length;t+=1){const n=this.getTerms()[t];if(0===e.getTerms().filter((e=>e.equals(n,i,i))).length)return!1}for(let t=0;t<e.getTerms().length;t+=1){const n=e.getTerms()[t];if(0===this.getTerms().filter((e=>e.equals(n,i,i))).length)return!1}}return!0}computeString(e,t="+",i="",n,s,a="(",o=")",r=!0){let l="";if(this._logicOperator===ra)return`\\overline{${this._terms[0].computeString(e,t,i,n,s,a,o,r)}}`;const c=this.getTerms().length,u=c>1&&this.getLogicOperator()!==oa;for(let h=r?c-1:0;r?h>=0:h<c;h+=r?-1:1){const d=this.getTerms()[h],m=d instanceof sa;u&&!m&&(l+=a),l+=d.computeString(e,t,i,n,s,a,o,r),u&&!m&&(l+=o),r?h>0&&(l+=this.getLogicOperator()===oa?t:i):h<c-1&&(l+=this.getLogicOperator()===oa?t:i)}return l}toLatex(e=["x0","x1","x2","x3","x4","x5","x6","x7"],t=!0){return this.computeString(e,"+","","\\bar{","}","\\left(","\\right)",t)}clone(){const e=[];for(let t=0;t<this._terms.length;t+=1)e[t]=this._terms[t].clone();return new la(this._logicOperator,e)}amountLiterals(){return this._terms.reduce(((e,t)=>e+t.amountLiterals()),0)}computeOutput(e){if(console.log("output",this._logicOperator,e),this._logicOperator===ra)return!this._terms[0].computeOutput(e);if(this._logicOperator===aa){for(const t of this._terms)if(!1===t.computeOutput(e))return!1;return!0}if(this._logicOperator===oa){for(const t of this._terms)if(!0===t.computeOutput(e))return!0;return!1}throw new Error(`Unknown BooleanFunctionOperator: ${this._logicOperator}`)}getIDs(e=[]){for(const t of this._terms)t.getIDs(e);return e}findHighestID(){let e=-1;for(const t of this._terms){let i;i=t instanceof sa?t.getId():t.findHighestID(),i>e&&(e=i)}return e}toString(){if(this._logicOperator===ra)return this._terms[0]instanceof sa?`~${this._terms[0].toString()}`:`~(${this._terms[0].toString()})`;let e="";for(let t=0;t<this._terms.length;t+=1){let i="";t<this._terms.length-1&&(i=this._logicOperator===aa?"*":"+"),this._terms[t]instanceof sa?e+=this._terms[t].toString()+i:e+=`(${this._terms[t].toString()})${i}`}return e}}class ca{constructor(e,t){if(this._amountLiterals=t,null!=e)this._values=e;else{const e=2**Math.floor((t+1)/2),i=2**Math.floor(t/2),n=[];for(let t=0;t<i;t+=1){n[t]=[];for(let i=0;i<e;i+=1)n[t][i]=0}this._values=n}this._generateLiteralToKVMapping()}getAmountLiterals(){return this._amountLiterals}getValues(){return this._values}computeKVIndex(e,t){let i=0;for(let n=0;n<this._amountLiterals;n+=1)if(0===this._literalToKVMapping[n][0]||2===this._literalToKVMapping[n][0]){for(let e=0;e<this._literalToKVMapping[n][1].length;e+=1)if(t===this._literalToKVMapping[n][1][e]){i+=2**n;break}}else for(let t=0;t<this._literalToKVMapping[n][1].length;t+=1)if(e===this._literalToKVMapping[n][1][t]){i+=2**n;break}return i}equals(e){if(this._amountLiterals!==e._amountLiterals)return!1;if(this._values.length!==e._values.length)return!1;for(let t=0;t<Math.max(this.getValues().length,e.getValues().length);t+=1){if(void 0===this.getValues()[t]||void 0===e.getValues()[t]||this.getValues()[t].length!==e.getValues()[t].length)return!1;for(let i=0;i<Math.max(this.getValues()[t].length,e.getValues()[t].length);i+=1)if(void 0===this.getValues()[t][i]||void 0===e.getValues()[t][i]||this.getValues()[t][i]!==e.getValues()[t][i])return!1}return!0}_generateLiteralToKVMapping(){this._literalToKVMapping=[];const e=2**Math.floor((this._amountLiterals+1)/2),t=2**Math.floor(this._amountLiterals/2);for(let i=0;i<this._amountLiterals;i+=1)if(this._literalToKVMapping[i]=[],this._literalToKVMapping[i][0]=i%4,this._literalToKVMapping[i][1]=[],0===this._literalToKVMapping[i][0]||2===this._literalToKVMapping[i][0]){const t=Math.round(Math.log2(e/2)),n=i/2,s=2**n,a=2**(i/2);for(let e=0;e<s;e+=1)this._literalToKVMapping[i][1].push(a+e);for(let e=0;e<t-n;e+=1){const t=this._literalToKVMapping[i][1].length;for(let s=t-1;s>=0;s-=1){const t=2**(2+e+n),a=t-1-this._literalToKVMapping[i][1][s];this._literalToKVMapping[i][1].push(a)}}}else{const e=Math.round(Math.log2(t/2)),n=(i-1)/2,s=2**n,a=2**((i-1)/2);for(let t=0;t<s;t+=1)this._literalToKVMapping[i][1].push(a+t);for(let t=0;t<e-n;t+=1){const e=this._literalToKVMapping[i][1].length;for(let s=e-1;s>=0;s-=1){const e=2**(2+t+n),a=e-1-this._literalToKVMapping[i][1][s];this._literalToKVMapping[i][1].push(a)}}}}}function ua(e,t=!1){const i=2**Math.floor((e+1)/2),n=2**Math.floor(e/2);while(1){let s=0,a=0;const o=[];for(let e=0;e<n;e+=1){o[e]=[];for(let t=0;t<i;t+=1){const i=Math.random();i<1/3?(o[e][t]="0",a+=1):i<2/3?(o[e][t]="1",s+=1):o[e][t]="-"}}if(!t||0!==a&&0!==s)return new ca(o,e)}}function ha(e,t){function i(){this.constructor=e}i.prototype=t.prototype,e.prototype=new i}function da(e,t,i,n){this.message=e,this.expected=t,this.found=i,this.location=n,this.name="SyntaxError","function"===typeof Error.captureStackTrace&&Error.captureStackTrace(this,da)}function ma(e,t){t=void 0!==t?t:{};const i={},n={Function:Ce};let s=Ce;const a="=",o="^",r="xor",l="<=>",c="xnor",u="nor",h="+",d="|",m="or",p="nand",f="*",g="&",b="and",v="!",w="~",x="not",_="0",$="1",y="(",E=")",C=/^[a-zA-Z]/,M=/^[0-9]/,k=/^[ \t\r\n]/,T=pe("=",!1),S=pe("^",!1),N=pe("xor",!1),B=pe("<=>",!1),F=pe("xnor",!1),L=pe("nor",!1),A=pe("+",!1),V=pe("|",!1),I=pe("or",!1),D=pe("nand",!1),P=pe("*",!1),O=pe("&",!1),j=pe("and",!1),R=pe("!",!1),z=pe("~",!1),W=pe("not",!1),q=pe("0",!1),H=pe("1",!1),U=fe([["a","z"],["A","Z"]],!1,!1),K=fe([["0","9"]],!1,!1),G=pe("(",!1),X=pe(")",!1),Z=fe([" ","\t","\r","\n"],!1,!1),J=function(e,t){return Re(e?e[0].toString():null,t)},Y=function(e,t){return t.length>0?ze(je.XOR,[e].concat(t.map((e=>e[1]))),!1):e},Q=function(e,t){return t.length>0?ze(je.XNOR,[e].concat(t.map((e=>e[1]))),!1):e},ee=function(e,t){return t.length>0?ze(je.NOR,[e].concat(t.map((e=>e[1]))),!1):e},te=function(e,t){return t.length>0?ze(je.OR,[e].concat(t.map((e=>e[1]))),!1):e},ie=function(e,t){return t.length>0?ze(je.NAND,[e].concat(t.map((e=>e[1]))),!1):e},ne=function(e,t){return t.length>0?ze(je.AND,[e].concat(t.map((e=>e[1]))),!1):e},se=function(e){return ze(je.NOT,e,!1)},ae=function(e){return e.hasParentheses=!0,e},oe=function(e){return qe(e)},re=function(e){return We(e[0].join("")+e[1].join(""))};let le=0,ce=0;const ue=[{line:1,column:1}],he=[],de=0;let me;if("startRule"in t){if(!(t.startRule in n))throw new Error(`Can't start parsing from rule "${t.startRule}".`);s=n[t.startRule]}function pe(e,t){return{type:"literal",text:e,ignoreCase:t}}function fe(e,t,i){return{type:"class",parts:e,inverted:t,ignoreCase:i}}function ge(){return{type:"end"}}function be(t){let i,n=ue[t];if(n)return n;i=t-1;while(!ue[i])i--;n=ue[i],n={line:n.line,column:n.column};while(i<t)10===e.charCodeAt(i)?(n.line++,n.column=1):n.column++,i++;return ue[t]=n,n}const ve="string"===typeof t.filename&&t.filename.length>0;function we(e,i){const n={};ve&&(n.filename=t.filename);const s=be(e);n.start={offset:e,line:s.line,column:s.column};const a=be(i);return n.end={offset:i,line:a.line,column:a.column},n}function xe(){he.push({pos:le,variants:[]})}function _e(e){const t=he[he.length-1];le<t.pos||(le>t.pos&&(t.pos=le,t.variants=[]),t.variants.push(e))}function $e(e){const t=he.pop(),i=he[he.length-1];let n=t.variants;i.pos===t.pos&&(e&&(n=n.map((e=>"not"===e.type?e.expected:{type:"not",expected:e}))),Array.prototype.push.apply(i.variants,n))}function ye(e,t,i){return new da(da.buildMessage(e,t),e,t,i)}function Ee(){const t=he[0],i=t.pos;return ye(t.variants,i<e.length?e.charAt(i):null,i<e.length?we(i,i+1):we(i,i))}function Ce(){let t,n,s,o;const r=function(e){0===de&&_e(e)};return t=le,n=le,s=Ve(),s!==i?(r(T),61===e.charCodeAt(le)?(o=a,le++):o=i,o!==i?(s=[s,o],n=s):(le=n,n=i)):(le=n,n=i),n===i&&(n=null),s=Me(),s!==i?(ce=t,t=J(n,s)):(le=t,t=i),t}function Me(){let t,n,s,a,l,c;const u=function(e){0===de&&_e(e)};if(t=le,n=ke(),n!==i){s=[],a=le,u(S),94===e.charCodeAt(le)?(l=o,le++):l=i,l===i&&(u(N),e.substr(le,3)===r?(l=r,le+=3):l=i),l!==i?(c=ke(),c!==i?(l=[l,c],a=l):(le=a,a=i)):(le=a,a=i);while(a!==i)s.push(a),a=le,u(S),94===e.charCodeAt(le)?(l=o,le++):l=i,l===i&&(u(N),e.substr(le,3)===r?(l=r,le+=3):l=i),l!==i?(c=ke(),c!==i?(l=[l,c],a=l):(le=a,a=i)):(le=a,a=i);ce=t,t=Y(n,s)}else le=t,t=i;return t}function ke(){let t,n,s,a,o,r;const u=function(e){0===de&&_e(e)};if(t=le,n=Te(),n!==i){s=[],a=le,u(B),e.substr(le,3)===l?(o=l,le+=3):o=i,o===i&&(u(F),e.substr(le,4)===c?(o=c,le+=4):o=i),o!==i?(r=Te(),r!==i?(o=[o,r],a=o):(le=a,a=i)):(le=a,a=i);while(a!==i)s.push(a),a=le,u(B),e.substr(le,3)===l?(o=l,le+=3):o=i,o===i&&(u(F),e.substr(le,4)===c?(o=c,le+=4):o=i),o!==i?(r=Te(),r!==i?(o=[o,r],a=o):(le=a,a=i)):(le=a,a=i);ce=t,t=Q(n,s)}else le=t,t=i;return t}function Te(){let t,n,s,a,o,r;const l=function(e){0===de&&_e(e)};if(t=le,n=Se(),n!==i){s=[],a=le,l(L),e.substr(le,3)===u?(o=u,le+=3):o=i,o!==i?(r=Se(),r!==i?(o=[o,r],a=o):(le=a,a=i)):(le=a,a=i);while(a!==i)s.push(a),a=le,l(L),e.substr(le,3)===u?(o=u,le+=3):o=i,o!==i?(r=Se(),r!==i?(o=[o,r],a=o):(le=a,a=i)):(le=a,a=i);ce=t,t=ee(n,s)}else le=t,t=i;return t}function Se(){let t,n,s,a,o,r;const l=function(e){0===de&&_e(e)};if(t=le,n=Ne(),n!==i){s=[],a=le,l(A),43===e.charCodeAt(le)?(o=h,le++):o=i,o===i&&(l(V),124===e.charCodeAt(le)?(o=d,le++):o=i,o===i&&(l(I),e.substr(le,2)===m?(o=m,le+=2):o=i)),o!==i?(r=Ne(),r!==i?(o=[o,r],a=o):(le=a,a=i)):(le=a,a=i);while(a!==i)s.push(a),a=le,l(A),43===e.charCodeAt(le)?(o=h,le++):o=i,o===i&&(l(V),124===e.charCodeAt(le)?(o=d,le++):o=i,o===i&&(l(I),e.substr(le,2)===m?(o=m,le+=2):o=i)),o!==i?(r=Ne(),r!==i?(o=[o,r],a=o):(le=a,a=i)):(le=a,a=i);ce=t,t=te(n,s)}else le=t,t=i;return t}function Ne(){let t,n,s,a,o,r;const l=function(e){0===de&&_e(e)};if(t=le,n=Be(),n!==i){s=[],a=le,l(D),e.substr(le,4)===p?(o=p,le+=4):o=i,o!==i?(r=Be(),r!==i?(o=[o,r],a=o):(le=a,a=i)):(le=a,a=i);while(a!==i)s.push(a),a=le,l(D),e.substr(le,4)===p?(o=p,le+=4):o=i,o!==i?(r=Be(),r!==i?(o=[o,r],a=o):(le=a,a=i)):(le=a,a=i);ce=t,t=ie(n,s)}else le=t,t=i;return t}function Be(){let t,n,s,a,o,r;const l=function(e){0===de&&_e(e)};if(t=le,n=Fe(),n!==i){s=[],a=le,l(P),42===e.charCodeAt(le)?(o=f,le++):o=i,o===i&&(l(O),38===e.charCodeAt(le)?(o=g,le++):o=i,o===i&&(l(j),e.substr(le,3)===b?(o=b,le+=3):o=i)),o!==i?(r=Fe(),r!==i?(o=[o,r],a=o):(le=a,a=i)):(le=a,a=i);while(a!==i)s.push(a),a=le,l(P),42===e.charCodeAt(le)?(o=f,le++):o=i,o===i&&(l(O),38===e.charCodeAt(le)?(o=g,le++):o=i,o===i&&(l(j),e.substr(le,3)===b?(o=b,le+=3):o=i)),o!==i?(r=Fe(),r!==i?(o=[o,r],a=o):(le=a,a=i)):(le=a,a=i);ce=t,t=ne(n,s)}else le=t,t=i;return t}function Fe(){let t,n,s,a;const o=function(e){0===de&&_e(e)};t=le,n=[],s=Pe();while(s!==i)n.push(s),s=Pe();return o(R),33===e.charCodeAt(le)?(s=v,le++):s=i,s===i&&(o(z),126===e.charCodeAt(le)?(s=w,le++):s=i,s===i&&(o(W),e.substr(le,3)===x?(s=x,le+=3):s=i)),s!==i?(a=Le(),a!==i?(ce=t,t=se(a)):(le=t,t=i)):(le=t,t=i),t===i&&(t=Le()),t}function Le(){let e,t,n,s;return e=Ve(),e===i&&(e=Ae(),e===i&&(e=le,t=Ie(),t!==i?(n=Me(),n!==i?(s=De(),s!==i?(ce=e,e=ae(n)):(le=e,e=i)):(le=e,e=i)):(le=e,e=i))),e}function Ae(){let t,n,s,a,o;const r=function(e){0===de&&_e(e)};t=le,n=[],s=Pe();while(s!==i)n.push(s),s=Pe();if(r(q),48===e.charCodeAt(le)?(s=_,le++):s=i,s===i&&(r(H),49===e.charCodeAt(le)?(s=$,le++):s=i),s!==i){a=[],o=Pe();while(o!==i)a.push(o),o=Pe();ce=t,t=oe(s)}else le=t,t=i;return t}function Ve(){let t,n,s,a,o,r,l;const c=function(e){0===de&&_e(e)};if(t=le,n=le,xe(),s=Oe(),$e(!0),s===i?n=void 0:(le=n,n=i),n!==i){s=[],a=Pe();while(a!==i)s.push(a),a=Pe();if(a=le,o=[],c(U),C.test(e.charAt(le))?(r=e.charAt(le),le++):r=i,r!==i)while(r!==i)o.push(r),c(U),C.test(e.charAt(le))?(r=e.charAt(le),le++):r=i;else o=i;if(o!==i){r=[],c(K),M.test(e.charAt(le))?(l=e.charAt(le),le++):l=i;while(l!==i)r.push(l),c(K),M.test(e.charAt(le))?(l=e.charAt(le),le++):l=i;o=[o,r],a=o}else le=a,a=i;if(a!==i){o=[],r=Pe();while(r!==i)o.push(r),r=Pe();ce=t,t=re(a)}else le=t,t=i}else le=t,t=i;return t}function Ie(){let t,n,s,a,o;const r=function(e){0===de&&_e(e)};t=le,n=[],s=Pe();while(s!==i)n.push(s),s=Pe();if(r(G),40===e.charCodeAt(le)?(s=y,le++):s=i,s!==i){a=[],o=Pe();while(o!==i)a.push(o),o=Pe();n=[n,s,a],t=n}else le=t,t=i;return t}function De(){let t,n,s,a,o;const r=function(e){0===de&&_e(e)};t=le,n=[],s=Pe();while(s!==i)n.push(s),s=Pe();if(r(X),41===e.charCodeAt(le)?(s=E,le++):s=i,s!==i){a=[],o=Pe();while(o!==i)a.push(o),o=Pe();n=[n,s,a],t=n}else le=t,t=i;return t}function Pe(){let t,n;const s=function(e){0===de&&_e(e)};if(t=[],s(Z),k.test(e.charAt(le))?(n=e.charAt(le),le++):n=i,n!==i)while(n!==i)t.push(n),s(Z),k.test(e.charAt(le))?(n=e.charAt(le),le++):n=i;else t=i;return t}function Oe(){let t;const n=function(e){0===de&&_e(e)};return n(j),e.substr(le,3)===b?(t=b,le+=3):t=i,t===i&&(n(I),e.substr(le,2)===m?(t=m,le+=2):t=i,t===i&&(n(N),e.substr(le,3)===r?(t=r,le+=3):t=i,t===i&&(n(W),e.substr(le,3)===x?(t=x,le+=3):t=i,t===i&&(n(F),e.substr(le,4)===c?(t=c,le+=4):t=i,t===i&&(n(D),e.substr(le,4)===p?(t=p,le+=4):t=i,t===i&&(n(L),e.substr(le,3)===u?(t=u,le+=3):t=i)))))),t}const je=t.BooleanOperation,Re=t.makeBooleanFunction,ze=t.makeBooleanOperation,We=t.makeBooleanVariable,qe=t.makeBooleanLiteral;if(xe(),me=s(),me!==i&&le===e.length)return me;throw me!==i&&le<e.length&&_e(ge()),Ee()}ha(da,Error),da.buildMessage=function(e,t){const i={literal(e){return`"${s(e.text)}"`},class(e){const t=e.parts.map((e=>Array.isArray(e)?`${a(e[0])}-${a(e[1])}`:a(e)));return`[${e.inverted?"^":""}${t}]`},any(){return"any character"},end(){return"end of input"},other(e){return e.description},not(e){return`not ${o(e.expected)}`}};function n(e){return e.charCodeAt(0).toString(16).toUpperCase()}function s(e){return e.replace(/\\/g,"\\\\").replace(/"/g,'\\"').replace(/\0/g,"\\0").replace(/\t/g,"\\t").replace(/\n/g,"\\n").replace(/\r/g,"\\r").replace(/[\x00-\x0F]/g,(e=>`\\x0${n(e)}`)).replace(/[\x10-\x1F\x7F-\x9F]/g,(e=>`\\x${n(e)}`))}function a(e){return e.replace(/\\/g,"\\\\").replace(/\]/g,"\\]").replace(/\^/g,"\\^").replace(/-/g,"\\-").replace(/\0/g,"\\0").replace(/\t/g,"\\t").replace(/\n/g,"\\n").replace(/\r/g,"\\r").replace(/[\x00-\x0F]/g,(e=>`\\x0${n(e)}`)).replace(/[\x10-\x1F\x7F-\x9F]/g,(e=>`\\x${n(e)}`))}function o(e){return i[e.type](e)}function r(e){const t=e.map(o);let i,n;if(t.sort(),t.length>0){for(i=1,n=1;i<t.length;i++)t[i-1]!==t[i]&&(t[n]=t[i],n++);t.length=n}switch(t.length){case 1:return t[0];case 2:return`${t[0]} or ${t[1]}`;default:return`${t.slice(0,-1).join(", ")}, or ${t[t.length-1]}`}}function l(e){return e?`"${s(e)}"`:"end of input"}return`Expected ${r(e)} but ${l(t)} found.`};i(7642),i(8004),i(3853),i(5876),i(2475),i(5024),i(1698);const pa={OPERATOR:"op",VARIABLE:"var",LITERAL:"lit"};class fa{hasChildren(){return!1}children(){return[]}}class ga extends fa{constructor(e){super(),this.kind=pa.VARIABLE,this.name=e}toString(){return this.name}eval(e){return e[this.name]}}function ba(e){return new ga(e)}function va(e){if(e instanceof ga)return[e.name];const t=e.children();let i=[];for(let n=0;n<t.length;n+=1)i=i.concat(va(t[n]));return i}class wa{constructor(e,t,i){this.name=e,this.expression=t,this.variables=i?new Set(i.concat(va(t))):new Set(va(t))}toString(){return`${this.name}(${[...this.variables].join(",")}) = ${this.expression.toString()}`}toLatex(){return`$${this.name}(${[...this.variables].join(",")}) = ${this.expression.toLatex()}$`}eval(e){return this.expression.eval(e)}}function xa(e,t){return new wa(e,t,null)}class _a extends fa{constructor(e){super(),this.kind=pa.LITERAL,this.value="0"!==e&&("1"===e||!!e)}toString(){return this.value?"1":"0"}eval(){return this.value}}function $a(e){return new _a(e)}const ya={NOT:"not",AND:"and",OR:"or",XOR:"xor",XNOR:"xnor",NAND:"nand",NOR:"nor",IMPLIES:"implies"},Ea={not(e){return!e},and(e,t){return e&&t},or(e,t){return e||t},xor(e,t){return e&&!t||!e&&t},xnor(e,t){return!(e&&!t||!e&&t)},nand(e,t){return!(e&&t)},nor(e,t){return!(e||t)},implies(e,t){return e||t}};class Ca extends fa{constructor(e,t,i){if(t.length<2)throw Error("at least two operands are required for an n-ary expression");super(),this.kind=pa.OPERATOR,this.operator=e,this.operands=t,this.hasParentheses=i}toString(){const e=this.operands.map((e=>e.toString())).join(` ${this.operator} `);return this.hasParentheses?`(${e})`:e}toStringWithoutParentheses(){return this.operands.map((e=>e.toString())).join(` ${this.operator} `)}toLatex(){const e=this.operands.map((e=>e.toLatex())).join(this.operator);return this.hasParentheses?`(${e})`:e}hasChildren(){return!0}children(){return this.operands}eval(e){let t=this.operands[0].eval(e);for(let i=1;i<this.operands.length;i+=1)t=Ea[this.operator](t,this.operands[i].eval(e));return t}}class Ma extends fa{constructor(e,t,i){if(1!==t.length)throw Error("exactly one operand is required for a unary expression");super(),this.kind=pa.OPERATOR,this.operator=e,[this.operand]=t,this.hasParentheses=i}toString(){const e=`${this.operator} ${this.operand}`;return this.hasParentheses?`(${e})`:e}hasChildren(){return!0}toLatex(){return this.operands}children(){return[this.operand]}eval(e){return Ea[this.operator](this.operands[0].eval(e))}}function ka(e,t,i){return e===ya.NOT?new Ma(e,[t],i):new Ca(e,t,i)}function Ta(e){return ma(e,{BooleanOperation:ya,makeBooleanOperation:ka,makeBooleanFunction:xa,makeBooleanLiteral:$a,makeBooleanVariable:ba})}function Sa(e){return Ta(e)}class Na{convertBaseTermsToStringFormat(e,t){const i=[];for(let n=0;n<e.length;n+=1)i.push(this.convertBaseTermToStringFormat(e[n],t));return i}convertBaseTermToStringFormat(e,t){let i="";const n=e.getTerms();void 0===t&&console.trace("error in BooleanFunctionUtil.js > convertBaseTermToStringFormat(..) \nNo globalAmountLiterals (2nd parameter) was given\n");for(let s=0;s<t;s+=1){const e=n.filter((e=>e.getId()===s));if(e.length>1)return console.trace("error in BooleanFunctionUtil.js > convertBaseTermToStringFormat(..) \nGiven baseTerm had multiple Literals with the same ID. Conversion to String format not possible. Returning null"),null;i=1===e.length?(e[0].isNegated()?"0":"1")+i:`-${i}`}return i}convertStringFormatBaseTermToBooleanFunction(e,t){const i=new la(t,[]);for(let n=0;n<e.length;n+=1){const t=e.length-1-n;"-"!==e[t]&&i.addTerm(new sa(n,"0"===e.charAt(t)))}return i}cloneBooleanFunctionArray(e){const t=[];for(let i=0;i<e.length;i+=1)t[i]=e[i].clone();return t}convertFinalPetrickSolutionToBooleanFunction(e,t){const i=e.primeTerms,n=e.cheapestSolution,s=new la(t,[]),a=e.PRIMETERM_SYMBOL_BASE_CHAR_CODE;for(let o=0;o<n.length;o+=1){const e=n.charCodeAt(o)-a;s.addTerm(i[e].clone())}return s}extractCheapestSolutionFromPetrickStatementObj(e,t){const i=e.primeTerms,n=e.steps[e.steps.length-1],s=n.bf.getTerms()[0].getTerms()[e.cheapestSolution],a=new la(t,[]);for(let o=0;o<s.getTerms().length;o+=1){const e=s.getTerms()[o].getId();a.addTerm(i[e].clone())}return a}sortBaseTermsByKVIndex(e){const t=[];for(let n=0;n<e.length;n+=1){const i=e[n],s=parseInt(i.getTerms().map((e=>e.isNegated()?"0":"1")).reverse().join(""),2);t[n]=s}const i=t.map(((t,i)=>[e[i],t])).sort(((e,t)=>Math.sign(e[1]-t[1])));return i.map((e=>e[0]))}primeTermCoversBaseTerm(e,t){for(let i=0;i<e.getTerms().length;i+=1){const n=e.getTerms()[i];if(void 0===t.getTerms().find((e=>e.equals(n))))return!1}return!0}convertMinTermsToMaxTerms(e){const t=[];for(let i=0;i<e.length;i+=1){const n=e[i],s=n.getTerms(),a=new la(oa,[]);t[i]=a;for(let e=0;e<s.length;e+=1)a.addTerm(new sa(s[e].getId(),!s[e].isNegated()))}return t}booleanFunctionContainsAnother(e,t){for(let i=0;i<t.getTerms().length;i+=1){const n=t.getTerms()[i];if(void 0===e.getTerms().find((e=>e.equals(n))))return!1}return!0}computeBinaryStringRepresentationOfBaseTerm(e,t){let i="";for(let n=t-1;n>=0;n-=1){const t=e.getTerms().find((e=>e.getId()===n));void 0===t?i+="-":t.isNegated()?i+="0":i+="1"}return i}generateKVDiagramFromTruthTable(e,t){const i=new ca(null,t),n=i.getValues()[0].length,s=i.getValues().length,a=[];for(let o=0;o<s;o+=1){a[o]=[];for(let e=0;e<n;e+=1)a[o][e]=0}for(let o=0;o<s;o+=1)for(let s=0;s<n;s+=1){const n=i.computeKVIndex(o,s).toString(2).padStart(t,"0");let r=0;for(let e=0;e<t;e+=1)"0"!==n[t-e-1]&&(r+=2**e);a[o][s]=e[r]}return new ca(a,t)}parseStringToBF(e,t=!1){const i=Sa(e),n=Array.from(i.variables);let s=this._parseCMOSBFToMinimizerRepresentation(i.expression,n);return t&&(s=this.flattenBF(this.expandBF(s))),{bf:s,variables:n}}_parseCMOSBFToMinimizerRepresentation(e,t){if(e instanceof Ma&&"not"===e.operator)return e.operand instanceof ga?new sa(t.findIndex((t=>t===e.operand.name)),!0):new la(ra,[this._parseCMOSBFToMinimizerRepresentation(e.operand,t)]);if(e instanceof ga)return new sa(t.findIndex((t=>t===e.name)),!1);if(e instanceof Ca){const i=[];for(const n of e.operands)i.push(this._parseCMOSBFToMinimizerRepresentation(n,t));return new la("or"===e.operator?oa:aa,i)}throw new Error(`ERROR in BooleanFunctionUtil>parse: term is of undefined type. term: ${e}`)}expandBF(e,t=!1){return e instanceof la?e.getLogicOperator()===ra?this.expandBF(e.getTerms()[0],!t):new la(t?e.getLogicOperator()===aa?oa:aa:e.getLogicOperator(),e.getTerms().map((e=>this.expandBF(e,t)))):e instanceof sa?new sa(e.getId(),t?!e.isNegated():e.isNegated()):e}flattenBF(e){if(e instanceof sa)return e;if(e.getLogicOperator()===ra)throw new Error("flattenBF(only works on fully expanded bfs (expand a bf via util.expandBF(bf))");const t=e.clone();for(let i=0;i<t.getTerms().length;i+=1){const e=t.getTerms()[i];if(e instanceof sa);else if(t.getLogicOperator()!==e.getLogicOperator())t.setTerm(i,this.flattenBF(e));else{t.setTerm(i,e.getTerms()[0]);for(let n=1;n<e.getTerms().length;n+=1){const s=e.getTerms()[n];t.injectTermBeforeIndex(i+n,s)}i-=1}}return t}generateKVDiagramFromBooleanFunction(e){const t=e.getIDs(),i=t.length,n=[],s=2**Math.floor((i+1)/2),a=2**Math.floor(i/2),o=new ca([],i);for(let r=0;r<s;r+=1)for(let t=0;t<a;t+=1){const s=o.computeKVIndex(t,r),a=s.toString(2).padStart(i,"0").split("").reverse();n[s]=Number(e.computeOutput(a))}return console.log("truthTable",n),this.generateKVDiagramFromTruthTable(n,i)}}function Ba(e){console.log("computeMinTermsFromKV",e);const t=[],i=e.getValues();for(let n=0;n<i.length;n+=1)for(let s=0;s<i[0].length;s+=1){if(1!==Number(i[n][s]))continue;const a=e.computeKVIndex(n,s);let o=a.toString(2);while(o.length<e.getAmountLiterals())o=`0${o}`;const r=new la(aa,[]);for(let e=0;e<o.length;e+=1)r.addTerm(new sa(e,"0"===o.charAt(o.length-1-e)));t.push(r)}return console.log("minTerms",t),t}function Fa(e){const t=[],i=e.getValues();for(let n=0;n<i.length;n+=1)for(let s=0;s<i[0].length;s+=1){if(0!==Number(i[n][s]))continue;const a=e.computeKVIndex(n,s);let o=a.toString(2);while(o.length<e.getAmountLiterals())o=`0${o}`;const r=new la(oa,[]);for(let e=0;e<o.length;e+=1)r.addTerm(new sa(e,"0"!==o.charAt(o.length-1-e)));t.push(r)}return t}function La(e){const t=[],i=e.getValues();for(let n=0;n<i.length;n+=1)for(let s=0;s<i[0].length;s+=1){if("-"!==i[n][s])continue;const a=e.computeKVIndex(n,s);let o=a.toString(2);while(o.length<e.getAmountLiterals())o=`0${o}`;const r=new la(aa,[]);for(let e=0;e<o.length;e+=1)r.addTerm(new sa(e,"0"===o.charAt(o.length-1-e)));t.push(r)}return t}function Aa(e,t,i){return e.substr(0,t)+i+e.substr(t+i.length)}function Va(e,t){if(!e||0===e.length)return console.error("error in _computeQuineCluskeyClasses(..): given MinOrMaxTerms was undefined or of length 0. Might be bc knf = 1 or dnf = 0."),null;const i=e[0].getLogicOperator()===aa,n=e[0].getTerms().length,s=new Na,a=s.convertBaseTermsToStringFormat(e,n),o=s.convertBaseTermsToStringFormat(t,n);if(!i)for(let u=0;u<o.length;u+=1){const e=o[u];let t="";for(let i=0;i<e.length;i+=1)"-"===e[i]?t+="-":"1"===e[i]?t+="0":t+="1";o[u]=t}const r=[];let l=n;r[l]=[];for(let u=0;u<=n;u+=1)r[l][u]=[];for(let u=0;u<a.length;u+=1){const e=a[u].replace(/[^1]/g,"").length;r[l][e].push([a[u],!1])}for(let u=0;u<o.length;u+=1){const e=o[u].replace(/[^1]/g,"").length;r[l][e].push([o[u],!1])}while(l>0){r[l-1]=[];for(let e=0;e<l;e+=1)r[l-1][e]=[];for(let e=l;e>0;e-=1){const t=r[l][e].length,i=r[l][e-1].length;if(t<1||i<1)continue;const s={};for(let a=0;a<t;a+=1)for(let t=0;t<i;t+=1){const i=r[l][e][a][0],o=r[l][e-1][t][0];let c=-1;for(let e=0;e<n;e+=1){const t=i.charAt(e),n=o.charAt(e);if(t!==n){if("-"===t||"-"===n){c=-2;break}if(-1!==c){c=-2;break}c=e}}if(c>=0){const n=Aa(i,c,"-");r[l][e][a][1]=!0,r[l][e-1][t][1]=!0,1!==s[n]&&(s[n]=1,r[l-1][e-1].push([n,!1]))}}}l-=1}const c=[];for(let u=0;u<r.length;u+=1){c[u]=[];for(let e=0;e<r[u].length;e+=1){c[u][e]=[];for(let t=0;t<r[u][e].length;t+=1)c[u][e][t]=[s.convertStringFormatBaseTermToBooleanFunction(r[u][e][t][0],i?aa:oa),r[u][e][t][1]]}c[u].reverse()}return c}function Ia(e,t,i){return{"min-terms":Va(e,i),"max-terms":Va(t,i)}}function Da(e,t){if(!t||0===t.length)return!1;const i=t[0].getTerms().length,n=new Na,s=2**(i-e.getTerms().length);let a=0;for(let o=0;o<t.length;o+=1)n.primeTermCoversBaseTerm(e,t[o])&&(a+=1);return a===s}function Pa(e,t){const i=[];for(let s=0;s<e.length;s+=1)for(let n=0;n<e[s].length;n+=1)for(let a=0;a<e[s][n].length;a+=1){const o=e[s][n][a];!0!==o[1]&&(i.includes(o[0])||Da(o[0],t)||i.push(o[0]))}const n=[];for(let s=0;s<i.length;s+=1)n.push(i[s].clone());return n}function Oa(e,t,i){return{"min-terms":Pa(e["min-terms"],t),"max-terms":Pa(e["max-terms"],i)}}const ja="found-core",Ra="cross-column-bc-covered",za="cross-row-bc-covered",Wa="row-domination",qa="column-domination",Ha="has-cyclic-rest";class Ua{constructor(e,{core:t,column:i,coveredBy:n,dominator:s,dominated:a,row:o}){this.actionType=e,this.core=t,this.column=i,this.row=o,this.coveredBy=n,this.dominator=s,this.dominated=a}}function Ka(e,t){const i=new Na,n={coverTable:null,steps:[],baseTerms:i.cloneBooleanFunctionArray(e),primeTerms:i.cloneBooleanFunctionArray(t)},s=[];for(let u=0;u<e.length;u+=1){s[u]=[];for(let i=0;i<t.length;i+=1)io(t[i],e[u])?s[u][i]=!0:s[u][i]=!1}n.coverTable=s;const a=[];for(let u=0;u<s.length;u+=1){a[u]=[];for(let e=0;e<s[0].length;e+=1)a[u][e]=-1}const o=[],r=[];Ja(n,a,o,r);let l=!0;while(!0===l)l=!1,l=Ya(n,a,o,r)||l,l=eo(n,a,o,r)||l,l=Qa(n,a,o,r,t)||l,l=Ja(n,a,o,r)||l;const c=!to(a,o,r);return n.cyclic=c,c&&n.steps.push(new Ua(Ha,{})),n}function Ga(e,t,i,n=!1){const s=new Na,a=n?s.sortBaseTermsByKVIndex(e):e,o=n?s.sortBaseTermsByKVIndex(t):t;return{"min-terms":Ka(a,i["min-terms"]),"max-terms":Ka(o,i["max-terms"])}}function Xa(e,t,i){for(let n=0;n<e[0].length;n+=1)1!==i[t][n]&&(i[t][n]=0)}function Za(e,t,i){for(let n=0;n<e.length;n+=1)i[n][t]=0}function Ja(e,t,i,n){let s=!1;const a=e.coverTable;for(let o=0;o<a.length;o+=1){if(n.includes(o))continue;let r=-1,l=!0;for(let e=0;e<a[0].length;e+=1)if(!0===a[o][e]&&-1===t[o][e]){if(-1!==r){l=!1;break}r=e}if(l){s=!0,e.steps.push(new Ua(ja,{core:r,column:o})),Xa(a,o,t),n.push(o),Za(a,r,t),i.push(r);for(let i=0;i<a.length;i+=1)o!==i&&(n.includes(i)||(!0===a[i][r]&&(Xa(a,i,t),n.push(i),e.steps.push(new Ua(Ra,{column:i,coveredBy:r}))),1!==t[i][r]&&(t[i][r]=0)));t[o][r]=1}}return s}function Ya(e,t,i,n){let s=!1;const a=e.coverTable;for(let o=0;o<a.length;o+=1)if(!n.includes(o))for(let r=0;r<a.length;r+=1){if(o===r||n.includes(r))continue;let l=!0;for(let e=0;e<a[0].length;e+=1)if(!i.includes(e)&&!1!==a[r][e]&&!a[o][e]){l=!1;break}l&&(s=!0,n.push(o),Xa(a,o,t),e.steps.push(new Ua(qa,{dominator:o,dominated:r})))}return s}function Qa(e,t,i,n,s){let a=!1;const o=e.coverTable;for(let r=0;r<o[0].length;r+=1)if(!i.includes(r))for(let l=0;l<o[0].length;l+=1){if(r===l||i.includes(l))continue;let c=!0;for(let e=0;e<o.length;e+=1)if(!n.includes(e)&&!1!==o[e][l]&&!o[e][r]){c=!1;break}if(!c)continue;const u=s[r].getTerms().length,h=s[l].getTerms().length;let d=!1;if(u<=h)d=!0;else for(let e=0;e<o[0].length;e+=1){if(e===r||e===l||i.includes(e))continue;const t=s[e].getTerms().length;if(!(u<=h+t))continue;let n=!0;for(let i=0;i<o.length;i+=1)if(!1!==o[i][r]&&!0!==o[i][l]&&!1===o[i][e]){n=!1;break}if(n){d=!1;break}}!1!==d&&(a=!0,i.push(l),Za(o,l,t),e.steps.push(new Ua(Wa,{dominator:r,dominated:l})))}return a}function eo(e,t,i,n){let s=!1;const a=e.coverTable;for(let o=0;o<a[0].length;o+=1){if(i.includes(o))continue;let n=!0;for(let e=0;e<a.length;e+=1)if(a[e][o]&&0!==t[e][o]){n=!1;break}n&&(Za(a,o,t),i.push(o),e.steps.push(new Ua(za,{row:o})),s=!0)}return s}function to(e,t,i){for(let n=0;n<e[0].length;n+=1)if(!t.includes(n))return!1;for(let n=0;n<e.length;n+=1)if(!i.includes(n))return!1;return!0}function io(e,t){const i=e.getTerms(),n=t.getTerms();for(let s=0;s<i.length;s+=1){let e=!1;for(let t=0;t<n.length;t+=1)if(i[s].equals(n[t])){e=!0;break}if(!e)return!1}return!0}const no="bf-ps-initial",so="bf-ps-distribution",ao="bf-ps-idempotence",oo="bf-ps-absorption",ro="bf-ps-sorting";function lo(e){return{"min-terms":co(e["min-terms"]),"max-terms":co(e["max-terms"])}}function co(e){const t=e.coverTable,i=new la(aa,[]);for(let g=0;g<t.length;g+=1){i.addTerm(new la(oa,[]));for(let e=0;e<t[0].length;e+=1)t[g][e]&&i.getTerms()[g].addTerm(new la(aa,[new sa(e,!1)]))}const n=new Na,s={steps:[new po(i,no)],primeTerms:n.cloneBooleanFunctionArray(e.primeTerms)};function a(e){s.steps.push(e)}function o(){return s.steps[s.steps.length-1]}i.getTerms().sort(((e,t)=>e.amountLiterals()-t.amountLiterals())),i.equals(o().bf,!0,!0)||a(new po(i,ro));const r=i.getTerms().length;mo(i);const l=i.getTerms().length;l!==r&&a(new po(i,oo)),i.getTerms().sort(((e,t)=>t.amountLiterals()-e.amountLiterals())),i.equals(o().bf,!0,!0)||a(new po(i,ro));while(i.getTerms().length>1){i.getTerms()[0]=uo(i.getTerms()[0],i.getTerms()[1]),i.getTerms().splice(1,1),a(new po(i,so));const e=i.getTerms()[0].getTerms();let t=!1;for(let i=0;i<e.length;i+=1){const n=e[i].getTerms().length;e[i]=new la(aa,ho(e[i].getTerms(),a));const s=e[i].getTerms().length;n!==s&&(t=!0)}t&&a(new po(i,ao));const n=i.getTerms()[0].getTerms().length;mo(i.getTerms()[0]);const s=i.getTerms()[0].getTerms().length;n!==s&&a(new po(i,oo))}const c=e.primeTerms,u=[];for(let g=0;g<c.length;g+=1)u[g]=c[g].getTerms().length;const h=[],d=i.getTerms()[0].getTerms(),m=d.length;for(let g=0;g<m;g+=1){h[g]=0;const e=d[g];for(let t=0;t<e.getTerms().length;t+=1){const i=e.getTerms()[t].getId();h[g]+=u[i]}h[g]+=e.getTerms().length}let p=h[0],f=0;for(let g=0;g<h.length;g+=1)h[g]<p&&(p=h[g],f=g);return s.cheapestSolution=f,s}function uo(e,t){const i=new la(oa,[]);for(let n=0;n<e.getTerms().length;n+=1)for(let s=0;s<t.getTerms().length;s+=1){const a=e.getTerms()[n].clone(),o=t.getTerms()[s];for(let e=0;e<o.getTerms().length;e+=1){const t=o.getTerms()[e];a.addTerm(t)}i.addTerm(a)}return i}function ho(e){const t=[];for(let i=e.length-1;i>=0;i-=1){const n=e[i];let s=!0;for(let t=0;t<i;t+=1)if(n.equals(e[t])){s=!1;break}s&&t.push(n)}return t}function mo(e){const t=new Na,i=e.getTerms().length,n=[];function s(e){n[e]=!0}const a=e.getTerms();for(let o=0;o<a.length;o+=1){const e=a[o];for(let i=0;i<a.length;i+=1){if(i===o)continue;if(!0===n[i])continue;const r=a[i];if(!(e.getTerms().length<r.getTerms().length)&&t.booleanFunctionContainsAnother(e,r)){s(o);break}}}for(let o=i-1;o>=0;o-=1)!0===n[o]&&e.spliceTerms(o,1)}class po{constructor(e,t){this.bf=e.clone(),this.actionType=t}}function fo(e){const t=new Na;return t.extractCheapestSolutionFromPetrickStatementObj(e["min-terms"],oa)}function go(e){const t=new Na;return t.extractCheapestSolutionFromPetrickStatementObj(e["max-terms"],aa)}class bo{computeDNFFromKV(e){const t=Ba(e);return this.computeDNF(t)}computeDNF(e){const t=[];for(let i=0;i<e.length;i+=1)t[i]=e[i].clone();return new la(oa,t)}computeKNFFromKV(e){const t=Fa(e);return this.computeKNF(t)}computeKNF(e){const t=[];for(let i=0;i<e.length;i+=1)t[i]=e[i].clone();return new la(aa,t)}}function vo(e){const t=new Na,i=Ba(e),n=Fa(e),s=La(e),a=t.convertMinTermsToMaxTerms(s),o=new bo,r=o.computeDNF(i),l=o.computeKNF(n);console.log("minTerms",i,"maxTerms",n,"dontCareMinTerms",s);const c=Ia(i,n,s),u=Oa(c,s,a),h=Ga(i,n,u,!0),d=lo(h),m=fo(d),p=go(d);return{dnf:r,knf:l,quineClasses:c,primes:u,primeTable:h,petrickStatement:d,dmf:m,kmf:p}}const wo="nand_double_negation",xo="nand_nor_to_and",_o="nand_redundant_and",$o="nor_nand_to_or",yo="nor_double_negation",Eo="nor_redundant_or";function Co(e){const t={};ko(e,e,t,0);let i,n=-1;while(t[++n]&&t[n].length>0);return n-=1,i=n<0?e:t[n][t[n].length-1].bf,So(i),{result:i,steps:t}}function Mo(e){const t={};To(e,e,t,0);let i,n=-1;while(t[++n]&&t[n].length>0);return n--,i=n<0?e:t[n][t[n].length-1].bf,So(i),{result:i,steps:t}}function ko(e,t,i,n){if(i[n]||(i[n]=[]),t instanceof la&&t.getLogicOperator()===ra){if(t.getTerms()[0]instanceof la&&t.getTerms()[0].getLogicOperator()===aa)for(const s of t.getTerms()[0].getTerms())ko(e,s,i,n+1);else if(t.getTerms()[0]instanceof la&&t.getTerms()[0].getLogicOperator()===oa){t.setLogicOperator(aa);const s=[];for(const e of t.getTerms()[0].getTerms())s.push(new la(ra,[e]));t.setTerms(s),i[n].push(new No(xo,e.clone())),t.setLogicOperator(ra),t.setTerms([new la(ra,[new la(aa,t.getTerms())])]),i[n].push(new No(wo,e.clone())),t.setTerms([new la(aa,[t.getTerms()[0],t.getTerms()[0]])]),i[n].push(new No(_o,e.clone()));for(const a of t.getTerms()[0].getTerms())ko(e,a,i,n+1)}else if(t.getTerms()[0]instanceof la&&t.getTerms()[0].getLogicOperator()===ra){t.setTerms([new la(aa,[t.getTerms()[0],t.getTerms()[0]])]),i[n].push(new No(_o,e.clone()));for(const s of t.getTerms()[0].getTerms())ko(e,s,i,n+1)}}else if(t instanceof la&&t.getLogicOperator()===aa){t.setLogicOperator(ra),t.setTerms([new la(ra,[new la(aa,t.getTerms())])]),i[n].push(new No(wo,e.clone())),t.setTerms([new la(aa,[t.getTerms()[0],t.getTerms()[0]])]),i[n].push(new No(_o,e.clone()));for(const s of t.getTerms()[0].getTerms())ko(e,s,i,n+1)}else if(t instanceof la&&t.getLogicOperator()===oa){t.setLogicOperator(ra),t.setTerms([new la(ra,[new la(oa,t.getTerms())])]),i[n].push(new No(wo,e.clone())),t.getTerms()[0].setLogicOperator(aa);const s=[];for(const e of t.getTerms()[0].getTerms()[0].getTerms())s.push(new la(ra,[e]));t.getTerms()[0].setTerms(s),i[n].push(new No(xo,e.clone()));for(const a of t.getTerms()[0].getTerms())ko(e,a,i,n+1)}}function To(e,t,i,n){if(i[n]||(i[n]=[]),t instanceof la&&t.getLogicOperator()===ra){if(t.getTerms()[0]instanceof la&&t.getTerms()[0].getLogicOperator()===oa)for(const s of t.getTerms()[0].getTerms())To(e,s,i,n+1);else if(t.getTerms()[0]instanceof la&&t.getTerms()[0].getLogicOperator()===aa){t.setLogicOperator(oa);const s=[];for(const e of t.getTerms()[0].getTerms())s.push(new la(ra,[e]));t.setTerms(s),i[n].push(new No($o,e.clone())),t.setLogicOperator(ra),t.setTerms([new la(ra,[new la(oa,t.getTerms())])]),i[n].push(new No(yo,e.clone())),t.setTerms([new la(oa,[t.getTerms()[0],t.getTerms()[0]])]),i[n].push(new No(Eo,e.clone()));for(const a of t.getTerms()[0].getTerms())To(e,a,i,n+1)}else if(t.getTerms()[0]instanceof la&&t.getTerms()[0].getLogicOperator()===ra){t.setTerms([new la(oa,[t.getTerms()[0],t.getTerms()[0]])]),i[n].push(new No(Eo,e.clone()));for(const s of t.getTerms()[0].getTerms())To(e,s,i,n+1)}}else if(t instanceof la&&t.getLogicOperator()===oa){t.setLogicOperator(ra),t.setTerms([new la(ra,[new la(oa,t.getTerms())])]),i[n].push(new No(yo,e.clone())),t.setTerms([new la(oa,[t.getTerms()[0],t.getTerms()[0]])]),i[n].push(new No(Eo,e.clone()));for(const s of t.getTerms()[0].getTerms())To(e,s,i,n+1)}else if(t instanceof la&&t.getLogicOperator()===aa){t.setLogicOperator(ra),t.setTerms([new la(ra,[new la(aa,t.getTerms())])]),i[n].push(new No(yo,e.clone())),t.getTerms()[0].setLogicOperator(oa);const s=[];for(const e of t.getTerms()[0].getTerms()[0].getTerms())s.push(new la(ra,[e]));t.getTerms()[0].setTerms(s),i[n].push(new No($o,e.clone()));for(const a of t.getTerms()[0].getTerms())To(e,a,i,n+1)}}function So(e){if(!(e instanceof sa))for(let t=0;t<e.getTerms().length;t++){const i=e.getTerms()[t];i instanceof la&&i.getLogicOperator()===ra&&i.getTerms()[0]instanceof sa?e.setTerm(t,new sa(i.getTerms()[0].getId(),!i.getTerms()[0].isNegated())):So(i)}}class No{constructor(e,t){this.actionType=e,this.bf=t}}function Bo(e){const t=e.t("sheet");return[{title:`${t} 5: 1a) i)`,handle:"5-1ai",data:new ca([["0","1"],["1","0"]],2)},{title:`${t} 5: 1a) ii)`,handle:"5-1aii",data:new ca([["0","0","1","0"],["0","0","1","1"]],3)},{title:`${t} 5: 1a) iii)`,handle:"5-1aiii",data:new ca([["0","0","0","0"],["1","1","0","0"]],3)},{title:`${t} 5: 1c)`,handle:"5-1c",data:new ca([["1","0","1","0"],["0","1","0","1"],["1","0","1","0"],["0","1","0","1"]],4)},{title:`${t} 5: 1d)`,handle:"5-1d",data:new ca([["1","0","0","1"],["0","1","1","0"],["0","1","1","0"],["1","0","0","1"]],4)},{title:`${t} 6: 2a) i)`,handle:"6-2ai",data:new ca([["0","0","1","1"],["1","0","1","1"]],3)},{title:`${t} 6: 2a) ii)`,handle:"6-2aii",data:new ca([["0","1","0","1"],["0","1","1","0"]],3)},{title:`${t} 7: 1b)`,handle:"7-1b",data:new ca([["-","0","1","0","0","1","0","-"],["0","1","1","0","0","1","1","0"],["1","1","1","-","1","1","1","1"],["-","1","1","0","0","1","1","1"]],5)},{title:`${t} 8: 1a)`,handle:"8-1a",data:new ca([["0","0","1","0"],["1","1","1","1"],["1","1","1","1"],["1","1","1","1"]],4)},{title:`${t} 8: 1b)`,handle:"8-1b",data:new ca([["0","0","1","0"],["1","1","1","0"],["1","1","1","1"],["1","1","0","1"]],4)},{title:e.t("bf_tableWithCyclicRest"),handle:"tableWithCyclicRest",data:new ca([["1","0","0","1"],["1","-","-","0"],["1","-","-","1"],["0","1","0","1"]],4)}]}function Fo(e){return Bo(e).map((e=>e.title))}function Lo(e,t){return Bo(e)[t]}function Ao(e,t){const i=Bo(e);for(let n=0;n<i.length;n+=1)if(i[n].handle===t)return n;return-1}const Vo={for:"numVarSelect"},Io={class:"mtop"},Do={class:"radioCounter"},Po=["value"],Oo=["innerHTML"],jo={class:""},Ro={key:0,class:"customNamingTable"},zo=["innerHTML"],Wo=["innerHTML"],qo=["onUpdate:modelValue","placeholder"],Ho={style:{"padding-top":"3px","padding-right":"10px"}},Uo={style:{"padding-top":"3px","padding-left":"10px"}};function Ko(e,t,i,s,a,o){const r=(0,m.g2)("FSelect"),l=(0,m.g2)("ToggleSwitch"),c=(0,m.g2)("KVDiagr"),u=(0,m.g2)("TruthTable");return(0,m.uX)(),(0,m.CE)("div",null,[(0,m.Lk)("div",null,[(0,m.Lk)("label",Vo,(0,p.v_)(e.$t("numVarInput"))+":",1),(0,m.bF)(r,{id:"numVarSelect",sel:this.dropDownMenuSelectedNumVars,onInput:o.onChooseNumVars,num:0,class:"leftMargin10",options:a.numVarOptions},null,8,["sel","onInput","options"])]),(0,m.Lk)("div",Io,[t[6]||(t[6]=(0,m.Lk)("div",{class:"divMargin"},null,-1)),(0,m.Lk)("div",Do,[((0,m.uX)(!0),(0,m.CE)(m.FK,null,(0,m.pI)(a.radios,(e=>((0,m.uX)(),(0,m.CE)("label",{key:e.value,class:"p-default p-round p-smooth p-pulse"},[(0,m.bo)((0,m.Lk)("input",{name:"varRadio",class:"mj",ref_for:!0,ref:"radios",type:"radio","onUpdate:modelValue":t[0]||(t[0]=e=>a.varNamingScheme=e),value:e.value},null,8,Po),[[n.XL,a.varNamingScheme]]),(0,m.Lk)("div",{class:"radioSvg",innerHTML:o.toSvg(e.name)},null,8,Oo)])))),128))])]),(0,m.Lk)("div",jo,["custom"===a.varNamingScheme?((0,m.uX)(),(0,m.CE)("table",Ro,[(0,m.Lk)("thead",null,[(0,m.Lk)("tr",null,[(0,m.Lk)("td",{innerHTML:o.toSvg("i")},null,8,zo),((0,m.uX)(!0),(0,m.CE)(m.FK,null,(0,m.pI)(a.customIndices,(e=>((0,m.uX)(),(0,m.CE)("th",{key:e},(0,p.v_)(e),1)))),128))])]),(0,m.Lk)("tbody",null,[(0,m.Lk)("tr",null,[(0,m.Lk)("td",{innerHTML:o.toSvg("\\alpha")},null,8,Wo),((0,m.uX)(!0),(0,m.CE)(m.FK,null,(0,m.pI)(a.customIndices,(e=>((0,m.uX)(),(0,m.CE)("td",{key:e},[(0,m.bo)((0,m.Lk)("input",{"onUpdate:modelValue":t=>a.customNamingScheme[e]=t,type:"text",placeholder:`a_${e}`},null,8,qo),[[n.Jo,a.customNamingScheme[e]]])])))),128))])])])):(0,m.Q3)("",!0)]),(0,m.Lk)("span",Ho,(0,p.v_)(e.$t("kvDiagram")),1),(0,m.bF)(l,{onToggle:this.toggleMethodOfInputForBooleanFunction,checkedDefault:"false"},null,8,["onToggle"]),(0,m.Lk)("span",Uo,(0,p.v_)(e.$t("truthtable")),1),(0,m.Lk)("div",null,[((0,m.uX)(),(0,m.Wv)(m.PR,null,[this.methodOfInputForBooleanFunction===this.METHOD_OF_INPUT_FOR_BOOLEAN_FUNCTION_KVDIAGRAM?((0,m.uX)(),(0,m.Wv)(c,{key:0,numVariables:this.numVariables,varNames:o.currentVarNames,onKvdiagramModified:t[1]||(t[1]=t=>o.onKVDiagramModified(t,e.kvdiagram)),onRequestingKvdiagramDataAfterReactivation:t[2]||(t[2]=e=>o.notifyChildKVDiagramOfBF()),class:"kvdiagram",ref:"childKVDiagram"},null,8,["numVariables","varNames"])):((0,m.uX)(),(0,m.Wv)(u,{key:1,numVariables:this.numVariables,varNames:this.currentVarNames,onTruthtableModified:t[3]||(t[3]=t=>o.onTruthTableModified(t,e.kvdiagram)),onRequestingBfAfterReactivation:t[4]||(t[4]=e=>o.notifyChildTruthTableOfBF()),ref:"childTruthTable"},null,8,["numVariables","varNames"]))],1024)),(0,m.Lk)("button",{class:"button-export-png",onClick:t[5]||(t[5]=e=>o.exportPNG())},"PNG")])])}const Go=["width","height"],Xo=["transform"],Zo=["transform"],Jo=["width","height","onClick"],Yo=["x","y"],Qo=["x","y"],er=["x","y","width","height"],tr=["transform","innerHTML"],ir=["x","y","width","height"];function nr(e,t,i,n,s,a){return(0,m.uX)(),(0,m.CE)("div",{class:"kvDiagram",onClick:t[0]||(t[0]=t=>e.$emit("clicked-somewhere",t))},[((0,m.uX)(),(0,m.CE)("svg",{id:"kvContainer",width:a.svgWidth,height:a.svgHeight,xmlns:"http://www.w3.org/2000/svg",ref:"svgdom"},[(0,m.Lk)("g",{transform:`translate(${s.extraWidths[1]}, 0)`},[((0,m.uX)(!0),(0,m.CE)(m.FK,null,(0,m.pI)(s.diagram,((e,t)=>((0,m.uX)(),(0,m.CE)("g",{key:`cell_${t}`,transform:`translate(${a.getX(t)}, ${a.getY(t)})`},[(0,m.Lk)("rect",{fill:"transparent",stroke:"#898989",width:s.blockWidth,height:s.blockWidth,onClick:e=>this.modifiable?a.changeNumber(t):{}},null,8,Jo),(0,m.Lk)("text",{x:s.blockWidth/2,y:s.blockWidth/2,"dominant-baseline":"middle",class:"unclickable","text-anchor":"middle"},(0,p.v_)(s.legitStates[e.number]),9,Yo),(0,m.Lk)("text",{x:s.blockWidth-3,y:s.blockWidth-7,"dominant-baseline":"middle",class:"unclickable indexNumber","font-size":"13","text-anchor":"end"},(0,p.v_)(a.indices[t].index),9,Qo)],8,Zo)))),128)),((0,m.uX)(!0),(0,m.CE)(m.FK,null,(0,m.pI)(a.literalBars,(e=>((0,m.uX)(),(0,m.CE)("g",{key:e.id},[(0,m.Lk)("rect",{x:e.x,y:e.y,width:e.width,height:e.height},null,8,er),(0,m.Lk)("g",{transform:`translate(${e.textX}, ${e.textY})`,ref_for:!0,ref:"bars",innerHTML:a.getSVG(e.index)},null,8,tr)])))),128)),(0,m.Lk)("rect",{id:"unclickable",class:"unclickable",fill:"none",stroke:"black",x:a.paddingHorizontal,y:a.paddingVertical,width:s.blockWidth*a.cellsHorizontal,height:s.blockWidth*a.cellsVertical},null,8,ir)],8,Xo)],8,Go))])}var sr={name:"KVDiagram",components:{},emits:["kvdiagram-modified","requesting-kvdiagram-data-after-reactivation","clicked-somewhere"],props:{numVariables:{type:Number,default:4},varNames:{type:Array,default:()=>[]},modifiable:{type:Boolean,default:!0}},watch:{numVariables(e,t){e===t||e<1||this.reconstruct()}},data(){return{indexBaseSystem:8,paddingBase:27,blockWidth:40,diagram:(0,Q.Kh)([]),legitStates:["0","1","-"],barHeight:3,barDistance:10,extraWidths:{0:0,1:0,2:0,3:0,4:0}}},created(){for(let e=0;e<this.cellsHorizontal*this.cellsVertical;e+=1)this.diagram.push({number:0});window.MathJax&&window.MathJax.typeset()},computed:{cellsHorizontal(){return 2**Math.floor((this.numVariables+1)/2)},cellsVertical(){return 2**Math.floor(this.numVariables/2)},paddingHorizontal(){return 10+this.paddingBase*(Math.floor(Math.abs(this.numVariables-2)/4)+1)},paddingVertical(){return 7+this.paddingBase*(Math.floor(Math.abs(this.numVariables-1)/4)+1)},svgWidth(){return 2*this.paddingHorizontal+this.cellsHorizontal*this.blockWidth+this.extraWidths[1]+this.extraWidths[3]},svgHeight(){return 2*this.paddingVertical+this.cellsVertical*this.blockWidth},coveredAreaPerVariable(){const e=[];for(let i=0;i<this.numVariables;i+=1){const t=Math.floor(i/2),n=2**t,s=[];for(let e=n;e<2*n;e+=1)s.push(e);for(let a=i-2;a>=0;a-=2){const t=e[a],i=t.length;for(let e=0;e<i;e+=1)t[2*i-1-e]=2*n-1-t[e];e[a]=t}e.push(s)}const t=[];for(let i=0;i<this.numVariables;i+=1)t.push({isVertical:i%2===0,varIndex:i,coveredRows:e[i]});return t},indices(){const e=[];for(let t=0;t<this.cellsHorizontal*this.cellsVertical;t+=1){const i=t%this.cellsHorizontal,n=Math.floor(t/this.cellsHorizontal);let s="";for(const e of this.coveredAreaPerVariable)e.isVertical?s+=e.coveredRows.includes(i)?"1":"0":s+=e.coveredRows.includes(n)?"1":"0";e.push({binary:s,index:parseInt(s.split("").reverse().join(""),2).toString(this.indexBaseSystem)})}return e},literalBars(){const e=[];for(const t of this.coveredAreaPerVariable){let i=t.coveredRows[0],n=t.coveredRows[0];const s=[];for(let e=1;e<t.coveredRows.length;e+=1)t.coveredRows[e]===n+1?n+=1:(s.push([i,n]),i=t.coveredRows[e],n=t.coveredRows[e]);s.push([i,n]);for(const[a,o]of s.entries()){const i=(o[1]-o[0]+1)*this.blockWidth,n=t.isVertical?i:this.barHeight,s=t.isVertical?this.barHeight:i,r=t.varIndex,l=`bar${t.varIndex}_${a}`,c=Math.floor(t.varIndex/4),u=this.barDistance+this.paddingBase*c;let h=0,d=0,m=0,p=0;t.isVertical?(h=this.paddingHorizontal+o[0]*this.blockWidth,d=t.varIndex%4===0?this.paddingVertical-u:this.paddingVertical+this.blockWidth*this.cellsVertical+u,m=h+n/2-5,p=t.varIndex%4===0?d-12:d+10):(h=(t.varIndex+1)%4===0?this.paddingHorizontal+this.blockWidth*this.cellsHorizontal+u:this.paddingHorizontal-u,d=this.paddingVertical+o[0]*this.blockWidth,m=(t.varIndex+1)%4===0?h+9:h-13,p=d+s/2-5,(t.varIndex+1)%4!==0&&(m-=this.extraWidths[t.varIndex])),e.push({x:h,y:d,width:n,height:s,textX:m,textY:p,index:r,id:l})}}return e}},activated(){this.$emit("requesting-kvdiagram-data-after-reactivation")},mounted(){this.$emit("requesting-kvdiagram-data-after-reactivation")},methods:{getKVDiagram(){const e=[];for(let i=0;i<this.cellsVertical;i+=1){e[i]=[];for(let t=0;t<this.cellsHorizontal;t+=1)e[i][t]=this.legitStates[this.diagram[i*this.cellsHorizontal+t].number]}const t=new ca(e,this.numVariables);return t},setKVDiagram(e){const t=(0,Q.Kh)([]);for(let n=0;n<this.cellsHorizontal*this.cellsVertical;n+=1)t.push({number:"0"});const i=e.getValues();for(let n=0;n<i.length;n+=1)for(let e=0;e<i[n].length;e+=1){const s=n*this.cellsHorizontal+e;t[s].number=this.legitStates.indexOf(i[n][e].toString())}this.diagram=t},getX(e){return this.paddingHorizontal+e%this.cellsHorizontal*this.blockWidth},getY(e){return this.paddingVertical+Math.floor(e/this.cellsHorizontal)*this.blockWidth},changeNumber(e){this.diagram[e].number=(this.diagram[e].number+1)%this.legitStates.length,this.$emit("kvdiagram-modified",this.getKVDiagram())},getSVG(e){const t=this.varNames[e];if(null==t)return"";const i=window.MathJax.tex2svg(t),n=i.getElementsByTagName("svg")[0],s=parseFloat(n.getAttribute("width").slice(0,-2)),a=Math.round(8*(s-1));return this.extraWidths[e]=a,n.outerHTML},toSvg(e){const t=window.MathJax.tex2svg(e),i=t.getElementsByTagName("svg")[0];return i.outerHTML},reconstruct(){this.diagram=(0,Q.Kh)([]);for(let e=0;e<this.cellsHorizontal*this.cellsVertical;e+=1)this.diagram.push({number:"0"})},getSVGDOM(){return this.$refs.svgdom}}};const ar=(0,z.A)(sr,[["render",nr]]);var or=ar;const rr=["width","height"],lr=["transform"],cr=["transform","innerHTML"],ur=["transform"],hr=["transform","innerHTML"],dr=["x","y","width"],mr=["transform"],pr=["transform","innerHTML"],fr=["x","y","height"],gr=["transform"],br=["x","y"],vr=["x","y","height"],wr=["transform"],xr=["x","y"],_r=["width","height","onClick"];function $r(e,t,i,n,s,a){return(0,m.uX)(),(0,m.CE)("div",{class:"truthTable",onClick:t[0]||(t[0]=t=>e.$emit("clicked-somewhere",t))},[((0,m.uX)(),(0,m.CE)("svg",{class:"truthtableContainer",width:a.svgWidth(),height:a.svgHeight(),xmlns:"http://www.w3.org/2000/svg",ref:"svgdom"},[(0,m.Lk)("g",null,[((0,m.uX)(!0),(0,m.CE)(m.FK,null,(0,m.pI)(i.numVariables,(e=>((0,m.uX)(),(0,m.CE)("g",{key:`inputvariablename_cell_${e}`,transform:`translate(${a.getInputCellSVGX(e-1)}, 0)`},[(0,m.Lk)("g",{transform:`translate(${.2*s.cell_width}, ${s.cell_height*(a.isSmallCharacter(i.varNames[i.numVariables-e])?.4:.2)})`,"dominant-baseline":"bottom",class:"unclickable entry header_entry","text-anchor":"bottom",innerHTML:a.toSvg(i.varNames[i.numVariables-e])},null,8,cr)],8,lr)))),128)),(0,m.Lk)("g",{transform:`translate(${a.getResultCellSVGX()}, 0)`},[(0,m.Lk)("g",{transform:`translate(${.2*s.cell_width}, ${.2*s.cell_height})`,"dominant-baseline":"middle",class:"unclickable entry header_entry","text-anchor":"middle",innerHTML:a.toSvg("f")},null,8,hr)],8,ur)]),(0,m.Lk)("rect",{x:a.getHorizontalBarBelowHeaderSVGX(),y:a.getHorizontalBarBelowHeaderSVGY(),width:a.svgWidth(),height:1},null,8,dr),((0,m.uX)(!0),(0,m.CE)(m.FK,null,(0,m.pI)(a.inputCellsVertical+1,(e=>((0,m.uX)(),(0,m.CE)("g",{key:`indexcell_${e}`,transform:`translate(${a.getIndexCellSVGX()}, ${a.getIndexCellSVGY(e-1)})`},[(0,m.Lk)("g",{transform:`translate(${.2*s.cell_width}, ${.15*s.cell_height})`,"dominant-baseline":"middle",class:"unclickable entry index_entry","text-anchor":"middle",innerHTML:a.toSvg(a.num2indexHexString(e-1))},null,8,pr)],8,mr)))),128)),(0,m.Lk)("rect",{x:a.getVerticalBarLeftSVGX(),y:a.getVerticalBarLeftSVGY(),width:1,height:a.svgHeight()},null,8,fr),((0,m.uX)(!0),(0,m.CE)(m.FK,null,(0,m.pI)(s.table_inputs,((e,t)=>((0,m.uX)(),(0,m.CE)("g",{key:`rowArray_${t}`},[((0,m.uX)(!0),(0,m.CE)(m.FK,null,(0,m.pI)(e,((e,i)=>((0,m.uX)(),(0,m.CE)("g",{key:`cell_${i}`,transform:`translate(${a.getInputCellSVGX(i)}, ${a.getInputCellSVGY(t)})`},[(0,m.Lk)("text",{x:s.cell_width/2,y:s.cell_height/2,"dominant-baseline":"middle",class:"unclickable entry","text-anchor":"middle"},(0,p.v_)(e),9,br)],8,gr)))),128))])))),128)),(0,m.Lk)("rect",{x:a.getVerticalBarRightSVGX(),y:a.getVerticalBarRightSVGY(),width:1,height:a.svgHeight()},null,8,vr),((0,m.uX)(!0),(0,m.CE)(m.FK,null,(0,m.pI)(s.table_outputs,((e,t)=>((0,m.uX)(),(0,m.CE)("g",{key:`outputcell_${t}`,transform:`translate(${a.getResultCellSVGX()}, ${a.getResultCellSVGY(t)})`},[(0,m.Lk)("text",{x:s.cell_width/2,y:s.cell_height/2,"dominant-baseline":"middle",class:"unclickable entry result_entry_number","text-anchor":"middle"},(0,p.v_)(e),9,xr),(0,m.Lk)("rect",{fill:"transparent",width:s.cell_width,height:s.cell_height,class:"result_entry_iteractable",onClick:e=>this.modifiable?a.onClickResult(t):{}},null,8,_r)],8,wr)))),128))],8,rr))])}var yr={emits:["truthtable-modified","requesting-bf-after-reactivation","clicked-somewhere"],props:{numVariables:{type:Number,default:4},varNames:{type:Array,default:()=>[]},modifiable:{type:Boolean,default:!0}},watch:{numVariables(e,t){e===t||e<1||this.reconstruct()}},data(){return{table_inputs:(0,Q.Kh)([]),table_outputs:(0,Q.Kh)([]),cell_height:30,cell_width:25,header_height:37}},created(){this.clearTable(),window.MathJax&&window.MathJax.typeset()},computed:{inputCellsHorizontal(){return this.numVariables},inputCellsVertical(){return 2**this.numVariables}},activated(){this.$emit("requesting-bf-after-reactivation")},mounted(){this.$emit("requesting-bf-after-reactivation")},methods:{clearTable(){this.table_inputs=(0,Q.Kh)([]),this.table_outputs=(0,Q.Kh)([]);for(let e=0;e<this.inputCellsVertical;e+=1){this.table_outputs[e]="0",this.table_inputs[e]=[];const t=e.toString(2).padStart(this.numVariables,"0");for(let i=0;i<this.inputCellsHorizontal;i+=1)this.table_inputs[e].push(t[i])}},reconstruct(){this.clearTable()},onClickResult(e){this.table_outputs[e]=this.toggleState(this.table_outputs[e]),this.$emit("truthtable-modified",this.getKVDiagram())},toggleState(e){return 0===e||"0"===e?"1":"1"===e?"-":"0"},getKVDiagram(){const e=new Na;return e.generateKVDiagramFromTruthTable(this.table_outputs,this.numVariables)},setKVDiagram(e){this.table_outputs=(0,Q.Kh)([]);const t=e.getValues();for(let i=0;i<t.length;i+=1)for(let n=0;n<t[0].length;n+=1){const s=e.computeKVIndex(i,n);this.table_outputs[s]=t[i][n]}},toSvg(e){const t=window.MathJax.tex2svg(e),i=t.getElementsByTagName("svg")[0];return i.outerHTML},svgWidth(){return this.numVariables||console.error("numVariables was not passed to TruthTable\n"),this.getResultCellSVGX()+1.1*this.cell_width},svgHeight(){return this.header_height+this.inputCellsVertical*this.cell_height},getIndexCellSVGX(){return 0},getIndexCellSVGY(e){return this.header_height+e*this.cell_height},getIndexColumnWidth(){const e=2+Math.floor((Math.log(this.inputCellsVertical-1)-1)/Math.log(16))+1+1;return e*(this.cell_width/2)},getHorizontalBarBelowHeaderSVGX(){return 0},getHorizontalBarBelowHeaderSVGY(){return this.getInputCellSVGY(0)-5},getVerticalBarLeftSVGX(){return this.getIndexColumnWidth()+this.cell_width/4},getVerticalBarLeftSVGY(){return 0},getInputCellSVGX(e){return this.getVerticalBarLeftSVGX()+this.cell_width/4+e*this.cell_width},getInputCellSVGY(e){return this.getIndexCellSVGY(e)},getVerticalBarRightSVGX(){return this.getInputCellSVGX(this.numVariables-1)+1.5*this.cell_width},getVerticalBarRightSVGY(){return 0},getResultCellSVGX(){return this.getVerticalBarRightSVGX()+this.cell_width/4},getResultCellSVGY(e){return this.getInputCellSVGY(e)},isSmallCharacter(e){return!(e.includes("b")||e.includes("d")||e.includes("f")||e.includes("h")||e.includes("k")||e.includes("l")||e.includes("t"))},num2indexHexString(e){let t=e.toString(16).toUpperCase();const i=Math.floor((Math.log(this.inputCellsVertical-1)-1)/Math.log(16))+1;for(let n=t.length;n<i;n+=1)t=`0${t}`;return`0x${t}`},getSVGDOM(){return this.$refs.svgdom}}};const Er=(0,z.A)(yr,[["render",$r]]);var Cr=Er;const Mr={class:"switch"};function kr(e,t,i,n,s,a){return(0,m.uX)(),(0,m.CE)("label",Mr,[(0,m.Lk)("input",{type:"checkbox",onClick:t[0]||(t[0]=e=>a.toggle(e)),ref:"checkbox"},null,512),t[1]||(t[1]=(0,m.Lk)("span",{class:"slider round"},null,-1))])}var Tr={data(){return{checked:!1}},props:["checkedDefault"],mounted(){this.checked="true"===this.checkedDefault,this.$refs.checkbox.checked=this.checked,this.$emit("toggle",this.checked)},methods:{toggle(e){const t=e.target;this.checked=t.checked,this.$emit("toggle",this.checked)}}};const Sr=(0,z.A)(Tr,[["render",kr],["__scopeId","data-v-5b45b049"]]);var Nr=Sr,Br={name:"BooleanFunctionInputDevice",components:{KVDiagr:or,FSelect:Oe,TruthTable:Cr,ToggleSwitch:Nr},data(){return this.METHOD_OF_INPUT_FOR_BOOLEAN_FUNCTION_KVDIAGRAM="method_kvdiagram",this.METHOD_OF_INPUT_FOR_BOOLEAN_FUNCTION_FUNCTION_TABLE="method_function_table",this.DEFAULT_NUM_VARIABLES=4,{methodOfInputForBooleanFunction:this.METHOD_OF_INPUT_FOR_BOOLEAN_FUNCTION_KVDIAGRAM,booleanFunctionAsKVDiagram:new ca(null,this.DEFAULT_NUM_VARIABLES),numVariables:this.DEFAULT_NUM_VARIABLES,dropDownMenuSelectedNumVars:this.DEFAULT_NUM_VARIABLES,numVarOptions:{2:2,3:3,4:4,5:5},varNamingScheme:"xyz",radios:[{value:"abc",name:"a, b, \\dots"},{value:"xyz",name:"x, y, \\dots"},{value:"x",name:"x_0, x_1, \\dots"},{value:"x1",name:"x_1, x_2, \\dots"},{value:"custom",name:"custom"}],customIndices:[0,1,2,3,4],customNamingScheme:{0:"",1:"",2:"",3:"",4:""}}},created(){window.MathJax&&window.MathJax.typeset()},watch:{numVariables(e,t){e===t||e<1||(this.booleanFunctionAsKVDiagram=new ca(null,e))}},computed:{varNames(){return{custom:this.customNamingScheme,abc:["a","b","c","d","e","f","g"],xyz:["x","y","z","u","v","w","q"],x:["x_0","x_1","x_2","x_3","x_4","x_5","x_6"],x1:["x_1","x_2","x_3","x_4","x_5","x_6","x_7"]}},currentVarNames(){return this.varNames[this.varNamingScheme]}},methods:{setMethodOfInputForBooleanFunction(e){this.methodOfInputForBooleanFunction=e},toggleMethodOfInputForBooleanFunction(e){this.methodOfInputForBooleanFunction=e?this.METHOD_OF_INPUT_FOR_BOOLEAN_FUNCTION_FUNCTION_TABLE:this.METHOD_OF_INPUT_FOR_BOOLEAN_FUNCTION_KVDIAGRAM},onChooseNumVars(e,t){this.dropDownMenuSelectedNumVars=parseInt(t,10),this.setNumVar()},setNumVar(){this.numVariables=this.dropDownMenuSelectedNumVars},onKVDiagramModified(e){this.setBooleanFunctionFromKVDiagram(e)},onTruthTableModified(e){this.setBooleanFunctionFromKVDiagram(e)},setBooleanFunctionFromKVDiagram(e){this.booleanFunctionAsKVDiagram=e},async overwriteBFFromKVDiagram(e){await(this.numVariables=e.getAmountLiterals()),this.setBooleanFunctionFromKVDiagram(e),this.methodOfInputForBooleanFunction===this.METHOD_OF_INPUT_FOR_BOOLEAN_FUNCTION_FUNCTION_TABLE?this.notifyChildTruthTableOfBF():this.notifyChildKVDiagramOfBF()},getSVG(e){const t=this.varNames[this.varNamingScheme][e],i=window.MathJax.tex2svg(t),n=i.getElementsByTagName("svg")[0];return n.outerHTML},toSvg(e){const t=window.MathJax.tex2svg(e),i=t.getElementsByTagName("svg")[0];return i.outerHTML},notifyChildKVDiagramOfBF(){this.$refs.childKVDiagram.setKVDiagram(this.getBFAsKVDiagram())},notifyChildTruthTableOfBF(){this.$refs.childTruthTable.setKVDiagram(this.getBFAsKVDiagram())},injectCustomVariableNames(e){console.log(e);for(let t=0;t<5;t+=1)this.customNamingScheme[t]=t<e.length?e[t]:"";this.varNamingScheme="custom"},exportPNG(){let e;e=this.methodOfInputForBooleanFunction===this.METHOD_OF_INPUT_FOR_BOOLEAN_FUNCTION_FUNCTION_TABLE?this.$refs.childTruthTable.getSVGDOM():this.$refs.childKVDiagram.getSVGDOM();const t=document.createElement("canvas"),i=t.getContext("2d"),n=new Image,s=3;t.width=parseInt(e.getAttribute("width"),10)*s,n.width=t.width,t.height=parseInt(e.getAttribute("height"),10)*s,n.height=t.height,n.onload=()=>{i.drawImage(n,0,0,n.width,n.height);const e=t.toDataURL(),s=document.createElement("a");s.download="sym.png",s.href=e,s.click()};const a=(new XMLSerializer).serializeToString(e);n.src=`data:image/svg+xml,${encodeURIComponent(a)}`},getBFAsKVDiagram(){return this.booleanFunctionAsKVDiagram}}};const Fr=(0,z.A)(Br,[["render",Ko]]);var Lr=Fr;const Ar={class:"tabs"},Vr=["onClick"],Ir={class:"tab-content"};function Dr(e,t,i,n,s,a){return(0,m.uX)(),(0,m.CE)("div",null,[(0,m.Lk)("div",Ar,[((0,m.uX)(!0),(0,m.CE)(m.FK,null,(0,m.pI)(i.tabs,(t=>((0,m.uX)(),(0,m.CE)("button",{key:t,class:(0,p.C4)({active:t===s.selectedTab}),onClick:e=>a.selectTab(t)},(0,p.v_)(e.$t(t)),11,Vr)))),128))]),(0,m.Lk)("div",Ir,[(0,m.RG)(e.$slots,s.selectedTab,{},void 0,!0)])])}var Pr={props:{tabs:{type:Array,required:!0}},data(){return{selectedTab:this.tabs[0]}},methods:{selectTab(e){this.selectedTab=e}}};const Or=(0,z.A)(Pr,[["render",Dr],["__scopeId","data-v-902a0a2e"]]);var jr=Or;const Rr={class:"infoblob-container"},zr={class:"infoblob-text-container"};function Wr(e,t,i,n,s,a){const o=(0,m.g2)("font-awesome-icon");return(0,m.uX)(),(0,m.CE)("div",Rr,[(0,m.bF)(o,{icon:"info-circle"}),(0,m.Lk)("div",zr,[(0,m.RG)(e.$slots,"default",{},void 0,!0)])])}var qr={};const Hr=(0,z.A)(qr,[["render",Wr],["__scopeId","data-v-711c92db"]]);var Ur=Hr,Kr={name:"BooleanFunctionMinimizer",components:{Accordion:qe,AccordionItem:Ze,FSelect:Oe,ToggleSwitch:Nr,InfoBlob:Ur,BooleanFunctionInputDevice:Lr,KVDiagr:or,TruthTable:Cr,TabComponent:jr},data(){return{archivedExerciseSelectedIndex:0,stringInterpreterFormula:"",randomExerciseDifficultySelectedIndex:0,randomExerciseGoalSelectedIndex:0,indexBaseSystem:8,useMinNotMaxTermDisplayStyle:!0,loadFromArchiveOrFormula:!1,loadFromFormula_formulaError:!1,loadFromFormula_formulaErrorDetails:{},bfFromFormulaUnflattened:null,resultKVDiagram:{},resultNumVars:4,dnf:"",knf:"",quineClassesCurrent:[],quineClassesMin:[],quineClassesMax:[],primeTermsCurrent:"",primeTermsMin:"",primeTermsMax:"",primeTableCurrent:{},primeTableMin:{},primeTableMax:{},petrickStatementCurrent:{},petrickStatementMin:{},petrickStatementMax:{},dmf:"",kmf:"",nandOriginalBF:{},norOriginalBF:{},optimizationNAND:{},optimizationNOR:{},literalNames:[],someOptimizationsFinished:!1,showMsgKVDiagramMustNotBeEmptyOrFull:!1,quineClassesColorfulDisplayStyle:!1,quineClassesBinaryDisplayStyle:!1,primetableStepsAmount:0,primetableCurrentStepIndex:0}},created(){if(this.methodOfInputForBooleanFunction=this.METHOD_OF_INPUT_FOR_BOOLEAN_FUNCTION_KVDIAGRAM,window.MathJax&&window.MathJax.typeset(),window.MathJax)try{this.toSvg("(\\require{cancel})")}catch(e){}else console.error("Upon created() call of BooleanFunctionMinimizer comp. MathJax was not yet initialized.")},mounted(){this.loadExerciseFromURL()},computed:{randomExercisesDifficulties(){return[this.$t("easy"),this.$t("difficultyMiddle"),this.$t("difficultyHard")]},randomExercisesGoalsMetrics(){return[{title:this.$t("bf_goal_determine_DNF"),difficulties:[{numVarsMin:2,numVarsMax:3,numMintermsMin:2,numMintermsMax:4},{numVarsMin:3,numVarsMax:4,numMintermsMin:4,numMintermsMax:7},{numVarsMin:4,numVarsMax:5,numMintermsMin:6}]},{title:this.$t("bf_goal_determine_KNF"),difficulties:[{numVarsMin:2,numVarsMax:3,numMaxtermsMin:2,numMaxtermsMax:4},{numVarsMin:3,numVarsMax:4,numMaxtermsMin:4,numMaxtermsMax:7},{numVarsMin:4,numVarsMax:5,numMaxtermsMin:6}]},{title:this.$t("bf_goal_determine_prime_implicants"),difficulties:[{numVarsMin:2,numVarsMax:3,numPrimeimplicantsMin:1,numPrimeimplicantsMax:2},{numVarsMin:3,numVarsMax:4,numPrimeimplicantsMin:2,numPrimeimplicantsMax:4},{numVarsMin:4,numVarsMax:5,numMintermsMin:7,numPrimeimplicantsMin:3}]},{title:this.$t("bf_goal_determine_prime_implicates"),difficulties:[{numVarsMin:2,numVarsMax:3,numPrimeimplicatesMin:1,numPrimeimplicatesMax:2},{numVarsMin:3,numVarsMax:4,numPrimeimplicatesMin:2,numPrimeimplicatesMax:4},{numVarsMin:4,numVarsMax:5,numMaxtermsMin:7,numPrimeimplicatesMin:3}]}]},randomExercisesGoalsTitles(){return this.randomExercisesGoalsMetrics.map((e=>e.title))},primeTableColorMatrixObj(){const e=[];let t=-1,i=-1;const n=this.primeTableCurrent,s="primetable-cell-default",a="primetable-cell-core",o="primetable-cell-covered",r="primetable-cell-crossed-out";for(let l=0;l<=n.baseTerms.length;l+=1){e[l]=[];for(let t=0;t<=n.primeTerms.length;t+=1)e[l][t]=s}for(let l=0;l<this.primetableCurrentStepIndex;l+=1){const s=n.steps[l],c=s.actionType;switch(c){case ja:for(let t=0;t<e.length;t+=1)e[t][s.core+1]=a;for(let t=0;t<e[0].length;t+=1)e[s.column+1][t]=a;t=s.core+1,i=s.column+1;break;case Ra:for(let t=0;t<e[0].length;t+=1)e[s.column+1][t]=o;t=s.coveredBy+1,i=s.column+1;break;case za:for(let t=0;t<e.length;t+=1)e[t][s.row+1]=o;t=s.row+1,i=0;break;case Wa:for(let t=0;t<e.length;t+=1)e[t][s.dominated+1]=r;t=s.dominator+1,i=0;break;case qa:for(let t=0;t<e[0].length;t+=1)e[s.dominator+1][t]=r;t=0,i=s.dominated+1;break;case Ha:t=-1,i=-1;break;default:console.error(`err in cover table: specified actionType in Step object ('${c}') is unknown.`)}}return{matrix:e,highlightedCellRow:t,highlightedCellColumn:i}},primeTableCurrentExplanation(){const e=this.primeTableCurrent;if(0===this.primetableCurrentStepIndex)return this.$t("bf_covertable_step_description_initial",{ifMinTermsEinstelleElseNullstelle:this.useMinNotMaxTermDisplayStyle?this.$t("bf_einstelle"):this.$t("bf_nullstelle"),ifMinTermsEinstellenElseNullstellen:this.useMinNotMaxTermDisplayStyle?this.$t("bf_einstellen"):this.$t("bf_nullstellen"),ifMinTermsNullstelleElseEinstelle:this.useMinNotMaxTermDisplayStyle?this.$t("bf_nullstelle"):this.$t("bf_einstelle"),ifMinTermsNullstellenElseEinstellen:this.useMinNotMaxTermDisplayStyle?this.$t("bf_nullstellen"):this.$t("bf_einstellen")});const t=e.steps[this.primetableCurrentStepIndex-1];switch(t.actionType){case ja:return this.$t("bf_covertable_step_description_core_found",{columnName:this.primeTableBaseTermIndices[t.column],rowName:this.nthLetter(t.core+1),ifMinTermsEinstelleElseNullstelle:this.useMinNotMaxTermDisplayStyle?this.$t("bf_einstelle"):this.$t("bf_nullstelle"),ifMinTermsEinstellenElseNullstellen:this.useMinNotMaxTermDisplayStyle?this.$t("bf_einstellen"):this.$t("bf_nullstellen"),ifMinTermsNullstelleElseEinstelle:this.useMinNotMaxTermDisplayStyle?this.$t("bf_nullstelle"):this.$t("bf_einstelle"),ifMinTermsNullstellenElseEinstellen:this.useMinNotMaxTermDisplayStyle?this.$t("bf_nullstellen"):this.$t("bf_einstellen")});case Ra:return this.$t("bf_covertable_step_description_cross_column_bc_covered",{columnName:this.primeTableBaseTermIndices[t.column],rowName:this.nthLetter(t.coveredBy+1),ifMinTermsEinstelleElseNullstelle:this.useMinNotMaxTermDisplayStyle?this.$t("bf_einstelle"):this.$t("bf_nullstelle"),ifMinTermsEinstellenElseNullstellen:this.useMinNotMaxTermDisplayStyle?this.$t("bf_einstellen"):this.$t("bf_nullstellen"),ifMinTermsNullstelleElseEinstelle:this.useMinNotMaxTermDisplayStyle?this.$t("bf_nullstelle"):this.$t("bf_einstelle"),ifMinTermsNullstellenElseEinstellen:this.useMinNotMaxTermDisplayStyle?this.$t("bf_nullstellen"):this.$t("bf_einstellen")});case za:return this.$t("bf_covertable_step_description_cross_row_bc_covered",{rowName:this.nthLetter(t.row+1),ifMinTermsEinstelleElseNullstelle:this.useMinNotMaxTermDisplayStyle?this.$t("bf_einstelle"):this.$t("bf_nullstelle"),ifMinTermsEinstellenElseNullstellen:this.useMinNotMaxTermDisplayStyle?this.$t("bf_einstellen"):this.$t("bf_nullstellen"),ifMinTermsNullstelleElseEinstelle:this.useMinNotMaxTermDisplayStyle?this.$t("bf_nullstelle"):this.$t("bf_einstelle"),ifMinTermsNullstellenElseEinstellen:this.useMinNotMaxTermDisplayStyle?this.$t("bf_nullstellen"):this.$t("bf_einstellen")});case Wa:return this.$t("bf_covertable_step_description_row_domination",{dominatorName:this.nthLetter(t.dominator+1),dominatedName:this.nthLetter(t.dominated+1),ifMinTermsEinstelleElseNullstelle:this.useMinNotMaxTermDisplayStyle?this.$t("bf_einstelle"):this.$t("bf_nullstelle"),ifMinTermsEinstellenElseNullstellen:this.useMinNotMaxTermDisplayStyle?this.$t("bf_einstellen"):this.$t("bf_nullstellen"),ifMinTermsNullstelleElseEinstelle:this.useMinNotMaxTermDisplayStyle?this.$t("bf_nullstelle"):this.$t("bf_einstelle"),ifMinTermsNullstellenElseEinstellen:this.useMinNotMaxTermDisplayStyle?this.$t("bf_nullstellen"):this.$t("bf_einstellen")});case qa:return this.$t("bf_covertable_step_description_column_domination",{dominatorName:this.primeTableBaseTermIndices[t.dominator],dominatedName:this.primeTableBaseTermIndices[t.dominated],ifMinTermsEinstelleElseNullstelle:this.useMinNotMaxTermDisplayStyle?this.$t("bf_einstelle"):this.$t("bf_nullstelle"),ifMinTermsEinstellenElseNullstellen:this.useMinNotMaxTermDisplayStyle?this.$t("bf_einstellen"):this.$t("bf_nullstellen"),ifMinTermsNullstelleElseEinstelle:this.useMinNotMaxTermDisplayStyle?this.$t("bf_nullstelle"):this.$t("bf_einstelle"),ifMinTermsNullstellenElseEinstellen:this.useMinNotMaxTermDisplayStyle?this.$t("bf_nullstellen"):this.$t("bf_einstellen")});case Ha:return this.$t("bf_covertable_step_description_cyclic_rest",{ifMinTermsEinstelleElseNullstelle:this.useMinNotMaxTermDisplayStyle?this.$t("bf_einstelle"):this.$t("bf_nullstelle"),ifMinTermsEinstellenElseNullstellen:this.useMinNotMaxTermDisplayStyle?this.$t("bf_einstellen"):this.$t("bf_nullstellen"),ifMinTermsNullstelleElseEinstelle:this.useMinNotMaxTermDisplayStyle?this.$t("bf_nullstelle"):this.$t("bf_einstelle"),ifMinTermsNullstellenElseEinstellen:this.useMinNotMaxTermDisplayStyle?this.$t("bf_nullstellen"):this.$t("bf_einstellen")});default:return`ERROR: CoverTable: actionType of Step obj unknown: '${t.actionType}'`}},primeTableBaseTermIndices(){const e=this.primeTableCurrent.baseTerms,t=[];for(let i=0;i<e.length;i+=1){const n=e[i],s=parseInt(n.getTerms().map((e=>e.isNegated()?"0":"1")).reverse().join(""),2),a=s.toString(this.indexBaseSystem);t[i]=a}return t},archivedExerciseTitles(){return Fo(this.$i18n)}},methods:{selectArchivedExercise(e,t){this.archivedExerciseSelectedIndex=t},selectRandomExerciseDifficulty(e,t){this.randomExerciseDifficultySelectedIndex=t},selectRandomExerciseGoal(e,t){this.randomExerciseGoalSelectedIndex=t},optimize(){const e=this.$refs.childBooleanFunctionInputDevice,t=e.getBFAsKVDiagram(),i=e.currentVarNames;this.literalNames=i;const n=t.getAmountLiterals(),s=new Na;let a;try{a=vo(t),this.nandOriginalBF=this.bfFromFormulaUnflattened?this.bfFromFormulaUnflattened.clone():a.dmf.clone(),this.norOriginalBF=this.bfFromFormulaUnflattened?this.bfFromFormulaUnflattened.clone():a.kmf.clone(),this.optimizationNAND=Co(this.nandOriginalBF.clone()),this.optimizationNOR=Mo(this.norOriginalBF.clone())}catch(o){return this.showMsgKVDiagramMustNotBeEmptyOrFull=!0,void(this.someOptimizationsFinished=!1)}this.showMsgKVDiagramMustNotBeEmptyOrFull=!1,this.bfFromFormulaUnflattened=null,this.resultKVDiagram=t,this.resultNumVars=n;try{this.$refs.resultKVDiagram.setKVDiagram(t)}catch(r){}try{this.$refs.resultTruthTable.setKVDiagram(t)}catch(r){}this.dnf=a.dnf.toLatex(i),this.knf=a.knf.toLatex(i),this.quineClassesMin=a.quineClasses["min-terms"].map((e=>e.map((e=>e.map((e=>[e[0].toLatex(i),e[1],`\\text{${s.computeBinaryStringRepresentationOfBaseTerm(e[0],n)}}`])))).slice().reverse())).slice().reverse(),this.quineClassesMax=a.quineClasses["max-terms"].map((e=>e.map((e=>e.map((e=>[e[0].toLatex(i),e[1],`\\text{${s.computeBinaryStringRepresentationOfBaseTerm(e[0],n)}}`])))).slice().reverse())).slice().reverse(),this.primeTermsMin=a.primes["min-terms"].map((e=>e.toLatex(i))),this.primeTermsMax=a.primes["max-terms"].map((e=>e.toLatex(i))),this.primeTableMin=a.primeTable["min-terms"],this.primeTableMax=a.primeTable["max-terms"],this.petrickStatementMin=a.petrickStatement["min-terms"],this.petrickStatementMax=a.petrickStatement["max-terms"],this.dmf=a.dmf.toLatex(i),this.kmf=a.kmf.toLatex(i),this.updateMinMaxDisplayStyle(),this.resetPrimeTable(),this.someOptimizationsFinished=!0},changeQuineClassesDisplayStyle(e){this.quineClassesColorfulDisplayStyle=e},changeQuineClassesBinaryDisplayStyle(e){this.quineClassesBinaryDisplayStyle=e},toggleMinMaxTerms(e){this.useMinNotMaxTermDisplayStyle=!e,this.updateMinMaxDisplayStyle(),this.resetPrimeTable()},updateMinMaxDisplayStyle(){this.useMinNotMaxTermDisplayStyle?(this.quineClassesCurrent=this.quineClassesMin,this.primeTermsCurrent=this.primeTermsMin,this.primeTableCurrent=this.primeTableMin,this.petrickStatementCurrent=this.petrickStatementMin):(this.quineClassesCurrent=this.quineClassesMax,this.primeTermsCurrent=this.primeTermsMax,this.primeTableCurrent=this.primeTableMax,this.petrickStatementCurrent=this.petrickStatementMax)},updateResultKVDiagram(){this.$refs.resultKVDiagram.setKVDiagram(this.resultKVDiagram)},updateResultTruthtable(){this.$refs.resultTruthTable.setKVDiagram(this.resultKVDiagram)},toggleLoadFromArchiveOrFormula(e){this.loadFromArchiveOrFormula=!e},resetPrimeTable(){this.primetableCurrentStepIndex=0,this.primetableStepsAmount=this.primeTableCurrent.steps.length},primetableStepForward(){this.primetableCurrentStepIndex>=this.primetableStepsAmount||(this.primetableCurrentStepIndex+=1)},primetableStepBackward(){this.primetableCurrentStepIndex<=0||(this.primetableCurrentStepIndex-=1)},loadArchivedExercise(){const e=this.archivedExerciseSelectedIndex;if(e<0)return;const t=this.$refs.childBooleanFunctionInputDevice;t.overwriteBFFromKVDiagram(Lo(this.$i18n,e).data),this.someOptimizationsFinished=!1},loadBFFromString(e){const t=new Na;let i=null,n=null;try{i=t.parseStringToBF(e,!0),n=t.parseStringToBF(e,!1),this.loadFromFormula_formulaError=!1}catch(l){return this.loadFromFormula_formulaError=!0,void(this.loadFromFormula_formulaErrorDetails=l)}const s=i.bf,a=i.variables;this.bfFromFormulaUnflattened=n.bf;const o=t.generateKVDiagramFromBooleanFunction(s),r=this.$refs.childBooleanFunctionInputDevice;r.overwriteBFFromKVDiagram(o),r.injectCustomVariableNames(a)},generateRandomExercise(){function e(e,t,i){return(void 0===t.numMinterms||i.dnf.getTerms().length===t.numMinterms)&&(!(void 0!==t.numMintermsMin&&i.dnf.getTerms().length<t.numMintermsMin)&&(!(void 0!==t.numMintermsMax&&i.dnf.getTerms().length>t.numMintermsMax)&&((void 0===t.numMaxterms||i.knf.getTerms().length===t.numMaxterms)&&(!(void 0!==t.numMaxtermsMin&&i.knf.getTerms().length<t.numMaxtermsMin)&&(!(void 0!==t.numMaxtermsMax&&i.knf.getTerms().length>t.numMaxtermsMax)&&((void 0===t.numPrimeimplicants||i.primes["min-terms"].length===t.numPrimeimplicants)&&(!(void 0!==t.numPrimeimplicantsMin&&i.primes["min-terms"].length<t.numPrimeimplicantsMin)&&(!(void 0!==t.numPrimeimplicantsMax&&i.primes["min-terms"].length>t.numPrimeimplicantsMax)&&((void 0===t.numPrimeimplicates||i.primes["max-terms"].length===t.numPrimeimplicates)&&(!(void 0!==t.numPrimeimplicatesMin&&i.primes["max-terms"].length<t.numPrimeimplicatesMin)&&!(void 0!==t.numPrimeimplicatesMax&&i.primes["max-terms"].length>t.numPrimeimplicatesMax)))))))))))}const t=parseInt(this.randomExerciseGoalSelectedIndex,10),i=parseInt(this.randomExerciseDifficultySelectedIndex,10),n=this.randomExercisesGoalsMetrics[t].difficulties[i];let s,a,o=n.numVars;if(void 0===o){const e=n.numVarsMin||1,t=n.numVarsMax||6;o=Math.floor(Math.random()*(t-e+1))+e}do{s=ua(o,!0);const t=vo(s);a=e(s,n,t)}while(!a);const r=this.$refs.childBooleanFunctionInputDevice;r.overwriteBFFromKVDiagram(s),this.updateMinMaxDisplayStyle(),this.someOptimizationsFinished=!1},getTextFromPetrickStatementActionType(e){switch(e){case no:return"";case so:return this.$t("bf_distributionUC");case oo:return this.$t("bf_absorptionUC");case ao:return this.$t("bf_idempotenceUC");case ro:return this.$t("bf_sortingUC");default:return console.log("unrecognized actionType of Petrick statement step:"),console.log(e),e}},unblurDOM(e){if(!e||!e.target||!e.target.classList)return;if(e.target.classList.contains("blurred"))return void e.target.classList.remove("blurred");let t=e.target.parentNode;do{if(t.classList.contains("blurred"))return void t.classList.remove("blurred");t=t.parentNode}while(null!=t&&t.classList)},nthLetter(e){return String.fromCharCode("A".charCodeAt(0)+e-1)},toSvg(e){const t=window.MathJax.tex2svg(e),i=t.getElementsByTagName("svg")[0];return i.outerHTML},loadExerciseFromURL(){if(!this.$route.query)return;const e=this.$route.query.load;if(!e)return;const t=Ao(this.$i18n,e);-1!==t?(this.selectArchivedExercise(0,t),this.loadArchivedExercise(),this.$nextTick((()=>{this.$refs.archivedExercisesDropDownMenu.setSelected(t)}))):console.error("Unknown BooleanFunctionMinimizer-exercise handle: ",e)},getTextFromNANDificationStep(e){switch(e){case wo:return this.$t("bf_nandify_double_negation_text");case xo:return this.$t("bf_nandify_nor_to_and_text");case _o:return this.$t("bf_nandify_redundant_and_text");default:return`ERR_actionType: ${e}`}},getTextFromNORificationStep(e){switch(e){case yo:return this.$t("bf_norify_double_negation_text");case $o:return this.$t("bf_norify_nand_to_or_text");case Eo:return this.$t("bf_norify_redundant_or_text");default:return`ERR_actionType: ${e}`}}}};const Gr=(0,z.A)(Kr,[["render",na],["__scopeId","data-v-0ef7b4be"]]);var Xr=Gr;const Zr={style:{display:"flex","margin-bottom":"40px","margin-top":"0"}},Jr={style:{flex:"50%",padding:"15px"}},Yr=["src"],Qr={style:{flex:"50%",padding:"15px"}},el=["src"],tl=["innerHTML"];function il(e,t,i,n,s,a){return(0,m.uX)(),(0,m.CE)("div",null,[(0,m.Lk)("div",Zr,[(0,m.Lk)("div",Jr,[(0,m.Lk)("img",{src:s.codesign_logo,alt:"CODESIGN_LOGO",style:{width:"50%"}},null,8,Yr)]),(0,m.Lk)("div",Qr,[(0,m.Lk)("img",{src:s.fau_logo,alt:"FAU_Logo",style:{width:"50%"}},null,8,el)])]),(0,m.Lk)("div",{id:"equation",ref:"equation",innerHTML:s.math},null,8,tl)])}var nl=i.p+"img/FAU_logo.721b7d42.png",sl=i.p+"img/codesign.79ad4fa2.png",al={name:"DescriptionPDF",data(){return{math:"",fau_logo:nl,codesign_logo:sl}},beforeMount(){window.addEventListener("afterprint",(()=>{window.open(this.$route.params.returnRoute,"_self")}))},mounted(){this.compileMath()},updated(){this.$nextTick((()=>{setTimeout((()=>{window.print()}),250)}))},methods:{render(){const e=new jspdf.jsPDF("l","pt","a4");e.html(document.getElementById("equation"),{callback:function(e){const t=document.createElement("iframe");t.setAttribute("style","position:absolute;right:200px; top:200px; bottom:0; height:1000px; width:1000px"),document.body.appendChild(t),t.src=e.output("datauristring")}})},compileMath(){const e=document.getElementById("languageDropdown");e.style.visibility="collapse";const t=document.querySelector(".navbar");t.style.visibility="collapse";const i=document.getElementById("menu-btn");i.style.visibility="collapse";const n=document.querySelector(".menu-icon");n.style.visibility="hidden";const s=document.querySelector(".menu");s.style.visibility="collapse";const a=document.getElementById("logo");a.style.visibility="collapse",this.math=this.$route.params.math,this.$nextTick().then((()=>{window.MathJax&&window.MathJax.typeset()}))}}};const ol=(0,z.A)(al,[["render",il],["__scopeId","data-v-38232d38"]]);var rl=ol;const ll={class:"cmosContainer"},cl={class:"pageContainer"},ul=["innerHTML"],hl={class:"bodyContainer"},dl={class:"centering"},ml={class:"exercise-selection-container"},pl={class:"exercise-selection-container-subsection"},fl={class:"exercise-selection-container-subsection"},gl=["innerHTML"],bl={class:"exercise-selection-container-subsection"},vl=["innerHTML"],wl={key:0,class:"exercise-selection-container-subsection"},xl={class:"errormessage"},_l=["innerHTML"],$l=["innerHTML"],yl={key:1,class:"exercise-selection-container-subsection"},El={class:"errormessage"},Cl={class:"exercise-selection-container-subsection"},Ml=["innerHTML"],kl=["innerHTML"],Tl={key:0},Sl={class:"codeContainer"},Nl={class:"copyButton"},Bl={class:"tooltip",ref:"tooltip"},Fl=["innerHTML"];function Ll(e,t,i,s,a,o){const r=(0,m.g2)("InfoBlob"),l=(0,m.g2)("FSelect"),c=(0,m.g2)("TabComponent"),u=(0,m.g2)("font-awesome-icon");return(0,m.uX)(),(0,m.CE)("div",ll,[(0,m.Lk)("div",cl,[(0,m.Lk)("h3",null,[t[6]||(t[6]=(0,m.eW)("CMOS")),(0,m.bF)(r,null,{default:(0,m.k6)((()=>[(0,m.Lk)("span",{innerHTML:e.$t("cmos_infoblob_description")},null,8,ul)])),_:1})]),(0,m.Lk)("div",hl,[(0,m.Lk)("p",null,(0,p.v_)(e.$t("enter_cmos")),1),(0,m.Lk)("p",null,(0,p.v_)(e.$t("cmos_infoblob_input_description")),1),(0,m.Lk)("div",dl,[(0,m.Lk)("div",ml,[(0,m.bF)(c,{tabs:["archive","formula","randomExercise"]},{archive:(0,m.k6)((()=>[(0,m.Lk)("div",pl,[(0,m.Lk)("div",fl,[(0,m.Lk)("span",{innerHTML:e.$t("archive")},null,8,gl),(0,m.bF)(l,{options:o.archivedExerciseTitles,sel:0,class:"leftMargin10",onInput:o.selectArchivedExercise,ref:"archivedExercisesCMOSDropDownMenu"},null,8,["options","onInput"]),(0,m.Lk)("button",{onClick:t[0]||(t[0]=(...e)=>o.loadArchivedExercise&&o.loadArchivedExercise(...e)),type:"button"},(0,p.v_)(e.$t("load")),1)])])])),formula:(0,m.k6)((()=>[(0,m.Lk)("div",bl,[(0,m.Lk)("span",{style:{"padding-left":"10px"},innerHTML:e.$t("formula")},null,8,vl),(0,m.bo)((0,m.Lk)("input",{"onUpdate:modelValue":t[1]||(t[1]=e=>a.cmosFormula=e),class:"leftMargin10",size:"25"},null,512),[[n.Jo,a.cmosFormula]]),(0,m.Lk)("button",{onClick:t[2]||(t[2]=e=>o.generateCmos(a.cmosFormula))},(0,p.v_)(e.$t("translate_big")),1),null!=a.cmosError?((0,m.uX)(),(0,m.CE)("div",wl,[(0,m.Lk)("span",xl,[(0,m.Lk)("span",{innerHTML:`${e.$t("cmos_error_at_symbol")} `},null,8,_l),(0,m.Lk)("span",null," '"+(0,p.v_)(a.cmosError.found)+"' ",1),(0,m.Lk)("span",{innerHTML:`${e.$t("at_position")} `},null,8,$l),(0,m.Lk)("span",null,(0,p.v_)(a.cmosError.location.start.column),1)])])):(0,m.Q3)("",!0),null!=a.cmosErrorFormulaTooSimple?((0,m.uX)(),(0,m.CE)("div",yl,[(0,m.Lk)("span",El,[(0,m.Lk)("span",null,(0,p.v_)(e.$t("cmos_enter_more_than_one_variable")),1)])])):(0,m.Q3)("",!0)])])),randomExercise:(0,m.k6)((()=>[(0,m.Lk)("div",Cl,[(0,m.Lk)("div",null,[(0,m.Lk)("span",null,(0,p.v_)(e.$t("difficultyUC"))+":",1),(0,m.bF)(l,{options:o.randomExercisesDifficulties,sel:0,class:"leftMargin10",onInput:o.selectRandomExerciseDifficulty},null,8,["options","onInput"]),(0,m.Lk)("button",{onClick:t[3]||(t[3]=(...e)=>o.generateRandomExercise&&o.generateRandomExercise(...e))},(0,p.v_)(e.$t("load")),1)])])])),_:1})])]),a.renderedFormula?((0,m.uX)(),(0,m.CE)("h4",{key:0,id:"displayedFormula",innerHTML:`${e.$t("formula")}: ${a.renderedFormula}`},null,8,Ml)):(0,m.Q3)("",!0)]),(0,m.Lk)("div",{id:"cmosOutput",innerHTML:a.cmosOutput,class:"blurred",onMousedown:t[4]||(t[4]=(...e)=>o.unblurDOM&&o.unblurDOM(...e)),ref:"cmosOutput"},null,40,kl),a.latex?((0,m.uX)(),(0,m.CE)("h3",Tl,"Tikz Code")):(0,m.Q3)("",!0),(0,m.Lk)("div",Sl,[(0,m.Lk)("div",Nl,[(0,m.Lk)("button",{onClick:t[5]||(t[5]=(...e)=>o.copyToClipboard&&o.copyToClipboard(...e))},[(0,m.bF)(u,{icon:"copy"})]),(0,m.Lk)("span",Bl,"Copied",512)]),(0,m.Lk)("pre",null,[(0,m.Lk)("code",null,[((0,m.uX)(!0),(0,m.CE)(m.FK,null,(0,m.pI)(a.latex,((e,t)=>((0,m.uX)(),(0,m.CE)("span",{key:t,innerHTML:e,class:"codeLine"},null,8,Fl)))),128))])])])])])}var Al=i(1545);class Vl{constructor(e,t){this.children=[],this.parent=e,this.networkType=t}addChild(e){this.children.push(e)}}class Il extends Vl{constructor(e,t){super(e,t)}}class Dl extends Vl{constructor(e,t){super(e,t)}}const Pl={PULLUP:"pullup",PULLDOWN:"pulldown"};class Ol{constructor(e,t,i,n=null,s=null){this.name=e,this.id=null,this.parent=t,this.connectedTo=[],this.booleanExpression=i,this.pullUp=n,this.pullDown=s}setId(e){this.id=e}addConnection(e){this.connectedTo.push(e)}}const jl={PMOS:"pmos",NMOS:"nmos"};class Rl{constructor(e,t,i){this.src=t,this.type=e,this.parent=i}}class zl{constructor(e,t){this.name=e,this.connectedTo=[],this.booleanExpression=t}addConnection(e){this.connectedTo.push(e)}}class Wl{constructor(e){this.name=e?"1":"0",this.value=e&&!0,this.connectedTo=[]}addConnection(e){this.connectedTo.push(e)}}class ql{constructor(e){this.variables=[],this.literals=[],this.expressions=[],this.func=e}getExpressionByName(e){const t=this.expressions.filter((t=>t.name===e));return t.length>0?t[0]:null}getVariableByName(e){const t=this.variables.filter((t=>t.name===e));return t.length>0?t[0]:null}getLiteralByValue(e){const t=this.literals.filter((t=>t.value&&e||!t.value&&!e));return t.length>0?t[0]:null}generateExpression(e,t){const i=e.toString();if(e instanceof ga){const t=this.getVariableByName(e.name);return null==t&&this.variables.push(new zl(e.name,e)),t}if(null!=this.getExpressionByName(i))return this.getExpressionByName(i);const n=new Ol(e.toString(),this,e,null,null);return n.pullUp=this.generateNetwork(n,Pl.PULLUP,e,t),n.pullDown=this.generateNetwork(n,Pl.PULLDOWN,e,t),this.expressions.push(n),n}generateNetwork(e,t,i,n){const s=t===Pl.PULLUP?jl.PMOS:jl.NMOS;if(i instanceof _a){let t=this.getLiteralByValue(!i.value);null==t&&(t=new Wl(!i.value),this.literals.push(t));const n=new Rl(s,t,e);return t.addConnection(n),n}if(i instanceof ga){const t=this.generateExpression(new Ma(ya.NOT,[i],!1),n),a=new Rl(s,t,e);return t.addConnection(a),a}if(i instanceof Ca){if(i.operator===ya.AND){const s=t===Pl.PULLUP?new Il(e,t):new Dl(e,t);for(const e of i.operands)s.addChild(this.generateNetwork(s,t,e,n));return s}if(i.operator===ya.OR){const s=t===Pl.PULLUP?new Dl(e,t):new Il(e,t);for(const e of i.operands)s.addChild(this.generateNetwork(s,t,e,n));return s}throw Error("Unknown NAry-Operation found.")}if(i instanceof Ma){if(i.operator===ya.NOT){const t=i.operand;if(t instanceof ga){let i=this.getVariableByName(t.name);null==i&&(i=new zl(t.name,t),this.variables.push(i));const n=new Rl(s,i,e);return i.addConnection(n),n}const a=this.generateExpression(t,n),o=new Rl(s,a,e);return a.addConnection(o),o}throw Error("Unknown Unary-Operation found.")}throw Error("Unknown Expression-Type found.")}}class Hl{buildCMOS(e){let t=new ql(e);return this._generateExpression(t,e.expression),t=this._giveIds(t),t=this._flattenCMOS(t),t}_giveIds(e){for(let t=0;t<e.expressions.length;t+=1)e.expressions[t].setId(t);return e}_generateExpression(e,t,i){const n=t.toString();if(t instanceof ga){const i=e.getVariableByName(t.name);return null==i&&e.variables.push(new zl(t.name,t)),i}if(null!=e.getExpressionByName(n))return e.getExpressionByName(n);const s=new Ol(n,e,t,null,null);return s.pullUp=this._generateNetwork(e,s,Pl.PULLUP,t,i),s.pullDown=this._generateNetwork(e,s,Pl.PULLDOWN,t,i),e.expressions.push(s),s}_generateNetwork(e,t,i,n,s){if(n instanceof _a)return this._handleBooleanLiteral(e,t,i,n);if(n instanceof ga)return this._handleBooleanVariable(e,t,i,n,s);if(n instanceof Ca)return this._handleNAryExpression(e,t,i,n,s);if(n instanceof Ma)return this._handleUnaryExpression(e,t,i,n,s);throw Error("CMOSBuilder._generateNetwork(CMOS, CMOSElement, NetworkType, BooleanExpression, options): Unknown Expression-Type found.")}_handleBooleanLiteral(e,t,i,n){const s=i===Pl.PULLUP?jl.PMOS:jl.NMOS;let a=e.getLiteralByValue(!n.value);null==a&&(a=new Wl(!n.value),e.literals.push(a));const o=new Rl(s,a,t);return a.addConnection(o),o}_handleBooleanVariable(e,t,i,n,s){const a=i===Pl.PULLUP?jl.PMOS:jl.NMOS,o=this._generateExpression(e,new Ma(ya.NOT,[n],!1),s),r=new Rl(a,o,t);return o.addConnection(r),r}_handleNAryExpression(e,t,i,n,s){let a;if(n.operator===ya.AND)a=i===Pl.PULLUP?new Il(t,i):new Dl(t,i);else{if(n.operator!==ya.OR)throw Error("CMOSBuilder._handleNAryExpression(CMOS, CMOSElement, NetworkType, BooleanExpression, options): Unknown NAry-Operation found.");a=i===Pl.PULLUP?new Dl(t,i):new Il(t,i)}for(const o of n.operands)a.addChild(this._generateNetwork(e,a,i,o,s));return a}_handleUnaryExpression(e,t,i,n,s){const a=i===Pl.PULLUP?jl.PMOS:jl.NMOS;if(n.operator===ya.NOT){const i=n.operand;if(i instanceof ga){let n=e.getVariableByName(i.name);null==n&&(n=new zl(i.name,i),e.variables.push(n));const s=new Rl(a,n,t);return n.addConnection(s),s}const o=this._generateExpression(e,i,s),r=new Rl(a,o,t);return o.addConnection(r),r}throw Error("CMOSBuilder._handleUnaryExpression(CMOS, CMOSElement, NetworkType, BooleanExpression, options): Unknown Unary-Operation found.")}_flattenCMOS(e){const t=e;if(t instanceof ql)for(const i of t.expressions)this._flattenCMOS(i);else if(t instanceof Ol)this._flattenCMOS(t.pullUp),this._flattenCMOS(t.pullDown);else if(t instanceof Il){const e=t.children,i=[];let n=0;while(n<e.length){const s=e[n];if(s instanceof Il)for(const t of s.children)e.push(t);else s.parent=t,i.push(s);n+=1}t.children=i}else if(t instanceof Dl){const e=t.children,i=[];let n=0;while(n<e.length){const s=e[n];if(s instanceof Dl)for(const t of s.children)e.push(t);else s.parent=t,i.push(s);n+=1}t.children=i}return t}}const Ul={DRAIN:"D",SOURCE:"S",GATE:"G"};class Kl{constructor(e){this.root=e}}class Gl{constructor(e,t,i){this.x=e,this.y=t,this.parent=i,this.children=[]}addChild(e){return this.children.push(e),e}removeChild(e){for(let t=0;t<this.children.length;t+=1)if(this.children[t]===e)return this.children.splice(t,1),!0;return!1}findChildByPos(e,t){for(const i of this.children)if(i.x===e&&i.y===t)return i;return null}}class Xl extends Gl{constructor(e,t,i,n){super(e,t,i),this.containsPoint=n}}class Zl extends Gl{constructor(e,t,i,n,s){super(e,t,i),this.children=[],this.transistor=n,this.connectionType=s}}class Jl{getTransistorSVG(e,t,i){const n={x:t.x+t.width-e.info.transistorPadRight,y:t.y},s=[`<path fill="none" stroke="black" d="M ${n.x*i} ${n.y*i}`,"V "+(n.y+e.info.transistorPadTop+.3*e.info.transistorHeight)*i,"H "+(n.x-.5*e.info.transistorWidth)*i,"V "+(n.y+e.info.transistorPadTop+.2*e.info.transistorHeight)*i,"V "+(n.y+e.info.transistorPadTop+.8*e.info.transistorHeight)*i,"V "+(n.y+e.info.transistorPadTop+.7*e.info.transistorHeight)*i,"H "+n.x*i,"V "+(n.y+t.height)*i,'"/>'].join(" "),a=t.leftPad-e.info.transistorPadLeft,o=[`<path fill="none" stroke="black" d="M ${(t.x+a+e.info.transistorPadLeft)*i} ${(n.y+t.height/2)*i}`,"H "+(n.x-.6*e.info.transistorWidth)*i,"V "+(n.y+e.info.transistorPadTop+.3*e.info.transistorHeight)*i,"V "+(n.y+e.info.transistorPadTop+.7*e.info.transistorHeight)*i,'"/>'].join(" ");let r;if(t.content.type===jl.PMOS){const a=['<circle fill="white" stroke="black"',`cx="${(n.x-.7*e.info.transistorWidth)*i}"`,`cy="${(n.y+t.height/2)*i}"`,`r="${.1*e.info.transistorWidth*i}"`,"/>"].join(" ");r=[s,o,a].join("\n")}else r=[s,o].join("\n");return r}placeTransistors(e,t){const i=[" ","\x3c!--TRANSISTORS--\x3e",""];for(const n of e.transistors)i.push(this.getTransistorSVG(e,n,t));return i.length>3?i.join("\n"):""}getWireSVG(e,t,i,n=!1){const s=[];if(t instanceof Xl){if(n)for(const n of t.children)s.push(`<path fill="none" stroke="black" d="M ${t.x*i} ${t.y*i}`),s.push(this.getWireSVG(e,n,i));else if(s.push(`L ${t.x*i} ${t.y*i}`),1===t.children.length)s.push(this.getWireSVG(e,t.children[0],i));else{s.push(`L ${t.x*i} ${t.y*i} "/>`);for(const n of t.children)s.push(`<path fill="none" stroke="black" d="M ${t.x*i} ${t.y*i}`),s.push(this.getWireSVG(e,n,i))}t.containsPoint&&s.push(`<circle cx="${t.x*i}" cy="${t.y*i}" r="2"/>`)}else t instanceof Zl&&s.push(`L ${t.x*i} ${t.y*i} "/>`);return s.join(" ")}placeConnectionWires(e,t){const i=[" ","\x3c!--CONNECTIONWIRES--\x3e",""];for(const n of e.connectionWires)i.push(this.getWireSVG(e,n.root,t,!0));return i.length>3?i.join("\n"):""}getExpressionTransistorLabel(e,t,i,n,s){const a={x:i.x+i.width-e.info.transistorPadRight-e.info.transistorWidth,y:i.y+e.info.transistorPadTop+e.info.transistorHeight/2};return`<text x="${(a.x-.1)*s}" y="${a.y*s}" font-size="${e.info.channelWidth*s}" text-anchor="end" dominant-baseline="middle">$${n(t.content.booleanExpression)}$</text>`}getExpressionWireLabel(e,t,i,n,s,a){return`<text x="${(i+.1)*a}" y="${n*a}" font-size="${e.info.channelWidth*a}" text-anchor="begin" dominant-baseline="middle">$${s(t.content.booleanExpression)}$</text>`}placeExpressionLabels(e,t,i){const n=[];if(e.info.tunnelExpressions){for(let s=0;s<e.children.length-1;s+=1){const a=e.children[s],o=a.getExitPoint();n.push(this.getExpressionWireLabel(e,a,a.x+a.width-a.content.name.length*e.info.charWidth,o.y,t,i))}for(let s=0;s<e.children.length-1;s+=1){const a=e.children[s];for(const s of a.content.connectedTo)n.push(this.getExpressionTransistorLabel(e,a,e.getTransistorByContent(s),t,i))}}const s=e.children[e.children.length-1],a=s.getExitPoint();return n.push(this.getExpressionWireLabel(e,s,e.x+e.width,a.y,t,i)),n.join("\n")}placeExpressionWires(e,t){const i=[" ","\x3c!--EXPRESSIONWIRES--\x3e",""];for(const n of e.expressionWires)i.push(this.getWireSVG(e,n.root,t,!0));return i.length>3?i.join("\n"):""}getExpressionSVG(e,t,i){return[this.placeExpressionWires(e,i),this.placeExpressionLabels(e,t,i)].join("\n")}getVariableTransistorLabel(e,t,i,n,s){const a={x:i.x+i.width-e.info.transistorPadRight-e.info.transistorWidth,y:i.y+e.info.transistorPadTop+e.info.transistorHeight/2};return`<text x="${(a.x-.1)*s}" y="${a.y*s}" font-size="${e.info.channelWidth*s}" text-anchor="end" dominant-baseline="middle">$${n(t.content.booleanExpression)}$</text>`}placeVariableLabels(e,t,i){const n=[];for(const s of e.variables)for(const a of s.content.connectedTo)n.push(this.getVariableTransistorLabel(e,s,e.getTransistorByContent(a),t,i));return n.join("\n")}getVariableWireLabel(e,t,i,n,s,a){return`<text x="${(i-.1)*a}" y="${n*a}" font-size="${e.info.channelWidth*a}" text-anchor="end" dominant-baseline="middle">$${s(t.content.booleanExpression)}$</text>`}placeVariableWires(e,t,i){const n=[" ","\x3c!--VARIABLEWIRES--\x3e",""];for(let s=0;s<e.variableWires.length;s+=1){const a=e.variables[s],o=e.variableWires[s];n.push(this.getVariableWireLabel(e,a,o.root.x,o.root.y,t,i)),n.push(this.getWireSVG(e,o.root,i,!0))}return n.length>3?n.join("\n"):""}getVariableSVG(e,t,i){return e.info.tunnelVariables?this.placeVariableLabels(e,t,i):this.placeVariableWires(e,t,i)}getLiteralTransistorLabel(e,t,i,n){const s={x:i.x+i.width-e.info.transistorPadRight-e.info.transistorWidth,y:i.y+e.info.transistorPadTop+e.info.transistorHeight/2},a=t.content.value?"1":"0";return`<text x="${(s.x-.1)*n}" y="${s.y*n}" font-size="${e.info.channelWidth*n}" text-anchor="end" dominant-baseline="middle">$${a}$</text>`}placeLiteralLabels(e,t){const i=[];for(const n of e.literals)for(const s of n.content.connectedTo)i.push(this.getLiteralTransistorLabel(e,n,e.getTransistorByContent(s),t));return i.join("\n")}placeLiteralWires(e,t){const i=[" ","\x3c!--LITERALWIRES--\x3e",""];for(let n=0;n<e.literalWires.length;n+=1){const s=e.literalWires[n];i.push(this.getWireSVG(e,s.root,t,!0))}return i.length>3?i.join("\n"):""}getLiteralSVG(e,t){return e.info.tunnelLiterals?this.placeLiteralLabels(e,t):this.placeLiteralWires(e,t)}placeSupplyWires(e,t){const i=`<text x="${(e.x-.1)*t}" y="${e.y*t}" font-size="16" text-anchor="end" dominant-baseline="middle">VCC</text>`,n=`<text x="${(e.x-.1)*t}" y="${(e.y+e.height)*t}" font-size="16" text-anchor="end" dominant-baseline="middle">GND</text>`,s=`<path fill="none" stroke-width="2px" stroke="black" d="M ${e.x*t} ${e.y*t} H ${(e.y+e.width+1)*t}" />`,a=`<path fill="none" stroke-width="2px" stroke="black" d="M ${e.x*t} ${(e.y+e.height)*t} H ${(e.y+e.width+1)*t}" />`;return[" ","\x3c!--SUPPLYWIRES--\x3e","",i,n,s,a].join("\n")}buildSVG(e,t,i=30){const n=["\n",`<svg viewBox="${-3*i} ${-3*i} ${e.width*i*2} ${e.height*i*2}" width="${e.width*i}" height="${e.height*i}">`,this.placeTransistors(e,i),this.placeConnectionWires(e,i),this.getExpressionSVG(e,t,i),this.getVariableSVG(e,t,i),this.getLiteralSVG(e,i),this.placeSupplyWires(e,i),"</svg>"].join("\n");return n}}class Yl{constructor(e,t){this.id=e,this.content=t,this.width=null,this.height=null,this.parent=null,this.x=null,this.y=null,this.x=null,this.y=null,this.upperConnectionPoint=null,this.lowerConnectionPoint=null}setSize(e,t){this.width=e,this.height=t}setPosition(e,t){this.x=e,this.y=t}setParent(e){this.parent=e}}class Ql extends Yl{constructor(e,t,i){super(e,t),this.info=i,this.children=[],this.transistors=[],this.variables=[],this.literals=[],this.connectionWires=[],this.literalWires=[],this.expressionWires=[],this.variableWires=[]}addChild(e){this.children.push(e)}addTransistor(e){this.transistors.push(e)}addVariable(e){this.variables.push(e)}addLiteral(e){this.literals.push(e)}containsVariable(e){return this.variables.map((e=>e.content)).includes(e)}addConnectionWire(e){this.connectionWires.push(e)}addLiteralWire(e){this.literalWires.push(e)}addExpressionWire(e){this.expressionWires.push(e)}addVariableWire(e){this.variableWires.push(e)}getTransistorByContent(e){for(let t=0;t<this.transistors.length;t+=1){const i=this.transistors[t];if(i.content===e)return i}return null}}class ec extends Yl{constructor(e,t){super(e,t),this.children=[],this.channels=[],this.entryPointTable={},this.exitPoint=null}addChild(e){this.children.push(e)}getChild(e){for(let t=0;t<this.children.length;t+=1){const i=this.children[t];if(i===e)return i}return null}addChannel(e){this.channels.includes(e)||(this.channels.push(e),this.channels.sort())}setExitPoint(e){this.exitPoint=e}getExitPoint(){return this.exitPoint}getEntryPoint(e){return this.entryPointTable[e]}}class tc extends Yl{constructor(e,t){super(e,t),this.children=[],this.channels=[],this.entryPointTable={}}addChild(e){this.children.push(e)}addChannel(e){this.channels.includes(e)||(this.channels.push(e),this.channels.sort())}getEntryPoint(e){return this.entryPointTable[e]}}class ic extends Yl{constructor(e,t){super(e,t),this.children=[],this.channels=[],this.neededChannels=[],this.entryPointTable={}}addChild(e){this.children.push(e)}addChannel(e){this.channels.includes(e)||(this.channels.push(e),this.channels.sort())}addNeededChannel(e){this.neededChannels.includes(e)||(this.neededChannels.push(e),this.neededChannels.sort())}getEntryPoint(e,t=null){let i=t;return null==i&&(i=this.children[0]),this.entryPointTable[[e,i.id]]}}class nc extends Yl{constructor(e,t){super(e,t),this.channels=[],this.entryPointTable={},this.leftPad=null}addChannel(e){this.channels.includes(e)||this.channels.push(e)}getEntryPoint(e){return this.entryPointTable[e]}setLeftPad(e){this.leftPad=e}updateLeftPad(e){this.width-=this.leftPad,this.leftPad=e,this.width+=this.leftPad}}class sc{constructor(e,t){this.id=e,this.content=t,this.exitPoint=null}setExitPoint(e){this.exitPoint=e}getExitPoint(){return this.exitPoint}}class ac{constructor(e,t){this.id=e,this.content=t}}class oc{constructor(e,t,i){this.info=i,this.builder=t,this.result=this._generateVisualHull(e)}_generateVisualHull(e){if(e instanceof ql)return this._handleCMOS(e);if(e instanceof Ol)return this._handleCMOSExpression(e);if(e instanceof Il)return this._handleCMOSSeriesElement(e);if(e instanceof Dl)return this._handleCMOSParallelElement(e);if(e instanceof Rl)return this._handleCMOSTransistor(e);throw Error("CMOSVisualBuilder.generateVisualHull(CMOS): cmosElement is of unknown type.")}_handleCMOS(e){const t=new Ql(this.builder.getId(),e,this.info);for(const i of e.expressions){const e=this._generateVisualHull(i);e.setParent(t),t.addChild(e)}return t}_handleCMOSExpression(e){const t=new ec(this.builder.getId(),e),i=this._generateVisualHull(e.pullUp),n=this._generateVisualHull(e.pullDown);return i.setParent(t),n.setParent(t),t.addChild(i),t.addChild(n),t}_handleCMOSSeriesElement(e){const t=new tc(this.builder.getId(),e);for(const i of e.children){const e=this._generateVisualHull(i);e.setParent(t),t.addChild(e)}return t}_handleCMOSParallelElement(e){const t=new ic(this.builder.getId(),e);for(const i of e.children){const e=this._generateVisualHull(i);e.setParent(t),t.addChild(e)}return t}_handleCMOSTransistor(e){return new nc(this.builder.getId(),e)}getResult(){return this.result}}class rc{constructor(e,t){this.info=t,this.result=this._calculateChannels(e)}_calculateChannels(e){if(e instanceof Ql)this._handleCMOSVisual(e);else if(e instanceof ec)this._handleCMOSVisualExpression(e);else if(e instanceof tc)this._handleCMOSVisualSeriesElement(e);else if(e instanceof ic)this._handleCMOSVisualParallelElement(e);else{if(!(e instanceof nc))throw Error("CMOSVisualBuilder.calculateChannels(CMOSVisual): visualElement is of unknown type.");this._handleCMOSVisualTransistor(e)}return e}_handleCMOSVisual(e){for(const t of e.children)this._calculateChannels(t)}_handleCMOSVisualExpression(e){for(const t in this.info.channelTable)Object.prototype.hasOwnProperty.call(this.info.channelTable,t)&&e.addChannel(this.info.channelTable[t]);for(const t of e.children)this._calculateChannels(t)}_handleCMOSVisualSeriesElement(e){for(const t of e.children){this._calculateChannels(t);for(const i of t.channels)e.addChannel(i)}}_handleCMOSVisualParallelElement(e){for(let t=0;t<e.children.length;t+=1){const i=e.children[t];this._calculateChannels(i);for(const t of i.channels)e.addChannel(t);if(t>0)for(const t of i.channels)e.addNeededChannel(t)}}_handleCMOSVisualTransistor(e){const t=this.info.getChannelId(e.content.src);null!=t&&e.addChannel(t)}getResult(){return this.result}}class lc{constructor(e,t){this.info=t,this.result=this._calculateSize(e,e)}_getMaximumLeftPad(e){let t=0;if(e instanceof ec)t=Math.max(this._getMaximumLeftPad(e.children[0]),this._getMaximumLeftPad(e.children[1]));else if(e instanceof tc)for(const i of e.children)t=Math.max(this._getMaximumLeftPad(i));else if(e instanceof ic)t=Math.max(this._getMaximumLeftPad(e.children[0]));else{if(!(e instanceof nc))throw Error("CMOSVisualBuilder._getMaximumLeftPad(CMOSVisual, CMOSVisual): visualElement is of unknown type.");t=this.info.transistorPadLeft,(this.info.tunnelExpressions&&e.content.src instanceof Ol||this.info.tunnelVariables&&e.content.src instanceof zl||this.info.tunnelLiterals&&e.content.src instanceof Wl)&&(t=Math.max(t,e.content.src.name.length*this.info.charWidth))}return t}_calculateSize(e,t,i=0,n=!1){if(t instanceof Ql)this._handleCMOSVisual(e,t);else if(t instanceof ec)this._handleCMOSVisualExpression(e,t);else if(t instanceof tc)this._handleCMOSVisualSeriesElement(e,t,i,n);else if(t instanceof ic)this._handleCMOSVisualParallelElement(e,t,i,n);else{if(!(t instanceof nc))throw Error("CMOSVisualBuilder._calculateSize(CMOSVisual, CMOSVisual): visualElement is of unknown type.");this._handleCMOSVisualTransistor(e,t,i,n)}return t}_handleCMOSVisual(e,t){let i=0,n=0;for(let s=0;s<t.children.length;s+=1){const e=t.children[s];this._calculateSize(t,e),this.info.singleRows&&s!==t.children.length-1?(n+=e.width,i+=e.height):(n+=e.width,i=Math.max(i,e.height))}t.setSize(n,i)}_handleCMOSVisualExpression(e,t){let i=0,n=0;const s=t.children[0],a=t.children[1];let o=0;this.info.adjustLeftPad&&(o=this._getMaximumLeftPad(t)),this._calculateSize(e,s,o,this.info.adjustLeftPad),this._calculateSize(e,a,o,this.info.adjustLeftPad),n=Math.max(s.width,a.width),i=this.info.equalizePullUpPullDown?2*Math.max(s.height,a.height):a.height+s.height,this.info.useOnlyNeededChannels?n+=t.channels.length*this.info.channelWidth:n+=this.info.channelNum*this.info.channelWidth,this.info.tunnelExpressions&&t.content.id<e.children.length-1&&(n+=this.info.expressionTunnelWireLength+t.content.name.length*this.info.charWidth,i+=this.info.channelWidth),n+=this.info.channelNum*this.info.channelWidth+2*this.info.channelWidth,i+=this.info.channelNum*this.info.channelWidth,t.setSize(n,i)}_handleCMOSVisualSeriesElement(e,t,i,n){let s=0,a=0;for(const o of t.children)this._calculateSize(e,o,i,n),a=Math.max(a,o.width),s+=o.height;t.setSize(a,s)}_handleCMOSVisualParallelElement(e,t,i,n){let s=0,a=0;for(let o=0;o<t.children.length;o+=1){const r=t.children[o];n&&0===o?this._calculateSize(e,r,i,!0):this._calculateSize(e,r,i,!1),o>0&&(this.info.useOnlyNeededChannels?a+=r.channels.length*this.info.channelWidth:a+=this.info.channelNum*this.info.channelWidth),a+=r.width,s=Math.max(s,r.height)}this.info.useOnlyNeededChannels?s+=t.neededChannels.length*this.info.channelWidth:s+=this.info.channelNum*this.info.channelWidth,s+=this.info.parallelElementChannelOffset,t.setSize(a,s)}_handleCMOSVisualTransistor(e,t,i,n){let s,a=0,o=0;n?s=i:(s=this.info.transistorPadLeft,(this.info.tunnelExpressions&&t.content.src instanceof Ol||this.info.tunnelVariables&&t.content.src instanceof zl||this.info.tunnelLiterals&&t.content.src instanceof Wl)&&(s=Math.max(s,t.content.src.name.length*this.info.charWidth))),o=s+this.info.transistorWidth+this.info.transistorPadRight,a=this.info.transistorPadTop+this.info.transistorHeight+this.info.transistorPadBot,t.setLeftPad(s),t.setSize(o,a)}getResult(){return this.result}}const cc={LEFT:"horizontal_left",CENTER:"horizontal_center",RIGHT:"horizontal_right"},uc={TOP:"vertical_top",CENTER:"vertical_center",BOTTOM:"vertical_bottom"},hc={alignmentHorizontal:cc.LEFT,alignmentVertical:uc.CENTER,connectionPointAlignment:cc.LEFT,offsetX:0,offsetY:0,transistorWidth:.75,transistorHeight:1,transistorPadLeft:1.5,transistorPadRight:.5,transistorPadTop:.25,transistorPadBot:.25,parallelElementChannelOffset:.25,expressionTunnelWireLength:.5,charWidth:.2,channelWidth:0,useOnlyNeededChannels:!0,tunnelLiterals:!0,tunnelVariables:!0,tunnelExpressions:!0,enableConnectionLineJoints:!1,equalizePullUpPullDown:!1,channelSymmetry:!1,adjustLeftPad:!0,singleRows:!0};class dc{constructor(e,t){this.alignmentHorizontal=t.alignmentHorizontal,this.alignmentVertical=t.alignmentVertical,this.connectionPointAlignment=t.connectionPointAlignment,this.offsetX=t.offsetX,this.offsetY=t.offsetY,this.transistorWidth=t.transistorWidth,this.transistorHeight=t.transistorHeight,this.transistorPadLeft=t.transistorPadLeft,this.transistorPadRight=t.transistorPadRight,this.transistorPadTop=t.transistorPadTop,this.transistorPadBot=t.transistorPadBot,this.parallelElementChannelOffset=t.parallelElementChannelOffset,this.expressionTunnelWireLength=t.expressionTunnelWireLength,this.charWidth=t.charWidth,this.channelWidth=t.channelWidth,this.useOnlyNeededChannels=t.useOnlyNeededChannels,this.tunnelLiterals=t.tunnelLiterals,this.tunnelVariables=t.tunnelVariables,this.tunnelExpressions=t.tunnelExpressions,this.enableConnectionLineJoints=t.enableConnectionLineJoints,this.equalizePullUpPullDown=t.equalizePullUpPullDown,this.channelSymmetry=t.channelSymmetry,this.adjustLeftPad=t.adjustLeftPad,this.singleRows=t.singleRows,this.channelNum=0,this.channelTable={};let i=0;if(!this.tunnelLiterals)for(const n of e.literals)this.channelTable[n.name]=i,i+=1;if(!this.tunnelVariables)for(const n of e.variables)this.channelTable[n.name]=i,i+=1;if(!this.tunnelExpressions)for(let n=0;n<e.expressions.length-1;n+=1)this.channelTable[e.expressions[n].name]=i,i+=1;this.channelNum=i}getChannelId(e){return Object.prototype.hasOwnProperty.call(this.channelTable,e.name)?this.channelTable[e.name]:null}}class mc{constructor(e,t){this.info=t,this.result=this._calculatePositions(e,this.info.offsetX,this.info.offsetY)}_calculatePositions(e,t,i){if(e instanceof Ql)this._handleCMOSVisual(e,t,i);else if(e instanceof ec)this._handleCMOSVisualExpression(e,t,i);else if(e instanceof tc)this._handleCMOSVisualSeriesElement(e,t,i);else if(e instanceof ic)this._handleCMOSVisualParallelElement(e,t,i);else{if(!(e instanceof nc))throw Error("CMOSVisualBuilder._calculatePositions(CMOSVisual, number, number): visualElement is of unknown type.");this._handleCMOSVisualTransistor(e,t,i)}return e}_handleCMOSVisual(e,t,i){let n=t;e.setPosition(n,i);let s=i;if(this.info.singleRows){let t=0;for(let i=0;i<e.children.length-1;i+=1)t+=e.children[i].height;this.info.alignmentVertical===uc.TOP||t>=e.children[e.children.length-1].height?s=i:this.info.alignmentVertical===uc.CENTER?s=i+(e.children[e.children.length-1].height-t)/2:this.info.alignmentVertical===uc.BOTTOM&&(s=i+e.children[e.children.length-1].height-t)}for(let a=0;a<e.children.length;a+=1){const t=e.children[a];this.info.singleRows&&a!==e.children.length-1||(this.info.alignmentVertical===uc.TOP?s=i:this.info.alignmentVertical===uc.CENTER?s=i+(e.height-t.height)/2:this.info.alignmentVertical===uc.BOTTOM&&(s=i+e.height-t.height)),this._calculatePositions(t,n,s),n+=t.width,this.info.singleRows&&(s+=t.height)}}_handleCMOSVisualExpression(e,t,i){e.setPosition(t,i);const n=e.children[0],s=e.children[1];let a=e.channels.length*this.info.channelWidth,o=0,r=0,l=0;this.info.tunnelExpressions&&e.content.id<e.parent.children.length-1&&(l=e.content.name.length*this.info.charWidth+this.info.expressionTunnelWireLength),this.info.alignmentHorizontal===cc.LEFT?(o=t+a,r=t+a):this.info.alignmentHorizontal===cc.CENTER?(o=t+a+(e.width-a-2*this.info.channelWidth-l-n.width)/2,r=t+a+(e.width-a-2*this.info.channelWidth-l-s.width)/2):this.info.alignmentHorizontal===cc.RIGHT&&(o=t+e.width-a-2*this.info.channelWidth-l-n.width,r=t+e.width-a-2*this.info.channelWidth-l-s.width),this.info.tunnelExpressions&&(a+=this.info.channelWidth);let c=0,u=0;if(this.info.equalizePullUpPullDown)if(this.info.alignmentVertical===uc.TOP)c=i,u=i+n.height+a;else if(this.info.alignmentVertical===uc.CENTER){const t=(e.height-a)/2;c=i+(t-n.height)/2,u=i+e.height-s.height-(t-s.height)/2}else this.info.alignmentVertical===uc.BOTTOM&&(u=i+e.height-s.height,c=i+e.height-s.height-a-n.height);else c=i,u=i+e.height-s.height;this._calculatePositions(n,o,c),this._calculatePositions(s,r,u)}_handleCMOSVisualSeriesElement(e,t,i){const n=t;let s=i;e.setPosition(n,s);for(const a of e.children){let t=0;this.info.alignmentHorizontal===cc.LEFT?t=n:this.info.alignmentHorizontal===cc.CENTER?t=n+(e.width-a.width)/2:this.info.alignmentHorizontal===cc.RIGHT&&(t=n+e.width-a.width),this._calculatePositions(a,t,s),s+=a.height}}_handleCMOSVisualParallelElement(e,t,i){let n=t;e.setPosition(n,i);let s=e.neededChannels.length*this.info.channelWidth;this.info.useOnlyNeededChannels||(s=this.info.channelNum*this.info.channelWidth);for(let a=0;a<e.children.length;a+=1){const t=e.children[a];let o=t.channels.length*this.info.channelWidth;this.info.useOnlyNeededChannels||(o=this.info.channelNum*this.info.channelWidth),0===a&&(o=0);let r=0;this.info.alignmentVertical===uc.TOP?r=i:this.info.alignmentVertical===uc.CENTER?r=i+(e.height-s-this.info.parallelElementChannelOffset-t.height)/2:this.info.alignmentVertical===uc.BOTTOM&&(r=i+e.height-s-this.info.parallelElementChannelOffset-t.height),this.info.channelSymmetry&&e.content.networkType===Pl.PULLDOWN&&(r+=s+this.info.parallelElementChannelOffset),this._calculatePositions(t,n+o,r),n+=t.width+o}}_handleCMOSVisualTransistor(e,t,i){e.setPosition(t,i)}getResult(){return this.result}}class pc{constructor(e,t,i){this.builder=t,this.info=i,this.result=this._collectAll(e)}_collectAll(e){let t=e;return t=this._collectTransistors(t,t),t=this._collectVariables(t),t=this._collectLiterals(t),t}_collectTransistors(e,t){if(t instanceof nc)e.addTransistor(t);else{if(!(t instanceof Ql||t instanceof ec||t instanceof tc||t instanceof ic))throw Error("Collect._collectTransistors(CMOSVisual, CMOSVisual): visualElement is of unknown type.");for(const i of t.children)this._collectTransistors(e,i)}return t}_collectVariables(e){if(!(e instanceof Ql))throw Error("Collect._collectVariables(CMOSVisual, CMOSVisual): visualElement is of unknown type.");for(const t of e.content.variables)e.addVariable(new sc(this.builder.getId(),t));return e}_collectLiterals(e){if(!(e instanceof Ql))throw Error("Collect._collectVariables(CMOSVisual): visualElement is of unknown type.");for(const t of e.content.literals)e.addLiteral(new ac(this.builder.getId(),t));return e}getResult(){return this.result}}class fc{constructor(e,t){this.info=t,this.result=this._calculateConnectionPoints(e)}_calculateConnectionPoints(e){if(e instanceof Ql)this._handleCMOSVisual(e);else if(e instanceof ec)this._handleCMOSVisualExpression(e);else if(e instanceof tc)this._handleCMOSVisualSeriesElement(e);else if(e instanceof ic)this._handleCMOSVisualParallelElement(e);else{if(!(e instanceof nc))throw Error("CalculateConnectionPoints._calculateConnectionPoints(CMOSVisual): visualElement is of unknown type.");this._handleCMOSVisualTransistor(e)}return e}_handleCMOSVisual(e){for(const t of e.children)this._calculateConnectionPoints(t)}_handleCMOSVisualExpression(e){for(const t of e.children)this._calculateConnectionPoints(t);e.upperConnectionPoint=e.children[0].upperConnectionPoint,e.lowerConnectionPoint=e.children[1].lowerConnectionPoint}_handleCMOSVisualSeriesElement(e){for(const t of e.children)this._calculateConnectionPoints(t);e.upperConnectionPoint=e.children[0].upperConnectionPoint,e.lowerConnectionPoint=e.children[e.children.length-1].lowerConnectionPoint}_handleCMOSVisualParallelElement(e){for(const a of e.children)this._calculateConnectionPoints(a);let t=0,i=0,n=0,s=0;this.info.connectionPointAlignment===cc.LEFT?(t=e.children[0].upperConnectionPoint.x,i=e.children[0].lowerConnectionPoint.x):this.info.connectionPointAlignment===cc.CENTER?(t=(e.children[0].upperConnectionPoint.x+e.children[e.children.length-1].upperConnectionPoint.x)/2,i=(e.children[0].lowerConnectionPoint.x+e.children[e.children.length-1].lowerConnectionPoint.x)/2):this.info.connectionPointAlignment===cc.RIGHT&&(t=e.children[e.children.length-1].upperConnectionPoint.x,i=e.children[e.children.length-1].lowerConnectionPoint.x),n=e.y+e.height,s=e.y;for(const a of e.children)a.upperConnectionPoint.y<n&&(n=a.upperConnectionPoint.y),a.lowerConnectionPoint.y>s&&(s=a.lowerConnectionPoint.y);e.content.networkType===Pl.PULLDOWN&&this.info.channelSymmetry?this.info.useOnlyNeededChannels?n-=e.neededChannels.length*this.info.channelWidth+this.info.parallelElementChannelOffset:n-=this.info.channelNum*this.info.channelWidth+this.info.parallelElementChannelOffset:this.info.useOnlyNeededChannels?s+=e.neededChannels.length*this.info.channelWidth+this.info.parallelElementChannelOffset:s+=this.info.channelNum*this.info.channelWidth+this.info.parallelElementChannelOffset,e.upperConnectionPoint={x:t,y:n},e.lowerConnectionPoint={x:i,y:s}}_handleCMOSVisualTransistor(e){e.upperConnectionPoint={x:e.x+e.width-this.info.transistorPadRight,y:e.y},e.lowerConnectionPoint={x:e.x+e.width-this.info.transistorPadRight,y:e.y+e.height}}getResult(){return this.result}}class gc{constructor(e,t){this.info=t,this.result=this._calculateEntryPoints(e)}_calculateEntryPoints(e){if(e instanceof Ql)this._handleCMOSVisual(e);else if(e instanceof ec)this._handleCMOSVisualExpression(e);else if(e instanceof tc)this._handleCMOSVisualSeriesElement(e);else if(e instanceof ic)this._handleCMOSVisualParallelElement(e);else{if(!(e instanceof nc))throw Error("CalculateEntryPoints._calculateEntryPoints(CMOSVisual): cmosElement is of unknown type.");this._handleCMOSVisualTransistor(e)}return e}_handleCMOSVisual(e){for(const t of e.children)this._calculateEntryPoints(t)}_handleCMOSVisualExpression(e){for(let t=0;t<e.channels.length;t+=1){let i;const n=e.x+t*this.info.channelWidth+this.info.channelWidth/2;i=this.info.equalizePullUpPullDown?e.y+Math.max(e.children[0].height,e.children[1].height)+this.info.channelWidth*t+this.info.channelWidth/2:e.y+e.children[0].height+this.info.channelWidth*t+this.info.channelWidth/2;const s={x:n,y:i};e.entryPointTable[e.channels[t]]=s}for(const t of e.children)this._calculateEntryPoints(t)}_handleCMOSVisualSeriesElement(e){for(let t=0;t<e.channels.length;t+=1){let i,n;e.parent instanceof ec?(i=e.parent.getEntryPoint(e.channels[t]).x,n=e.parent.getEntryPoint(e.channels[t]).y):e.content.networkType===Pl.PULLDOWN&&this.info.channelSymmetry?(i=e.x-e.channels.length*this.info.channelWidth+t*this.info.channelWidth+this.info.channelWidth/2,n=e.y-e.channels.length*this.info.channelWidth+t*this.info.channelWidth+this.info.channelWidth/2):(i=e.x-e.channels.length*this.info.channelWidth+t*this.info.channelWidth+this.info.channelWidth/2,n=e.y+e.height+t*this.info.channelWidth+this.info.channelWidth/2);const s={x:i,y:n};e.entryPointTable[e.channels[t]]=s}for(const t of e.children)e.parent instanceof ec&&(t.parent=e.parent),this._calculateEntryPoints(t),e.parent instanceof ec&&(t.parent=e)}_handleCMOSVisualParallelElement(e){let t,i;for(let s=0;s<e.children.length;s+=1){const t=e.children[s];0===s&&e.parent instanceof ec?(t.parent=e.parent,this._calculateEntryPoints(t),t.parent=e):this._calculateEntryPoints(t)}for(let s=0;s<e.neededChannels.length;s+=1){i=e.content.networkType===Pl.PULLDOWN&&this.info.channelSymmetry?e.y+s*this.info.channelWidth+this.info.channelWidth/2+this.info.parallelElementChannelOffset:e.y+e.height-e.neededChannels.length*this.info.channelWidth-this.info.parallelElementChannelOffset+s*this.info.channelWidth+this.info.channelWidth/2;for(let n=1;n<e.children.length;n+=1){const a=e.children[n];a.channels.includes(e.neededChannels[s])&&(t=a.getEntryPoint(e.neededChannels[s]).x,e.entryPointTable[[e.neededChannels[s],a.id]]={x:t,y:i})}}const n=e.children[0];for(let s=0;s<n.channels.length;s+=1){const t=n.channels[s],i=n.getEntryPoint(t).x,a=n.getEntryPoint(t).y;e.entryPointTable[[t,n.id]]={x:i,y:a}}}_handleCMOSVisualTransistor(e){const t=e.x,i=e.y+this.info.transistorPadTop+this.info.transistorHeight/2;e.entryPointTable[e.channels[0]]={x:t,y:i}}getResult(){return this.result}}class bc{constructor(e,t){this.info=t,this.result=this._calculateExitPoints(e)}_calculateExitPoints(e){if(e instanceof Ql)this._handleCMOSVisual(e);else{if(!(e instanceof ec))throw Error("CalculateEntryPoints._calculateExitPoints(CMOSVisual): cmosElement is of unknown type.");this._handleCMOSVisualExpression(e)}return e}_handleCMOSVisual(e){for(const t of e.children)this._calculateExitPoints(t);if(!this.info.tunnelVariables)for(const t of e.variables){const i=-1,n=e.children[0].getEntryPoint(this.info.getChannelId(t.content)).y;t.exitPoint={x:i,y:n}}}_handleCMOSVisualExpression(e){const t=e.children[0].lowerConnectionPoint,i=e.children[1].upperConnectionPoint;let n,s;this.info.connectionPointAlignment===cc.LEFT?n=Math.min(t.x,i.x):this.info.connectionPointAlignment===cc.CENTER?n=(t.x+i.x)/2:this.info.connectionPointAlignment===cc.RIGHT&&(n=Math.max(t.x,i.x)),s=e.content.id>=e.content.parent.expressions.length-1?this.info.equalizePullUpPullDown?e.y+e.height/2:e.y+e.children[0].height+(e.height-e.children[0].height-e.children[1].height)/2:this.info.tunnelExpressions?this.info.equalizePullUpPullDown?e.y+Math.max(e.children[0].height,e.children[1].height)+this.info.channelNum*this.info.channelWidth+this.info.channelWidth/2:e.y+e.children[0].height+this.info.channelNum*this.info.channelWidth+this.info.channelWidth/2:this.info.equalizePullUpPullDown?e.y+Math.max(e.children[0].height,e.children[1].height)+this.info.channelWidth*this.info.getChannelId(e.content)+this.info.channelWidth/2:e.y+e.children[0].height+this.info.channelWidth*this.info.getChannelId(e.content)+this.info.channelWidth/2,e.exitPoint={x:n,y:s}}getResult(){return this.result}}class vc{constructor(e){this.current=e}advanceX(e,t=!1){if(this.current.containsPoint||(this.current.containsPoint=t&&null!=this.current.parent&&this.current.children.length>1||t&&this.current.children.length>2),this.current.x===e)return;for(const n of this.current.children){if(n instanceof Zl||n.y!==this.current.y||n.x>this.current.x&&this.current.x>e||n.x<this.current.x&&this.current.x<e)continue;if(e===n.x)return void(this.current=n);if(e>n.x&&n.x>this.current.x||e<n.x&&n.x<this.current.x)return this.current=n,void this.advanceX(e,t);const i=new Xl(e,this.current.y,this.current,!1);return i.addChild(n),n.parent=i,this.current.addChild(i),this.current.removeChild(n),void(this.current=i)}if(null!=this.current.parent&&this.current.parent.y===this.current.y&&!(this.current.parent.x>this.current.x&&this.current.x>e||this.current.parent.x<this.current.x&&this.current.x<e)){if(e===this.current.parent.x)return void(this.current=this.current.parent);if(e>this.current.parent.x&&this.current.parent.x>this.current.x||e<this.current.parent.x&&this.current.parent.x<this.current.x)return this.current=this.current.parent,void this.advanceX(e,t);const i=new Xl(e,this.current.y,this.current.parent,!1);return this.current.parent.addChild(i),this.current.parent.removeChild(this.current),i.addChild(this.current),this.current.parent=i,void(this.current=i)}const i=new Xl(e,this.current.y,this.current,!1);this.current.addChild(i),this.current.containsPoint||(this.current.containsPoint=t&&null!=this.current.parent&&this.current.children.length>1||t&&this.current.children.length>2),this.current=i}advanceY(e,t=!1){if(this.current.containsPoint||(this.current.containsPoint=t&&null!=this.current.parent&&this.current.children.length>1||t&&this.current.children.length>2),this.current.y===e)return;for(const n of this.current.children){if(n instanceof Zl||n.x!==this.current.x||n.y>this.current.y&&this.current.y>e||n.y<this.current.y&&this.current.y<e)continue;if(e===n.y)return void(this.current=n);if(e>n.y&&n.y>this.current.y||e<n.y&&n.y<this.current.y)return this.current=n,void this.advanceY(e,t);const i=new Xl(this.current.x,e,this.current,!1);return i.addChild(n),n.parent=i,this.current.addChild(i),this.current.removeChild(n),void(this.current=i)}if(null!=this.current.parent&&this.current.parent.x===this.current.x&&!(this.current.parent.y>this.current.y&&this.current.y>e||this.current.parent.y<this.current.y&&this.current.y<e)){if(e===this.current.parent.y)return void(this.current=this.current.parent);if(e>this.current.parent.y&&this.current.parent.y>this.current.y||e<this.current.parent.y&&this.current.parent.y<this.current.y)return this.current=this.current.parent,void this.advanceY(e,t);const i=new Xl(this.current.x,e,this.current.parent,t);return this.current.parent.addChild(i),this.current.parent.removeChild(this.current),i.addChild(this.current),this.current.parent=i,void(this.current=i)}const i=new Xl(this.current.x,e,this.current,!1);this.current.addChild(i),this.current.containsPoint||(this.current.containsPoint=t&&null!=this.current.parent&&this.current.children.length>1||t&&this.current.children.length>2),this.current=i}connectTransistor(e,t,i){let n,s;t===Ul.GATE?(n=e.x+e.width-i.transistorPadRight-i.transistorWidth,s=e.y+i.transistorPadTop+i.transistorHeight/2):e.content.type===jl.PMOS?t===Ul.SOURCE?(n=e.upperConnectionPoint.x,s=e.upperConnectionPoint.y):t===Ul.DRAIN&&(n=e.lowerConnectionPoint.x,s=e.lowerConnectionPoint.y):e.content.type===jl.NMOS&&(t===Ul.DRAIN?(n=e.upperConnectionPoint.x,s=e.upperConnectionPoint.y):t===Ul.SOURCE&&(n=e.lowerConnectionPoint.x,s=e.lowerConnectionPoint.y));const a=new Zl(n,s,this.current,e,t);this.current.addChild(a),this.current=a}}class wc{constructor(e,t){this.info=t,this.result=this._generateConnectionWires(e,e,null,null)}_generateConnectionWires(e,t,i,n){if(t instanceof Ql)this._handleCMOSVisual(e,t);else if(t instanceof ec)this._handleCMOSVisualExpression(e,t,i,n);else if(t instanceof tc)this._handleCMOSVisualSeriesElement(e,t,i,n);else if(t instanceof ic)this._handleCMOSVisualParallelElement(e,t,i,n);else{if(!(t instanceof nc))throw Error("GenerateConnectionWires._generateConnectionWires(CMOSVisual, CMOSVisual, WireNode, WireNode): visualElement is of unknown type.");this._handleCMOSVisualTransistor(e,t,i,n)}return t}_handleCMOSVisual(e,t){const i=new Kl(new Xl(0,0,null,!1)),n=new Kl(new Xl(0,t.height,null,!1)),s=new vc(i.root),a=new vc(n.root);for(const o of t.children)s.advanceX(o.upperConnectionPoint.x,this.info.enableConnectionLineJoints),a.advanceX(o.lowerConnectionPoint.x,this.info.enableConnectionLineJoints),this._generateConnectionWires(e,o,s.current,a.current);s.advanceX(t.width,this.info.enableConnectionLineJoints),a.advanceX(t.width,this.info.enableConnectionLineJoints),e.addConnectionWire(i),e.addConnectionWire(n)}_handleCMOSVisualExpression(e,t,i,n){const s=t.getExitPoint(),a=new Kl(new Xl(s.x,s.y,null,!1)),o=new vc(i),r=new vc(a.root),l=new vc(n);r.advanceX(t.children[0].lowerConnectionPoint.x,this.info.enableConnectionLineJoints),r.advanceY(t.children[0].lowerConnectionPoint.y,this.info.enableConnectionLineJoints),o.advanceX(t.children[0].upperConnectionPoint.x,this.info.enableConnectionLineJoints),o.advanceY(t.children[0].upperConnectionPoint.y,this.info.enableConnectionLineJoints),this._generateConnectionWires(e,t.children[0],o.current,r.current),r.current=a.root,r.advanceX(t.children[1].upperConnectionPoint.x,this.info.enableConnectionLineJoints),r.advanceY(t.children[1].upperConnectionPoint.y,this.info.enableConnectionLineJoints),l.advanceX(t.children[1].lowerConnectionPoint.x,this.info.enableConnectionLineJoints),l.advanceY(t.children[1].lowerConnectionPoint.y,this.info.enableConnectionLineJoints),this._generateConnectionWires(e,t.children[1],r.current,l.current),r.current=a.root,this.info.tunnelExpressions&&t.content.id<e.children.length-1?r.advanceX(t.x+t.width-t.content.name.length*this.info.charWidth,this.info.enableConnectionLineJoints):t.content.id===e.children.length-1&&r.advanceX(e.width,this.info.enableConnectionLineJoints),e.addConnectionWire(a)}_handleCMOSVisualSeriesElement(e,t,i,n){const s=new vc(i),a=new vc(n);for(let o=0;o<t.children.length;o+=1){const i=t.children[o];if(i instanceof nc){const n=i.content.type===jl.PMOS?Ul.SOURCE:Ul.DRAIN,r=i.content.type===jl.PMOS?Ul.DRAIN:Ul.SOURCE;if(s.advanceX(i.upperConnectionPoint.x,this.info.enableConnectionLineJoints),s.connectTransistor(i,n,this.info),o<t.children.length-1){const t=new Zl(i.lowerConnectionPoint.x,i.lowerConnectionPoint.y,null,i,r),n=new Xl(i.lowerConnectionPoint.x,i.lowerConnectionPoint.y,null,!1);n.addChild(t);const a=new Kl(n);e.addConnectionWire(a),s.current=n}else a.connectTransistor(i,r,this.info)}else if(s.advanceX(i.upperConnectionPoint.x,this.info.enableConnectionLineJoints),s.advanceY(i.upperConnectionPoint.y,this.info.enableConnectionLineJoints),o<t.children.length-1){const t=new Xl(i.lowerConnectionPoint.x,i.lowerConnectionPoint.y,null,!1);this._generateConnectionWires(e,i,s.current,t),s.current=t;const n=new Kl(t);e.addConnectionWire(n)}else a.advanceY(i.lowerConnectionPoint.y),this._generateConnectionWires(e,i,s.current,a.current)}}_handleCMOSVisualParallelElement(e,t,i,n){const s=new vc(i),a=new vc(n);for(const o of t.children)s.advanceX(o.upperConnectionPoint.x,this.info.enableConnectionLineJoints),a.advanceX(o.lowerConnectionPoint.x,this.info.enableConnectionLineJoints),this._generateConnectionWires(e,o,s.current,a.current)}_handleCMOSVisualTransistor(e,t,i,n){const s=new vc(i),a=new vc(n),o=t.content.type===jl.PMOS?Ul.SOURCE:Ul.DRAIN,r=t.content.type===jl.PMOS?Ul.DRAIN:Ul.SOURCE;s.connectTransistor(t,o,this.info),a.connectTransistor(t,r,this.info)}getResult(){return this.result}}class xc{constructor(e,t){this.info=t,this.result=this._generateExpressionWires(e)}_generateExpressionWires(e){if(this.info.tunnelExpressions)return e;for(let t=0;t<e.children.length-1;t+=1){const i=e.children[t],n=i.getExitPoint(),s=new Kl(new Xl(n.x,n.y,null,!0));e.addExpressionWire(s);for(const t of i.content.connectedTo)this._generateExpressionWire(e,new vc(s.root),i,e.getTransistorByContent(t))}return e}_generateExpressionWire(e,t,i,n,s=null){const a=this.info.getChannelId(i.content);if(n instanceof ec){if(this.info.singleRows){const e=n.getEntryPoint(a);let i;i=0===n.content.id?0:t.current.y>e.y?(this.info.channelNum+1)*this.info.channelWidth:(2*a+2)*this.info.channelWidth,t.advanceX(e.x-i,!0),t.advanceY(e.y,!0),t.advanceX(e.x,!0)}else for(let s=i.content.id+1;s<n.content.id+1;s+=1){const i=e.children[s].getEntryPoint(a);let n;n=0===s?0:t.current.y>i.y?(this.info.channelNum+1)*this.info.channelWidth:(2*a+2)*this.info.channelWidth,t.advanceX(i.x-n,!0),t.advanceY(i.y,!0),t.advanceX(i.x,!0)}return}let o;this._generateExpressionWire(e,t,i,n.parent,n),n instanceof tc?(o=n.getEntryPoint(a),t.advanceY(o.y,!0),t.advanceX(o.x,!0)):n instanceof ic?(o=n.getEntryPoint(a,s),t.advanceY(o.y,!0),t.advanceX(o.x,!0)):n instanceof nc&&(o=n.getEntryPoint(a),t.advanceY(o.y,!0),t.advanceX(o.x,!0),t.connectTransistor(n,Ul.GATE,this.info))}getResult(){return this.result}}class _c{constructor(e,t){this.info=t,this.result=this._generateVariableWires(e)}_generateVariableWires(e){if(this.info.tunnelVariables)return e;for(let t=0;t<e.variables.length;t+=1){const i=e.variables[t],n=i.getExitPoint(),s=new Kl(new Xl(n.x,n.y,null,!1));e.addVariableWire(s);for(const t of i.content.connectedTo)this._generateVariableWire(e,new vc(s.root),i,e.getTransistorByContent(t))}return e}_generateVariableWire(e,t,i,n,s=null){const a=this.info.getChannelId(i.content);if(n instanceof ec){if(this.info.singleRows){const e=n.getEntryPoint(a);let i;i=0===n.content.id?0:t.current.y>e.y?(this.info.channelNum+1)*this.info.channelWidth:(2*a+2)*this.info.channelWidth,t.advanceX(e.x-i,!0),t.advanceY(e.y,!0),t.advanceX(e.x,!0)}else for(let i=0;i<n.content.id+1;i+=1){const n=e.children[i].getEntryPoint(a);let s;s=0===i?0:t.current.y>n.y?(this.info.channelNum+1)*this.info.channelWidth:(2*a+2)*this.info.channelWidth,t.advanceX(n.x-s,!0),t.advanceY(n.y,!0),t.advanceX(n.x,!0)}return}let o;this._generateVariableWire(e,t,i,n.parent,n),n instanceof tc?(o=n.getEntryPoint(a),t.advanceY(o.y,!0),t.advanceX(o.x,!0)):n instanceof ic?(o=n.getEntryPoint(a,s),t.advanceY(o.y,!0),t.advanceX(o.x,!0)):n instanceof nc&&(o=n.getEntryPoint(a),t.advanceY(o.y,!0),t.advanceX(o.x,!0),t.connectTransistor(n,Ul.GATE,this.info))}getResult(){return this.result}}class $c{constructor(e,t){this.info=t,this.result=this._generateLiteralWires(e)}_generateLiteralWires(e){if(this.info.tunnelLiterals)return e;for(let t=0;t<e.literals.length;t+=1){const i=e.literals[t];for(const t of i.content.connectedTo)this._generateLiteralWire(e,i,e.getTransistorByContent(t))}return e}_generateLiteralWire(e,t,i,n=null){const s=this.info.getChannelId(t.content);if(i instanceof ec){const n=t.content.value?0:e.height,a=i.getEntryPoint(s),o=new Kl(new Xl(a.x,n,null,!0));e.addLiteralWire(o);const r=new vc(o.root);return r.advanceY(a.y,!0),r}const a=this._generateLiteralWire(e,t,i.parent,i);let o;return i instanceof tc?(o=i.getEntryPoint(s),a.advanceY(o.y,!0),a.advanceX(o.x,!0)):i instanceof ic?(o=i.getEntryPoint(s,n),a.advanceY(o.y,!0),a.advanceX(o.x,!0)):i instanceof nc&&(o=i.getEntryPoint(s),a.advanceY(o.y,!0),a.advanceX(o.x,!0),a.connectTransistor(i,Ul.GATE,this.info)),a}getResult(){return this.result}}class yc{constructor(){this.idCounter=-1}getId(){return this.idCounter+=1,this.idCounter}resetId(){this.idCounter=-1}setDefaults(e,t){return{...t,...e}}buildHull(e,t,i=!0){let n;const s=new dc(e,this.setDefaults(t,hc));return n=new oc(e,this,s).getResult(),n=new rc(n,s).getResult(),n=new lc(n,s).getResult(),n=new mc(n,s).getResult(),n=new pc(n,this,s).getResult(),n=new fc(n,s).getResult(),n=new gc(n,s).getResult(),n=new bc(n,s).getResult(),n=new wc(n,s).getResult(),n=new xc(n,s).getResult(),n=new _c(n,s).getResult(),n=new $c(n,s).getResult(),i&&this.resetId(),n}}class Ec{placeSupplyWires(e){const t=`(${e.x}, ${-e.y}) node[anchor=east] {VCC}`,i=`(${e.x}, ${-e.y-e.height}) node[anchor=east] {GND}`,n=`(${e.x}, ${-e.y}) to (${e.x+e.width+1}, ${-e.y})`,s=`(${e.x}, ${-e.y-e.height}) to (${e.x+e.width+1}, ${-e.y-e.height})`;return["","% SUPPLYWIRES:","",t,i,";","\\draw [very thick]",n,s].join("\n")}getTransistorLatex(e,t){const i={x:t.x+t.width-e.info.transistorPadRight,y:t.y+e.info.transistorPadTop+e.info.transistorHeight/2},n=`${t.content.type}-${t.id}`;let s="";return t.content.type===jl.PMOS&&(s=", emptycircle"),`node[${t.content.type}${s}] (${n}) at (${i.x}, ${-i.y}){}`}placeTransistors(e){const t=["","% TRANSISTORS:",""];for(const i of e.transistors)t.push(this.getTransistorLatex(e,i));return t.join("\n")}getWireLatex(e,t,i=!1){const n=[];if(t instanceof Xl){if(i)for(const i of t.children)n.push(`(${t.x}, ${-t.y})`),n.push(this.getWireLatex(e,i));else if(n.push(` to (${t.x}, ${-t.y})`),1===t.children.length)n.push(this.getWireLatex(e,t.children[0]));else{n.push("\n");for(const i of t.children)n.push(`(${t.x}, ${-t.y})`),n.push(this.getWireLatex(e,i))}t.containsPoint&&n.push(`(${t.x}, ${-t.y}) node[circ] {}\n`)}else if(t instanceof Zl){const s=`${t.transistor.content.type}-${t.transistor.id}`,a=`${s}.${t.connectionType}`;i?n.push(`(${a})`):n.push(` to (${a})\n`);for(const i of t.children)n.push(this.getWireLatex(e,i))}return n.join("")}placeConnectionWires(e){const t=["","% CONNECTIONWIRES:",""];for(const i of e.connectionWires)t.push(this.getWireLatex(e,i.root,!0));return t.length>3?t.join("\n"):""}getExpressionTransistorLabelLatex(e,t,i,n){const s=`${i.content.type}-${i.id}`;return`(${s}.G) node[anchor=east] {$${n(t.content.booleanExpression)}$}`}getExpressionWireLabel(e,t,i,n){return`(${t}, ${-i}) node[anchor=west] {$${n(e.content.booleanExpression)}$}`}placeExpressionLabels(e,t){const i=[];if(e.info.tunnelExpressions){for(let n=0;n<e.children.length-1;n+=1){const s=e.children[n],a=s.getExitPoint(),o=s.x+s.width-s.content.name.length*e.info.charWidth,r=a.y,l=this.getExpressionWireLabel(s,o,r,t);i.push(l)}for(let n=0;n<e.children.length-1;n+=1){const s=e.children[n];for(const n of s.content.connectedTo){const a=e.getTransistorByContent(n),o=this.getExpressionTransistorLabelLatex(e,s,a,t);i.push(o)}}}const n=e.children[e.children.length-1],s=n.getExitPoint();return i.push(this.getExpressionWireLabel(n,e.x+e.width,s.y,t)),i.join("\n")}placeExpressionWires(e){const t=["","% EXPRESSIONWIRES:",""];for(const i of e.expressionWires)t.push(this.getWireLatex(e,i.root,!0));return t.length>3?t.join("\n"):""}getExpressionLatex(e,t){return[this.placeExpressionWires(e,t),this.placeExpressionLabels(e,t)].join("\n")}getVariableTransistorLabelLatex(e,t,i,n){const s=`${i.content.type}-${i.id}`;return`(${s}.G) node[anchor=east] {$${n(t.content.booleanExpression)}$}`}placeVariableLabels(e,t){const i=[];for(const n of e.variables)for(const s of n.content.connectedTo)i.push(this.getVariableTransistorLabelLatex(e,n,e.getTransistorByContent(s),t));return i.join("\n")}getVariableWireLabel(e,t,i,n){return`(${t}, ${-i}) node[anchor=east] {$${n(e.content.booleanExpression)}$}`}placeVariableWires(e,t){const i=["","% VARIABLEWIRES:",""];for(let n=0;n<e.variableWires.length;n+=1){const s=e.variableWires[n],a=e.variables[n];i.push(this.getVariableWireLabel(a,s.root.x,s.root.y,t)),i.push(this.getWireLatex(e,s.root,!0))}return i.length>3?i.join("\n"):""}getVariableLatex(e,t){return e.info.tunnelVariables?this.placeVariableLabels(e,t):this.placeVariableWires(e,t)}getLiteralTransistorLabelLatex(e,t,i){const n=`${i.content.type}-${i.id}`,s=t.content.value?"1":"0";return`(${n}.G) node[anchor=east] {$${s}$}`}placeLiteralLabels(e){const t=[];for(const i of e.literals)for(const n of i.content.connectedTo)t.push(this.getLiteralTransistorLabelLatex(e,i,e.getTransistorByContent(n)));return t.join("\n")}placeLiteralWires(e){const t=["","% LITERALWIRES:",""];for(let i=0;i<e.literalWires.length;i+=1){const n=e.literalWires[i];t.push(this.getWireLatex(e,n.root,!0))}return t.length>3?t.join("\n"):""}getLiteralLatex(e){return e.info.tunnelLiterals?this.placeLiteralLabels(e):this.placeLiteralWires(e)}placeSettings(e){return[`\\ctikzset{tripoles/nmos/height=${e.info.transistorHeight}, tripoles/pmos/height=${e.info.transistorHeight}}`,`\\ctikzset{tripoles/nmos/width=${e.info.transistorWidth}, tripoles/pmos/width=${e.info.transistorWidth}}`].join("\n")}buildLatex(e,t,i=.5){const n=["\n",`\\begin{circuitikz}[scale=${i}, every node/.style={scale=${i}}]`,this.placeSettings(e),"\\draw",this.placeTransistors(e),this.placeConnectionWires(e),this.getExpressionLatex(e,t),this.getVariableLatex(e,t),this.getLiteralLatex(e),this.placeSupplyWires(e),";\\end{circuitikz}"].join("\n");return n}}function Cc(e){return e.value?"1":"0"}function Mc(e){return e.name}function kc(e){if(e.operator===ya.NOT){const t=Tc(e.operand);return`\\overline{${t}}`}let t="";switch(e.operator){case ya.AND:t="\\cdot ";break;case ya.OR:t="+";break;case ya.NAND:t="\\operatorname{nand}";break;case ya.NOR:t="\\operatorname{nor}";break;case ya.XNOR:t="\\oplus";break;case ya.IMPLIES:t="\\implies";break;default:throw new Error("invalid operator")}const i=e.operands.map((e=>Tc(e)));return i.join(t)}function Tc(e){let t="";switch(e.kind){case pa.LITERAL:t=Cc(e);break;case pa.VARIABLE:t=Mc(e);break;case pa.OPERATOR:t=kc(e);break;default:throw new Error("invalid expression kind")}return e.hasParentheses&&(t=`\\left(${t}\\right)`),t}function Sc(e){return Tc(e)}function Nc(e){const t=e.t("sheet");return[{title:`${e.t("example")} 1`,handle:"ex1",data:"(~a+c)*~(~b+c*~a)"},{title:`${e.t("example")} 2`,handle:"ex2",data:"(~x+~r*~(~n+a))*(n+r)"},{title:`${e.t("wintersemester")}: ${t} 9 A1b`,handle:"ws-9a1b",data:"x0*~x1*(~x2+~x3)"},{title:`${e.t("sommersemester")}: ${t} 6 A3`,handle:"ss-6a3",data:"~(~a*b+a*~b)"}]}function Bc(e){return Nc(e).map((e=>e.title))}function Fc(e,t){return Nc(e)[t]}function Lc(e,t){const i=Nc(e);for(let n=0;n<i.length;n+=1)if(i[n].handle===t)return n;return-1}var Ac={name:"KVDiagram",components:{InfoBlob:Ur,FSelect:Oe,TabComponent:jr},data(){return{latex:"",latexText:"",cmosFormula:"",lastCmosFormula:"",cmosOutput:"",cmosError:null,cmosErrorFormulaTooSimple:null,renderedFormula:"",archivedExerciseSelectedIndex:0,loadFromArchiveOrFormula:!0,randomExerciseDifficultySelectedIndex:0,examples:["(~a+c)*~(~b+c*~a)","(~x+~r*~(~n+a))*(n+r)","x0*~x1*(~x2+~x3)","~(~a*b+a*~b)"]}},created(){},mounted(){this.loadExerciseFromURL()},computed:{archivedExerciseTitles(){return Bc(this.$i18n)},randomExercisesDifficulties(){return[this.$t("easy"),this.$t("difficultyMiddle"),this.$t("difficultyHard")]}},methods:{copyToClipboard(){navigator.clipboard.writeText(this.latexText).then((()=>{console.log("Copying to clipboard was successful!"),this.$refs.tooltip.classList.add("appear"),setTimeout((()=>{this.$refs.tooltip.classList.remove("appear")}),1e3)}),(e=>{console.error("Failed to copy: ",e)}))},selectArchivedExercise(e,t){this.archivedExerciseSelectedIndex=t},loadArchivedExercise(){const e=this.archivedExerciseSelectedIndex;e<0||this.generateCmos(Fc(this.$i18n,e).data)},toMathJax(e){const t=[];let i=!0;for(const n of e)"$"===n?(i?t.push("\\("):t.push("\\)"),i=!i):t.push(n);return t.join("")},generateOnlyLatex(e){let t;try{t=Sa(e)}catch(a){return null}const i=(new Hl).buildCMOS(t),n=new yc;let s;try{s=n.buildHull(i,{channelWidth:.4})}catch(a){return null}return window.MathJax.options.ignoreHtmlClass="tex2jax_ignore",(new Ec).buildLatex(s,Sc).trim()},generateCmos(e){const t=new Hl;let i;try{i=Sa(e)}catch(u){return void(this.cmosError=u)}this.cmosError=null;const n=t.buildCMOS(i),s=new yc;let a;try{a=s.buildHull(n,{channelWidth:.4})}catch(u){return void(this.cmosErrorFormulaTooSimple=u)}this.cmosErrorFormulaTooSimple=null,this.renderedFormula=`\\(${Sc(i.expression)}\\)`;const o=new Jl,r=new Ec,l=100;window.MathJax.options.ignoreHtmlClass="tex2jax_ignore";const c=r.buildLatex(a,Sc).trim();this.latexText=c,this.latex=Al.A.highlight(c,{language:"tex"}).value.split("\n"),this.cmosOutput=this.toMathJax(o.buildSVG(a,Sc,l)),this.cmosOutput=this.cmosOutput.replaceAll("text-anchor","data-anchor"),this.cmosOutput=this.cmosOutput.replaceAll("text","foreignobject"),this.cmosOutput=this.cmosOutput.replaceAll("<foreignobject",'<foreignobject width=400 height=80 transform="translate(0, -25)"'),this.$nextTick((()=>{window.MathJax&&(window.MathJax.typeset(),this.$nextTick((()=>{const t=document.getElementsByTagName("foreignObject");for(const e of t)if("VCC"!==e.textContent&&"GND"!==e.textContent||(e.setAttribute("font-size","40"),"VCC"===e.textContent?e.setAttribute("transform","translate(-50, -35)"):e.setAttribute("transform","translate(-50 10)")),e.children.length>0){const t=e.children[0].offsetWidth,i=e.children[0].children[0].getClientRects()[0].height,n=100;e.style.lineHeight=0,e.setAttribute("data-actualHeight",`${i}`),e.setAttribute("width",`${t+10}`),e.setAttribute("height",n),"end"===e.getAttribute("data-anchor")?e.setAttribute("transform",`translate(-${t},-${i})`):e.setAttribute("transform",`translate(0,-${i})`)}this.$nextTick((()=>{let i=0,n=0;for(const e of t){const t=Number(e.getAttribute("x"))+Number(e.getAttribute("width")),s=Number(e.getAttribute("y"))+Number(e.getAttribute("height"));n=Math.max(s,n),i=Math.max(t,i)}const s=document.getElementById("cmosOutput").children[0],a=s.getAttribute("viewBox"),o=(a.split(" ").map((e=>Number(e))),50);s.setAttribute("viewBox",`${-o} ${-o} ${i+o} ${n+o}`),this.lastCmosFormula!==e&&(s.setAttribute("width",Number(s.getAttribute("width"))/2),s.setAttribute("height",Number(s.getAttribute("height"))/2)),this.lastCmosFormula=e}))})))})),this.reblurCMOS()},unblurDOM(e){if(!e||!e.target||!e.target.classList)return;if(e.target.classList.contains("blurred"))return void e.target.classList.remove("blurred");let t=e.target.parentNode;do{if(t.classList.contains("blurred"))return void t.classList.remove("blurred");t=t.parentNode}while(null!=t&&t.classList)},reblurCMOS(){const e=this.$refs.cmosOutput;e.classList.contains("blurred")||e.classList.add("blurred")},loadExerciseFromURL(){if(!this.$route.query)return;const e=this.$route.query.load;if(!e)return;const t=Lc(this.$i18n,e);-1!==t?(this.selectArchivedExercise(0,t),this.loadArchivedExercise(),this.$nextTick((()=>{this.$refs.archivedExercisesCMOSDropDownMenu.setSelected(t)}))):console.error("Unknown CMOS-exercise handle: ",e)},toggleLoadFromArchiveOrFormula(e){this.loadFromArchiveOrFormula=!e},selectRandomExerciseDifficulty(e,t){this.randomExerciseDifficultySelectedIndex=t},generateRandomFormula(){const e=Math.random()<.5?"a":"~a",t="a"===e?"~a":"a",i=Math.random()<.5?"b":"~b",n=Math.random()<.5?"c":"~c",s=Math.random()<.5?"d":"~d",a=Math.random()<.5?"+":"*",o="+"===a?"*":"+",r=Math.random()<.5?"+":"*";let l=[];switch(this.randomExerciseDifficultySelectedIndex){case"0":case"1":l=[e+a+i+r+n,`(${e}${a}${i})${o}(${n}${a}${s})`,`${e}*${n}+${t}`,`(${e}+${i})*${n}`,`${e}+${i}*${n}`,`${n}*(${e}+${i})`,`${n}*${e}+${i}`];break;case"2":l=[`${Math.random()<.5?"~":""}((${e}+${i})*${n}+~(${e}+${i}))`,`${Math.random()<.5?"~":""}(${e}*${i}+${n}+~(${e}*${i}))`];break;default:l=[`a${a}${i}`];break}return l[Math.floor(Math.random()*l.length)]},generateRandomExercise(){this.generateCmos(this.generateRandomFormula())}}};const Vc=(0,z.A)(Ac,[["render",Ll],["__scopeId","data-v-5e8aaa2c"]]);var Ic=Vc,Dc=i.p+"img/gtionline.e4742052.png";const Pc={class:"home"},Oc={class:"headerHome"},jc={class:"textHome"},Rc={class:"linkHome"},zc=["href","onClick"],Wc={class:"linkLabel"},qc={class:"imageContainer"},Hc={class:"startImg"},Uc={class:"imgDescription"};function Kc(e,t,i,n,s,a){const o=(0,m.g2)("router-link");return(0,m.uX)(),(0,m.CE)("div",Pc,[(0,m.Lk)("div",Oc,[t[1]||(t[1]=(0,m.Lk)("h1",{class:"titleHome"},[(0,m.Lk)("span",{class:"red"},"GTI"),(0,m.eW)(" ONLINE")],-1)),(0,m.Lk)("div",jc,[(0,m.Lk)("p",null,(0,p.v_)(e.$t("homePageText")),1)]),(0,m.Lk)("div",Rc,[(0,m.bF)(o,{to:"/fparithmetic",custom:""},{default:(0,m.k6)((({href:i,navigate:n,isActive:s,isExactActive:a})=>[(0,m.Lk)("a",{href:i,onClick:n,class:(0,p.C4)(["link",s&&"router-link-active",a&&"router-link-exact-active"])},[(0,m.Lk)("div",Wc,(0,p.v_)(e.$t("startTraining")),1),t[0]||(t[0]=(0,m.Lk)("div",{class:"linkButton"},null,-1))],10,zc)])),_:1})])]),(0,m.Lk)("div",qc,[(0,m.Lk)("div",Hc,[t[2]||(t[2]=(0,m.Lk)("img",{alt:"Image of a sequential circuit",src:Dc},null,-1)),(0,m.Lk)("p",Uc,(0,p.v_)(e.$t("sequentialCircuit")),1)])])])}var Gc={name:"homePage"};const Xc=(0,z.A)(Gc,[["render",Kc],["__scopeId","data-v-ab09266c"]]);var Zc=Xc;const Jc={class:"about pageContainer"},Yc={class:"title"},Qc={class:"bodyContainer"},eu={class:"icon"};function tu(e,t,i,n,s,a){const o=(0,m.g2)("font-awesome-icon");return(0,m.uX)(),(0,m.CE)("div",Jc,[(0,m.Lk)("h3",Yc,(0,p.v_)(e.$t("contact")),1),(0,m.Lk)("div",Qc,[(0,m.Lk)("h2",null,(0,p.v_)(e.$t("contactPersonHeader")),1),(0,m.Lk)("p",null,[(0,m.Lk)("span",eu,[(0,m.bF)(o,{icon:"envelope"})]),t[0]||(t[0]=(0,m.eW)()),t[1]||(t[1]=(0,m.Lk)("span",{class:"info"},[(0,m.Lk)("a",null,"cs12-gti@fau.de")],-1))]),(0,m.Lk)("h2",null,(0,p.v_)(e.$t("Danksagung")),1),(0,m.Lk)("p",null,(0,p.v_)(e.$t("thankProfessorTeich")),1),(0,m.Lk)("p",null,(0,p.v_)(e.$t("weThank")),1),(0,m.Lk)("p",null,"Daniel Seidel, Timo Teufel"+(0,p.v_)(e.$t("and"))+" Martin Zeus",1)])])}var iu={name:"contactForm"};const nu=(0,z.A)(iu,[["render",tu]]);var su=nu;const au=[{path:"/",name:"home",component:Zc},{path:"/contact",name:"contact",component:su},{path:"/fparithmetic",name:"FloatingPointTabs",component:Ci},{path:"/polyadic",name:"PolyadicNumbers",component:zn},{path:"/kvdiagram",name:"KVDiagram",component:or},{path:"/bfminimizer",name:"BooleanFunctionMinimizer",component:Xr},{path:"/descriptionpdf",name:"DescriptionPDF",component:rl},{path:"/cmos",name:"Cmos",component:Ic}];var ou=au,ru=i(4682),lu=JSON.parse('{"complementExample":"Komplementsrechnung","shiftZero":"Mantissennull nach Shift","doubleNegative":"Negativ","denormalized":"Denormalisierung","fpExerciseIntro":"Üben Sie die Gleitkommazahlen Arithmetik nach IEEE-754 anhand automatisch generierter Aufgaben.","fpFormatSelectionSimple":"Wählen Sie die Anzahl der Bits für den Exponenten und die Mantisse aus.","fpFormatSelection":"Definieren Sie die Bitbreite der Gleitkommazahl und wählen Sie dann die Anzahl der Bits für den Exponenten und die Mantisse aus.","fpArithIntro":"Üben Sie die Gleitkommazahlen Arithmetik nach IEEE-754 oder einem daran angelehnten selbstdefinierten Format.","fpConvIntro":"Üben Sie die Konversion zwischen dem Dezimalsystem und dem Gleitkommazahl Format nach IEEE-754 oder einem daran angelehnten selbstdefinierten Format anhand generierter Übungsaufgaben.","sequentialCircuit":"Beispiel eines Schaltwerks bestehend aus zwei D-Flipflops und mehreren Multiplexern.","polyadicDivisionDescription":"Die Vorkommastellen ergeben sich aus den Ziffern des Rests, indem man diese von unten nach oben ausliest.","polyadicMultiplicationDescription":"Die Nachkommastellen ergeben sich aus den Ziffern des Rests, indem man diese von oben nach unten ausliest.","homePageText":"Auf dieser Webseite können Sie Ihre Kenntnisse zu ausgewählten Themenschwerpunkten aus der Vorlesung Grundlagen der Technischen Informatik (GTI) und der zugehörigen Übung vertiefen.","startTraining":"Los geht\'s","polyFreeIntro":"Üben Sie die polyadische Arithmetik mit eigenen Zahlenwerten in Ihrem Wunschsystem.","polyConvGenIntro":"Üben Sie die Konversion zwischen polyadischen Systemen anhand generierter Übungsaufgaben.","polyConvIntro":"Üben Sie die Konversion zwischen polyadischen Systemen, die Sie frei auswählen können.","numVarInput":"Anzahl an Variablen","conversionExercise":"Aufgaben zur Konversion","impressum":"Impressum","copyright":"Lehrstuhl für Informatik 12, FAU. Alle Rechte vorbehalten.","herausgeber":"Herausgeber","disclaimerFooter":"Es wird keine Garantie für die Richtigkeit der auf dieser Website angebotenen Materialien übernommen.","representedByHeader":"Vertreten durch","contactPersonHeader":"Kontakt","representedBy":"Lehrstuhl für Informatik 12 ist eine Einrichtung des Öffentlichen Rechts innerhalb der Friedrich-Alexander-Universität Erlangen-Nürnberg (FAU). Gemäß Art. 20, 21 BayHSchG wird die FAU als staatliche Einrichtung und Selbstverwaltungskörperschaft des öffentlichen Rechts nach außen durch den Präsidenten vertreten.","haftungsauschlussHeader":"Haftungsausschluss","haftungsauschlussBody":"Für die Inhalte anderer Webangebote sind die jeweiligen Einrichtungen verantwortlich. Alle auf dieser Internetseite bereitgestellten Informationen haben wir nach bestem Wissen und Gewissen erarbeitet und geprüft. Eine Gewähr für die jederzeitige Aktualität, Richtigkeit, Vollständigkeit und Verfügbarkeit der bereit gestellten Informationen können wir allerdings nicht übernehmen. Ein Vertragsverhältnis mit den Nutzern des Internetangebots kommt nicht zustande. Wir haften nicht für Schäden, die durch die Nutzung dieses Internetangebots entstehen. Dieser Haftungsausschluss gilt nicht, soweit die Vorschriften des §839 des Bürgerlichen Gesetzbuches (Haftung bei Amtspflichtverletzung) einschlägig sind. Für etwaige Schäden, die beim Aufrufen oder Herunterladen von Daten durch Schadsoftware oder der Installation oder Nutzung von Software verursacht werden, wird nicht gehaftet. Als Diensteanbieter sind wir gemäß § 7 Abs.1 TMG für eigene Inhalte auf diesenSeiten nach den allgemeinen Gesetzen verantwortlich. Nach § 8 bis 10 TMG sind wir als Diensteanbieter jedoch nicht verpflichtet, übermittelte oder gespeicherte fremde Informationen zu überwachen oder nach Umständen zu forschen, die auf eine rechtswidrige Tätigkeit hinweisen. Verpflichtungen zur Entfernung oder Sperrung der Nutzung von Informationen nach den allgemeinen Gesetzen bleiben hiervon unberührt. Eine diesbezügliche Haftung ist jedoch erst ab dem Zeitpunkt der Kenntnis einer konkreten Rechtsverletzung möglich. Bei Bekanntwerden von entsprechenden Rechtsverletzungen werden wir diese Inhalte umgehend entfernen. Der Betreiber behält es sich ausdrücklich vor, einzelne Webseiten, Web-Dienste oder das gesamte Angebot ohne gesonderte Ankündigung zu verändern, zu ergänzen, zu löschen oder die Veröffentlichung zeitweise oder endgültig einzustellen.","confirm":"Bestätigen","varNaming":"Benennung der Variablen","kvDiagram":"KV-Diagramm","truthtable":"Funktionstabelle","numeralSystem":"Zahlensysteme","polyadic":"Polyadisch","floatingPoint":"Gleitkommazahlen","functionMin":"Funktionsminimierung","exercises":"Übungsaufgaben","generateEx":"Aufgabe Generieren","generate":"Generieren","addition":"Addition","subtraction":"Subtraktion","multiplication":"Multiplikation","division":"Division","ownSolution":"Eigene Lösung","signBit":"Vorzeichenbit","correctSolution":"Lösungsweg","solution":"Lösung","exponentBits":"Exponent","fractionBits":"Mantisse","attRound":"Runden nicht vergessen!","attSolve":"Bitte versuchen Sie, die Aufgabe vorher selbstständig zu lösen!","step":"Schritt","freeCalculation":"Freie Berechnung","operationSelect":"Operationsauswahl","firstFloatingPoint":"Erste Gleitkommazahl","secondFloatingPoint":"Zweite Gleitkommazahl","operand":"Operand","decimal":"Dezimalzahl","binary":"Binärzahl","inputNumber":"Zahl eingeben","fpformat":"Floating Point Format","check":"Überprüfen","values":"Werte","load":"Laden","arithmetic":"Arithmetik","conversion":"Konversion","conversionExercise1":"Konvertiere: ","conversionExercise2":"in eine IEEE-Gleitkommazahl einer Exponenten-Länge von ","steps":"Schritte","repeatMinuend":"wiederhole\\\\ Minuend","doDivision":"Divison durchführen","doMultiplication":"Multiplikation durchführen","getDescription":"Drucken","approach":"Lösungsweg","gti":"Grundlagen der Technischen Informatik","disclaimer":"Haftungsausschluss:<br>Dies ist ein durch die GTI-Online-Webseite automatisch generierter Lösungsweg. Wir können keine Korrektheit garantieren und der Lösungsvorschlag ist somit <u>inoffiziell</u>.<br>Wir geben uns große Mühe, um für euch ein zuverlässiges und korrektes Hilfsmittel zu entwickeln. Trotzdem kann es sein, dass der Lösungsweg oder die Lösung per se Fehler enthalten. Dies kann auch mit bestimmten Browserversionen zusammenhängen. Bitte überprüfen Sie den Lösungsansatz, bevor Sie diesen zum Beispiel in einer Klausur verwenden.","example":"Beispiel","composition":"Zusammensetzung","negativeSummand":"Eine Addition mit einem negativen Wert wird wie eine Subtraktion behandelt.","negativeSubtrahend":"Ein negativer Subtrahend wirkt sich wie ein positiver Summand aus.","negativeMinuendSubtrahend":"Vereinfachung für den Fall \\\\( - x - y \\\\rightarrow - (x + y) \\\\)","addWithZero":"Bei einer Addition mit 0 wird der andere Summand nicht verändert","subWithZero":"Bei einer Subtraktion mit 0 wird der Minuend nicht verändert","divWithZero":"Bei einer Division mit 0 im Zähler ist das Ergebnis 0.","mulWithZero":"Bei einer Multiplikation mit 0 ist das Ergebnis immer 0.","zeroDivision":"Eine Division durch 0 ist nicht möglich!","arithmeticFree":"Freie Arithmetik","conversionFree":"Freie Konvertierung","value":"Wert","givenValues":"Werte der übertragenen Zahlen","leftValue":"Zahl links","rightValue":"Zahl rechts","firstSummand":"1. Summand","secondSummand":"2. Summand","firstFactor":"1. Faktor","secondFactor":"2. Faktor","numerator":"Zähler","denominator":"Nenner","minuend":"Minuend","subtrahend":"Subtrahend","sign":"Vorzeichen","exponent":"Exponent","adjustExponents":"Die Exponenten beider Zahlen müssen angeglichen werden.","addExponents":"Die Exponenten beider Zahlen müssen addiert werden.","subtExponents":"Die Exponenten beider Zahlen müssen subtrahiert werden.","diffExponent":"Differenz Exponent","smallerExponent":"Es wird immer der kleinere vom größeren Exponenten subtrahiert.","resDiffExponent":"Daher ergibt sich eine Differenz von","newExponentDivision":"Der neue Exponent ergibt sich als \\\\( E_{\'{neu}\'} = E_1 - E_2 + BIAS = {E1} - {E2} + {Bias} = {Result} \\\\)","newExponentMultiplication":"Der neue Exponent ergibt sich als \\\\( E_{\'{neu}\'} = E_1 + E_2 - BIAS = {E1} + {E2} - {Bias} = {Result}\\\\, ({ExpBits})\\\\)","considerExponent":"Exponent beachten","fpExerciseText":"Es seien die Gleitkommazahlen \\\\( fp_1 \\\\) und \\\\( fp_2 \\\\) im 16 Bit Gleitkommaformat gegeben. Berechnen Sie die {op1} \\\\( fp_1 {op2} fp_2 \\\\) ohne die Binärdarstellung zu verlassen und geben Sie das Ergebnis wieder als Gleitkommazahl an:","mantissa":"Mantisse","solutionIsNan":"Die Mantisse muss nicht berechnet werden, da das Ergebnis sicher NaN ist.","solutionIsInf":"Die Mantisse muss nicht berechnet werden, da das Ergebnis sicher unendlich ist.","solutionIsZero":"Die Mantisse muss nicht berechnet werden, da das Ergebnis sicher 0 ist.","mulMantissa":"Die Mantissen beider Zahlen müssen multipliziert werden.","addMantissa":"Die Mantissen beider Zahlen müssen addiert werden.","divMantissa":"Die Mantissen beider Zahlen müssen dividiert werden.","newMantissa":"Neue Mantisse","zeroMantissa":"Mantissen sind identisch \\\\( \\\\rightarrow \\\\) neue Mantissa ist 0-Mantisse","newMantissaIs":"Wir rechnen also","newMantissaSignBit":"Aufgrund des Komplements rechnen wir mit einem Vorzeichenbit:","equalMantissa":"Die Mantissen sind identisch, \\\\( \\\\rightarrow \\\\) Exponent wird um 1 erhöht; die Mantisse bleibt gleich","equalMantissaDiv":"Die beiden Mantissen sind gleich, daher wird keine binäre Division durchgeführt. Die Mantisse lautet {Mantissa}.","adjustSmallerMantissa":"Anpassen der Mantisse","shiftMantissa":"Shiften der Mantisse","mantissaFloat":"Mantisse im Float","mantissaNormalize":"Damit die Mantisse mit einer führenden 1 beginnt, müssen wir die Mantisse normalisieren, indem wir den Shift von {shift} anwenden. Diesen Shift müssen wir auch auf den Exponenten verrechnen, wodurch sich der neue Exponent {exponent} ergibt","mantissaNormalizeDenorm":"Das Ergebnis kann mit dem Shift {shift} nicht in der normalisierten Darstellung dargestellt werden, weshalb wir die denormalisierte Darstellung mit dem Exponenten {exponent} verwenden.","mantissaDenormalize":"Da wir nach dem Anwenden des Shifts einen negativen Exponenten bekommen, müssen wir zur Darstellung des Ergebnisses die denormalisierte Darstellung verwenden. Dazu setzen wir den Exponenten vollständig auf 0 und shiften unsere Mantisse inklusive der führenden Eins um den Betrag des Exponenten. Bei der Mantisse wird hierbei eine führende 0 angenommen.","mantissa1float":"Schließlich entfernen wir die führende Stelle der Mantisse, um die Mantissenbits der IEEE-754 Repräsentation zu erhalten. Die Mantissenbits lauten demnach:","mantissaComplement":"Die Mantisse ist negativ. Wir müssen also das Komplement bilden und das Vorzeichenbit setzen.","subtTwosComplement":"Subtraktion entspricht der Addition mit dem Zweierkomplement","mantissaTwosComplement":"Bildung Zweierkomplement aus Mantisse","switchBits":"Bits umkehren","add1":"1 addieren","normalize":"Normalisieren","shiftExpMant":"Der Shift-Faktor des Exponenten muss auf die Mantissen angewendet werden.","shift":"Shift","considerRepresentation":"Darstellung beachten","consider1comma":"Die Mantisse beginnt in der Standard-Darstellung immer mit einer 1 vor dem Komma (und einer 0, wenn denormalisiert).","ternary":"Ternärzahl","quaternary":"Quaternärzahl","quinary":"Quintalzahl","senary":"Hexalzahl","septenary":"Heptalsystem","octal":"Oktalzahl","novenary":"Nonalzahl","hexadecimal":"Hexadezimalzahl","hex":"Hexadezimal","input":"Eingabe","number":"Nummer","representation":"Repräsentation im Ausgangsformat","firstFormat":"Ausgangsformat","secondFormat":"Zielformat","doConversion":"Konvertierung durchführen:","modus":"Modus","to":"nach","fp_from_archive":"Aus Übungsarchiv","TenToPower":"Bei der Konvertierung vom Dezimalsystem in ein anderes polyadisches System wird vor dem Komma der Divisions- und nach dem Komma der Multiplikationsalgorithmus angewendet.","PowerToTen":"Die Konvertierung eines beliebigen Systems in das Dezimalsystem läuft durch Summierung der potenzierten Stellen.","PowerToPower":"Die Konvertierung einer Zahl eines Zahlensystems in ein anderes Zahlensystem erfolgt in zwei Schritten. Zuerst wird die Zahl des ursprünglichen Systems durch Aufsummieren in das Dezimalsystem übertragen. Danach wird diese Dezimalzahl mittels sukzessiver Division der Vorkommastellen und sukzessiver Multiplikation der Nachkommastellen ins Zielsystem konvertiert.","noValuesBeforeComma":"Keine Werte vor dem Komma. Der Divisionsalgorithmus kann weggelassen werden","noValuesAfterComma":"Keine Werte nach dem Komma. Der Multiplikationssalgorithmus kann weggelassen werden","firstToTen":"1. Summieren der potenzierten Stellen","secondToPower":"2. Konvertierung mittels Divisions- und Multiplikationsalgorithmus","shortcutBinToHex":"Bei der Konvertierung von Binär nach Hex können die Werte direkt abgelesen werden.","shortcutHexToBin":"Bei der Konvertierung von Hex nach Binär können die Werte direkt abgelesen werden.","divisionAlgorithm":"Ganzzahliger Teil (Divisions-Algorithmus)","multiplicationAlgorithm":"Nachkommastellen (Multiplikations-Algorithmus)","summation":"Aufsummieren","factor":"Faktor","quotient":"Quotient","remainder":"Rest","newBasis":"Basis_{\'{neu}\'}","calcStep":"Rechenschritt","summands":"Summanden","polyadicExercise1":"Konvertiere die","polyadicExercise3":"in eine ","archive":"Archiv","exerciseArchive":"Aufgabenarchiv","randomExercise":"Zufällige Aufgabe","doCalculation":"Berechnen","colorCoding":"Farbkodierung","mathDistribution":"Distribuierung","easy":"einfach","difficultyMiddle":"mittel","difficultyHard":"schwer","sheet":"Blatt","goal":"Ziel","difficultyUC":"Schwierigkeit","bf_infotext_or_interact_with_kv":"Oder interagiere direkt mit dem KV-Diagramm","bf_infotext_kv_must_not_be_empty":"Die Funktion muss Einsstellen und Nullstellen enthalten.<br>Mit ausschließlich 0en oder ausschließlich 1en ist die optimale Umsetzung genau die Funktion, die immer 1, oder immer 0 ausgibt.<br>Da gibt es für uns kaum etwas zu optimieren.","bf_infotext_what_to_do":"Lade eine Übungsaufgabe oder gebe eine Boolesche Funktion mit Hilfe des KV-Diagrams oder der Funktionstabelle ein. Klicke dann auf \'Berechnen\' um loszulegen.","bf_infotest_click_on_hidden_areas_to_make_visible":"Klicke auf die versteckten Bereiche, um diese aufzudecken","bf_normal_forms":"Normalformen","bf_disjunctiveNormalForm":"Disjunktive Normalform","bf_conjunctiveNormalForm":"Konjunktive Normalform","bf_disjunctiveMinimalForm":"Disjunktive Minimalform","bf_conjunctiveMinimalForm":"Konjunktive Minimalform","bf_quineMCCluskeyClasses":"Quine McCluskey Klassen","bf_primeTerms":"Primterme","bf_primeImplicants":"Primimplikanten","bf_primeImplicates":"Primimplikate","bf_primeCoverTable":"Überdeckungstabelle","bf_petrickExpression":"Petrick Ausdruck","bf_minimalForms":"Minimalformen","bf_tableWithCyclicRest":"Zyklische Resttabelle","bf_einstelle":"Einsstelle","bf_nullstelle":"Nullstelle","bf_einstellen":"Einsstellen","bf_nullstellen":"Nullstellen","bf_goal_determine_DNF":"DNF bestimmen","bf_goal_determine_KNF":"KNF bestimmen","bf_goal_determine_prime_implicants":"Primimplikanten bestimmen","bf_goal_determine_prime_implicates":"Primimplikate bestimmen","bf_covertable_step_description_initial":"<h4>Initialer Schritt:</h4>Trage spaltenweise alle Basisterme ({ifMinTermsEinstellenElseNullstellen}) und reihenweise alle Primterme (PI) in die Tabelle ein. Überdeckt ein Primterm eine {ifMinTermsEinstelleElseNullstelle}, markiere jene Zelle mit einem X. Die Kosten (eng. cost) c eines Primterms sind die Anzahl seiner Literale. Je höher, desto aufwändiger (teurer) ist die Umsetzung in Hardware. <br>Tipp:<br>Ein PrimimplikaNT überdeckt eine EINstelle genau dann, wenn alle Literale des Primterms auch genauso im Basisterm vorkommen","bf_covertable_step_description_core_found":"<h4>Kern gefunden:</h4>Der einzige Primterm, der die {ifMinTermsEinstelleElseNullstelle} {columnName} überdeckt, ist Term {rowName}. Dieser Primterm muss also unbedingt in unserer Schaltfunktion vorkommen! Markiere die Zeile als Kern und streiche die Spalte heraus.","bf_covertable_step_description_cross_column_bc_covered":"<h4>Spalte bereits abgedeckt:</h4>Die {ifMinTermsEinstellenElseNullstellen} {columnName} wird bereits vom Primterm {rowName} überdeckt. Streiche die Spalte heraus.","bf_covertable_step_description_cross_row_bc_covered":"<h4>Reihe bereits vollständig abgedeckt:</h4>Alle X\'e der Zeile {rowName} werden bereits abgedeckt. Streiche die Reihe heraus.","bf_covertable_step_description_row_domination":"<h4>Zeilendominanz:</h4>Die Zeile {dominatorName} dominiert die Zeile {dominatedName}, d.h. {dominatorName} besitzt überall da Markierungen, wo Zeile {dominatedName} auch welche besitzt (und vielleicht sogar mehr). => Streiche die dominieRTE Zeile {dominatedName}. <br>Beachte, dass die Zeilendominanz nur anwendbar ist, da die Zeile {dominatorName} weniger oder genauso viel kostet wie {dominatedName}; bzw. weil es keine andere Zeile gibt, die die zusätzlichen Stellen von {dominatorName} überdeckt und weniger als {dominatorName} - {dominatedName} kostet.","bf_covertable_step_description_column_domination":"<h4>Spaltendominanz:</h4>Die Spalte {dominatorName} dominiert die Spalte {dominatedName}, d.h. {dominatorName} besitzt überall da Markierungen, wo Spalte {dominatedName} auch welche besitzt (und vielleicht sogar mehr). => Streiche die dominieRENDE Spalte {dominatorName}<br>Im Gegensatz zur Zeilendominanz muss bei der Spaltendominanz überhaupt nicht auf Kosten geachtet werden (/▽＼)","bf_covertable_step_description_cyclic_rest":"<h4>Zyklischer Rest:</h4>Keine Regel der Überdeckungstabelle ist anwendbar. Man spricht hierbei von einem \'Zyklischem Rest\'.<br>Um nun dennoch eine Minimalform der Schaltfunktion bestimmen zu können, bietet sich eine Aufstellung des Petrick Ausdrucks an, wobei nur Zeilen und Spalten eingetragen werden, die noch nicht herausgestrichen wurden.","bf_infoblob_random_exercise_selection":"Die ausgewählte Schwierigkeit bestimmt dabei, wie viele Terme einer Art (z.B. Minterme, Primimplikanten) die Schaltfunktion enthalten soll.","bf_infoblob_petrick_statement":"Der Algorithmus besteht aus zwei Phasen:<ol><li>Ordne die Terme so um, dass möglichst viel absorbiert wird.</li><li>Multipliziere die Terme aus.</li></ol>","bf_infoblob_load_exercise":"Lade Aufgaben aus den Übungen oder gebe eine Boolesche Funktion ein.<br><br><b>Funktionseingabe:</b><br>Benutze + als logisches ODER<br>Benutze * als logisches UND<br>Benutze ~ als logisches NICHT<br><b>Beispiele:</b><br>a*b+a<br>a*(b+~a)<br>x0*x1+x0*~x1","bf_load_exercise_from_archive":"Lade Aufgabe aus Archiv","bf_error_at_symbol":"Fehler bei Symbol","cmos_error_at_symbol":"Fehler bei Symbol","at_position":"auf Position","cmos_enter_more_than_one_variable":"Bitte gebe mehr als nur eine Variable ein","bf_distributionUC":"Distribution","bf_idempotenceUC":"Idempotenz","bf_absorptionUC":"Absorption","bf_sortingUC":"Sortierung","bf_infoblob_functionMin":"Üben Sie die verschiedenen Verfahren zur Funktionsminimierung","bf_disjunctiveNormalForm_explanation":"Bei der disjunktiven Normalform handelt es sich um eine Disjunktion (Veroderung) aller Minterme (1en) einer Funktion. Jeder Minterm entspricht genau einer 1 in der Funktion; es müssen darin alle Literale negiert oder nicht negiert vorkommen.","bf_conjunctiveNormalForm_explanation":"Bei der konjunktiven Normalform handelt es sich um eine Konjunktion (Verundung) aller Maxterme (0en) einer Funktion. Die 0en werden bei Maxtermen nicht ausgewählt (wie die 1en bei Mintermen), sondern ausgeschlossen. Jeder Maxterm entspricht genau einer 0 in der Funktion; es müssen darin alle Literale negiert oder nicht negiert vorkommen.","bf_quineMCCluskeyClasses_explanation":"Beim Quine/McCluskey Verfahren handelt es sich um ein Minimierungsverfahren, mit welchem die Primterme einer Funktion bestimmt werden können.","bf_infoblob_quineMCCluskeyClasses_colorCoding":"Die reduzierten Terme werden beim Quine/McCluskey Verfahren üblicherweise durch Durchstreichen markiert. Wenn die Farbkodierung aktiv ist, werden sie stattdessen hellgrau eingefärbt. ","bf_infoblob_quineMCCluskeyClasses_01":"Normalerweise schreiben wir die Min-, bzw. Maxterme in die einzelnen Klassen. Es kann alternativ aber auch mit 0en (für negierte Literale) und 1en (für nicht negierte Literale) gearbeitet werden, wobei die Postion dieser bestimmt, um welches Literal es sich handelt.","bf_primeTerms_explanation":"Terme mit minimaler Anzahl an Literalen, die nur Einsstellen bzw. Nullstellen überdecken. ","bf_bf_primeImplicants_explanation":"PrimimplikaNTe sind Primterme, die nur EINstellen (mit Freistellen) überdecken. ","bf_primeImplicates_explanation":"Primimplikate sind Primterme, die nur Nullstellen (mit Freistellen) überdecken. ","bf_disjunctiveMinimalForm_explanation":"Disjunktion von durch Konjunktion verknüpften Literalen. Diese kann (ohne diese Form zu verletzen) nicht weiter vereinfacht werden (vereinfachte DNF).","bf_conjunctiveMinimalForm_explanation":"Konjunktion von durch Disjunktion verknüpften Literalen. Diese kann (ohne diese Form zu verletzen) nicht weiter vereinfacht werden (vereinfachte KNF).","bf_nandnorification":"NAND- / NORisierung","bf_nandification":"NANDisierung","bf_norification":"NORisierung","bf_nandify_double_negation_text":"Doppelt negieren","bf_nandify_nor_to_and_text":"De Morgansche Gesetz (Negation reinziehen)","bf_nandify_redundant_and_text":"Term im AND verdoppeln (x = x*x)","bf_norify_double_negation_text":"Doppelt negieren","bf_norify_nand_to_or_text":"De Morgansche Gesetz (Negation reinziehen)","bf_norify_redundant_or_text":"Term im OR verdoppeln (x = x+x)","cmos_infoblob_description":"Bei CMOS handelt es sich um eine Zusammensetzung aus einem komplementären NMOS-Schaltnetz (Pull-Down-Netzwerk, da mit Erdung verbunden) und PMOS-Schaltnetz (Pull-Up-Netzwerk, da mit Versorgunsspannung verbunden). Dadurch wird im festen Schaltzustand weniger Energie verbraucht, da PDN und PUN komplementär sind und somit nur bei Schalten kurz gleichzeitig leiten. Es wird jedoch mehr Fläche auf dem Chip benötigt.","cmos_infoblob_input_description":"Hinweis: Für ODER-Gatter kann \'+\' genutzt werden, für UND-Gatter \'*\' und für die Negation \'~\'. Variablen können beliebige Namen haben (Achtung: die Eingabe \'ab\' wird als eine Variable interpretiert und nicht als Verundung von \'a\' und \'b\').","enter_cmos":"Bitte geben Sie Ihren CMOS-Eintrag ein.","polyadicExercise2":"vom initialen Format:","newExponent":"Neuer Exponent","systemInBase":"System zur Basis","basis":"Basis","minterms":"Minterme","maxterms":"Maxterme","contact":"Kontakt","impressumText":"Sie finden das Impressum unter: ","and":" und","weThank":"Wir danken den folgenden Personen für ihre Mithilfe beim Erstellen dieser Webseite:","Danksagung":"Danksagung","thankProfessorTeich":"Die Materialien dieser Seite basieren auf der Vorlesung GTI von Professor Dr.-Ing. Jürgen Teich der Friedrich-Alexander-Universität (FAU). Wir danken Ihm für seine Expertise und Schirmherrschaft.","wintersemester":"Wintersemester","sommersemester":"Sommersemester","downloadSvg":"Exportiere SVG","downloadPng":"Exportiere PNG","formula":"Formel","translate_big":"Übersetzen","divByZero":"Division durch 0 ergibt NaN.","falseFormat":"Falsches Format"}'),cu=JSON.parse('{"complementExample":"Complement","shiftZero":"Zero after shift","doubleNegative":"Negative","denormalized":"Denormalization","fpExerciseIntro":"Practice arithmetic between floating point numbers in IEEE-754 format using generated exercises","fpFormatSelectionSimple":"To select a custom format, specify the distribution of bits between exponents and mantissa.","fpFormatSelection":"To select a custom format, first select the number of bits of the floating point number, and then specify the distribution of bits between exponents and mantissa.","fpArithIntro":"Practice arithmetic between floating point numbers in the format according to IEEE-754 or a self-defined format based on it.","fpConvIntro":"Practice conversion between the decimal system and floating-point number format according to IEEE-754 or a self-defined format based on it, using generated practice problems.","polyConvIntro":"Practice conversion between positional numeral systems that you can freely choose.","polyConvGenIntro":"Practice the conversion between positional numeral systems by solving generated exercises.","polyadicMultiplicationDescription":"The digits after the decimal point are obtained from the digits of the remainder by reading them from top to bottom.","polyadicDivisionDescription":"The digits before the decimal point result from the digits of the remainder by reading them from bottom to top.","enter_cmos":"Please enter your CMOS formula.","sequentialCircuit":"Example of a sequential circuit comprising two D-flip-flops and multiplexers.","homePageText":"The goal of GTI-Online is to deepen the knowledge of selected topics learned in the lecture and corresponding exercise. Select in the menu a topic and start practicing.","startTraining":"Let\'s go","numVarInput":"Number of variables","fpExerciseText":"Let \\\\( fp_1 \\\\) and \\\\( fp_2 \\\\) be given as floating point numbers in 16 bit floating point format. Compute the {op1} \\\\( fp_1 {op2} fp_2 \\\\) without leaving the binary representation and specify it again as a floating point number:","confirm":"Confirm","varNaming":"Variable naming","kvDiagram":"Karnaugh Map","truthtable":"Function Table","numeralSystem":"Numeral System","polyadic":"Positional numeral system","floatingPoint":"Floating Points","functionMin":"Minimization","exercises":"Exercises","generateEx":"Generate Exercise","generate":"Generate","polyFreeIntro":"Practice positional numeral arithmetic with your own numerical values in your desired system.","addition":"Addition","subtraction":"Subtraction","multiplication":"Multiplication","division":"Division","solution":"Solution","ownSolution":"Own Solution","signBit":"Sign Bit","load":"Load","correctSolution":"Solution","exponentBits":"Exponent","fractionBits":"Fraction","attRound":"Do not forget to round!","attSolve":"Please try to solve the exercise beforehand!","step":"Step","freeCalculation":"Free Calculation","operationSelect":"Configure Computation","firstFloatingPoint":"First Floating Point Number","secondFloatingPoint":"Second Floating Point Number","operand":"Operand","decimal":"Decimal","binary":"Binary","inputNumber":"Input Number","fpformat":"Floating Point Format","check":"Check","values":"Values","arithmetic":"Arithmetic","conversion":"Conversion","conversionExercise":"Exercises for conversion","conversionExercise1":"Convert: ","conversionExercise2":"into a IEEE floating point number with exponent length of ","steps":"steps","repeatMinuend":"repeat\\\\ minuend","doDivision":"execute division","doMultiplication":"execute multiplication","getDescription":"Print","approach":"Approach","gti":"Foundations of Computer Engineering","disclaimer":"Disclaimer:<br>This is an automatically generated solution approach by the GTI-Online-Website. Every output is completely <u>unofficial</u> and in the drafts state.<br>We are making lots of efforts to build a correct and reliable tool for you. Regardless, there may be failures in the solution or approach. That can especially depend on your browser version. Please review before using it for instance in an exam.","example":"Example","composition":"composition","negativeSummand":"An addition with a negative value is similar to a subtraction.","negativeSubtrahend":"A negative subtrahend is similar to a positive summand.","negativeMinuendSubtrahend":"Simplification for the case \\\\( - x - y \\\\rightarrow - (x + y) \\\\)","addWithZero":"An addition with 0 results in the other summand","subWithZero":"A subtraction with 0 results in the other value","mulWithZero":"A multiplication with 0 results always 0.","zeroDivision":"A division by 0 is illegal!","arithmeticFree":"Free arithmetic","conversionFree":"Free conversion","value":"Value","givenValues":"Values of the transmitted numbers","leftValue":"Left value","rightValue":"Right value","firstSummand":"1. summand","secondSummand":"2. summand","firstFactor":"1. factor","secondFactor":"2. factor","minuend":"Minuend","subtrahend":"Subtrahend","numerator":"Numerator","denominator":"Denominator","sign":"Sign","exponent":"Exponent","adjustExponents":"The exponents of both numbers must be balanced.","addExponents":"The exponents of both numbers must be added.","subtExponents":"The exponents of both numbers must be subtracted.","diffExponent":"Difference of the exponents","smallerExponent":"The smaller exponent will be subtracted from the bigger one.","resDiffExponent":"Hence, this difference is","newExponent":"New exponent","considerExponent":"Consider the exponent","mantissa":"Mantissa","mulMantissa":"The mantissa of both numbers must be multiplied.","solutionIsNan":"The mantissa can not be calculated because the input leads to NaN.","solutionIsInf":"The mantissa can not be calculated because the input leads to infinity.","solutionIsZero":"The mantissa can not be calculated because the input leads to zero.","addMantissa":"The mantissa of both numbers must be added.","divMantissa":"The mantissa of both numbers must be divided.","newMantissa":"New mantissa","zeroMantissa":"both mantissa are equal \\\\( \\\\rightarrow \\\\) the new mantissa is the 0-mantissa","newMantissaIs":"Hence the new mantissa is","equalMantissa":"Both mantissa are equal \\\\( \\\\rightarrow \\\\) the exponent will be incremented the mantissa remains","equalMantissaDiv":"Both mantissa are equal, no binary division will be executed","adjustSmallerMantissa":"Adjust the mantissa","shiftMantissa":"Shift the mantissa","mantissaFloat":"Mantissa inside the float","mantissa1float":"The leading digit is not part of the float","subtTwosComplement":"Subtraction is similar to addition with the two\'s complement","mantissaTwosComplement":"Formation of the two\'s complement out of the mantissa","switchBits":"Invert bits","add1":"Add 1","normalize":"Normalize","shiftExpMant":"The exponent\'s shift factor must be applied to the mantissa.","shift":"Shift","considerRepresentation":"Consider the representation","consider1comma":"The mantissa begins with an 1 in the standard form (and 0 in denormalized form).","ternary":"Ternary system","quaternary":"Quaternary system","quinary":"Quinary system","senary":"Senary system","septenary":"Septenary system","octal":"Octal system","novenary":"Nonal system","hexadecimal":"Hexadecimal system","hex":"Hexadecimal","input":"Input","number":"Number","representation":"representation in original format","firstFormat":"Initial format","secondFormat":"Target format","doConversion":"Convert:","modus":"Mode","to":"to","fp_from_archive":"From the Archive","TenToPower":"The conversion from the decimal system to an arbitrary one goes in two steps. Before the comma, the digits were converted with the use of the division algorithm. After the comma, the multiplication algorithm will be applied.","PowerToTen":"An arbitrary number system can be converted to the decimal system by summarizing all potentiated digits.","PowerToPower":"We convert an arbitrary number system into another within two steps via the decimal system. At first, the original number will be transferred into the decimal system be summarizing the potentiated digits. In the second step, we use the division- and multiplication algorithm to create the resulting number.","noValuesBeforeComma":"There are no values in front of the comma. Therefore, the division algorithm can be skipped.","noValuesAfterComma":"There are no values after the comma. Therefore, the multiplication algorithm can be skipped.","firstToTen":"1. Summation of the potentiated digits","secondToPower":"2. Conversion via division- and multiplication algorithm","shortcutBinToHex":"At the conversion from binary to hexadecimal, the values can be read directly.","shortcutHexToBin":"At the conversion from hexadecimal to binary, the values can be read directly.","divisionAlgorithm":"Division algorithm","multiplicationAlgorithm":"Multiplication algorithm","summation":"Summation","factor":"Factor","quotient":"Quotient","remainder":"Remainder","newBasis":"Base_{\'{new}\'}","calcStep":"calculation\\\\ step","summands":"Summands","newMantissaSignBit":"Because of the complement, we calculate with a sign bit:","disclaimerFooter":"No warranty is given for the correctness of the materials provided on this website.","polyadicExercise1":"Convert the value in the","polyadicExercise2":"from the initial format","polyadicExercise3":"to the target format","archive":"archive","exerciseArchive":"Exercise Archive","randomExercise":"Random Exercise","doCalculation":"Calculate","colorCoding":"Color coding","mathDistribution":"Distribution","easy":"Easy","difficultyMiddle":"Middle","difficultyHard":"Hard","sheet":"Sheet","goal":"Goal","difficultyUC":"Difficulty","bf_infotext_or_interact_with_kv":"Or directly interact with the KV-Diagram","bf_infotext_kv_must_not_be_empty":"The function must contain 1s and 0s.<br>With only 1s or only 0s, the optimized function will be either the function that always outputs a 1, or always outputs a 0, nevertheless the input.<br>Thus there would not remain much optimization for us to do.","bf_infotest_click_on_hidden_areas_to_make_visible":"Click on hidden areas to reveal them","bf_infotext_what_to_do":"Load an exercise or specify a boolean function using the KV-Diagram or Function Table. Then press \'Calculate\' to begin.","bf_normal_forms":"Normal Forms","bf_disjunctiveNormalForm":"Disjunctive normal form","bf_conjunctiveNormalForm":"Conjunctive normal form","bf_disjunctiveMinimalForm":"Disjunctive minimal form","bf_conjunctiveMinimalForm":"Conjunctive minimal form","bf_quineMCCluskeyClasses":"Quine MC Cluskey classes","bf_primeTerms":"Implicants (prime terms)","bf_primeImplicants":"Prime implicants","bf_primeImplicates":"Prime implicates","bf_primeCoverTable":"Prime implicant chart / \'Cover Table\'","bf_petrickExpression":"Petrick\'s method","bf_minimalForms":"Minimal Forms","bf_tableWithCyclicRest":"Table with cyclic rest","bf_einstelle":"One","bf_nullstelle":"Zero","bf_einstellen":"Ones","bf_nullstellen":"Zeros","bf_goal_determine_DNF":"Determine DNF","bf_goal_determine_KNF":"Determine KNF","bf_goal_determine_prime_implicants":"Determine prime implicants","bf_goal_determine_prime_implicates":"Determine prime implicates","bf_covertable_step_description_initial":"<h4>Initial step:</h4>Enter all base terms in the columns and all implicants (PI) in the rows of the table. If a implicant covers a {ifMinTermsEinstelleElseNullstelle}, mark that cell with an X. The cost c of an implicant is the number of its literals. The higher, the more complex (i.e. costly) the implementation in hardware.<br>Tip:<br>A prime implicant covers a \'ONE\' exactly if all literals of the implicant also occur in the same way in the base term.","bf_covertable_step_description_core_found":"<h4>Core found:</h4>The only implicant that covers column {columnName} is term {rowName}. Hence this implicant must definitely appear in our resulting function! Mark the row as a \'core\' (Kern) and strike out the column.","bf_covertable_step_description_cross_column_bc_covered":"<h4>Column already covered:</h4> Column {columnName} is already being covered by implicant {rowName}. Strike out the column.","bf_covertable_step_description_cross_row_bc_covered":"<h4>Row already covered:</h4>All X\'s of row {rowName} are already covered. Cross out the row.","bf_covertable_step_description_row_domination":"<h4>Row dominance:</h4>Row {dominatorName} dominates row {dominatedName}; i.e. row {dominatorName} has markers wherever row {dominatedName} does as well (and possibly more!). => cross the dominaTED row {dominatedName}. <br>Note that row dominance is only applicable, because row {dominatorName} costs less than, or the same as {dominatedName}; or because there is no other row that covers the additional markers of {dominatorName} and costs less than {dominatorName} - {dominatedName}.","bf_covertable_step_description_column_domination":"<h4>Column dominance:</h4>Column {dominatorName} dominates column {dominatedName}; i.e. column {dominatorName} has markers wherever column {dominatedName} does as well (and possibly more!). => Cross the dominaTING column {dominatorName}<br>Unlike with row dominance, column dominance doesn\'t require you to consider costs at all.","bf_covertable_step_description_cyclic_rest":"<h4>Cyclic rest:</h4>No rule of the prime table algorithm is applicable. This is referred to as a \'cyclic rest\' (ger: \'Zyklischer Rest\').<br>By setting up the Petrick\'s expression (ger: Petrick Ausdruck) for the rest table, one is still able to determine a minimal form of the original function.","bf_infoblob_random_exercise_selection":"Difficulty states how many individual terms of some kind (e.g. minterms, prime implicants) the boolean function should yield.","bf_infoblob_petrick_statement":"The algorithm consists of two phases:<ol><li>Make terms that absorb each other easily visible through sorting (only shown if it has any effect)</li><li>Multiply the first two terms with each other until the typical sum remains.</li></ol>","bf_infoblob_load_exercise":"Load exercises from the Tutorium or generate them from boolean formulas<br><br><b>Entering Formulas:</b><br>Use + for logical OR<br>Use * for logical AND<br>Use ~ for logical NOT<br><b>Examples:</b><br>a*b+a<br>a*(b+~a)<br>x0*x1+x0*~x1","bf_load_exercise_from_archive":"Load exercise from archive","bf_error_at_symbol":"Error at symbol","cmos_error_at_symbol":"Error at symbol","at_position":"at position","cmos_enter_more_than_one_variable":"Please enter more than one variable","bf_distributionUC":"Distribution","bf_idempotenceUC":"Idempotence","bf_absorptionUC":"Absorption","bf_sortingUC":"Sorting","bf_infoblob_functionMin":"On this page you can find different procedures for minimizing boolean expressions.","bf_disjunctiveNormalForm_explanation":"The disjunctive normal form is a disjunction (combination of the terms using or operators) of all minterms (1s) of a function. Each minterm corresponds exactly to a 1 in the function, all literals must occur negated or not negated.","bf_conjunctiveNormalForm_explanation":"The conjunctive normal form is a conjunction (combination of the terms using and operators) of all maxterms (0s) of a function. The 0s are not selected in maxterms (like 1s in minterms), but excluded. Each maxterm corresponds exactly to a 0 in the function, all literals must occur negated or not negated.","bf_quineMCCluskeyClasses_explanation":"The Quine/McCluskey algorithm is a minimization algorithm with which the implicants of a function can be determined.","bf_infoblob_quineMCCluskeyClasses_colorCoding":"All terms used in the reduction are normally crossed out in the Quine/McCluskey algorithm. If color coding is active, they are displayed in light gray instead.","bf_infoblob_quineMCCluskeyClasses_01":"Normally we write the min or max terms into the individual classes. Alternatively, we can also work with 0s (for negated literals) and 1s (for non-negated literals), whereby the position of these determines which literal it is.","bf_primeTerms_explanation":"Terms with a minimum number of literals covering only ones or zeros.","bf_bf_primeImplicants_explanation":"Prime implicants are terms that cover only ones (with don\'t cares).","bf_primeImplicates_explanation":"Prime implicates are terms which cover only zeros (with don\'t cares).","bf_disjunctiveMinimalForm_explanation":"Disjunction of literals linked by conjunction, which cannot be further simplified (without violating this form) (simplified DNF).","bf_conjunctiveMinimalForm_explanation":"Conjunction of literals linked by disjunction, which cannot be further simplified (without violating this form) (simplified KNF).","bf_nandnorification":"NAND- / NORification","bf_nandification":"NANDification","bf_norification":"NORification","bf_nandify_double_negation_text":"negate twice","bf_nandify_nor_to_and_text":"De Morgan\'s Law (pull negation in)","bf_nandify_redundant_and_text":"Duplicate term in AND (x = x*x)","bf_norify_double_negation_text":"negate twice","bf_norify_nand_to_or_text":"De Morgan\'s Law (pull negation in)","bf_norify_redundant_or_text":"Duplicate term in OR (x = x+x)","cmos_infoblob_description":"CMOS is a composition of a complementary NMOS  network (pull-down network, since connected to ground) and PMOS network (pull-up network, since connected to supply voltage).\\n As a result, less energy is consumed in the fixed switching state, since PDN and PUN are complementary and thus only conduct simultaneously for a short time during switching. However, more area is required on the chip.","cmos_infoblob_input_description":"Note: For OR gates \'+\' can be used, for AND gates \'*\' and for negation \'~\'. Variables can have arbitrary names (Attention: \'ab\' is considered as one variable, not as \'a\' multiplied by \'b\').","contactPersonHeader":"Contact","herausgeber":"Publisher","divWithZero":"For a division with 0 in the numerator, the result is always 0.","impressum":"Imprint","representedByHeader":"Represented by","copyright":"Chair of Computer Science 12, FAU. All rights reserved.","representedBy":"Chair of Computer Science 12 is a public law institution within the Friedrich-Alexander-Universität Erlangen-Nürnberg (FAU). According to Art. 20, 21 BayHSchG, FAU, as a state institution and self-governing body under public law, is represented externally by the President.","haftungsauschlussHeader":"Disclaimer","mantissaComplement":"The mantissa is negative. So we have to form the complement and set the sign bit.","mantissaNormalize":"To make the mantissa start with a leading 1, we need to normalize the mantissa by applying the shift of {shift}. We also have to apply this shift to the exponent, which results in the new exponent {exponent}.","mantissaNormalizeDenorm":"The result cannot be represented in the normalized representation with the shift {shift}, so we use the denormalized representation with the exponent {exponent}.","newExponentDivision":"The new exponent results as \\\\( E_{\'{neu}\'} = E_1 - E_2 + BIAS = {E1} - {E2} + {Bias} = {Result} \\\\)","newExponentMultiplication":"The new exponent results as \\\\( E_{\'{neu}\'} = E_1 + E_2 - BIAS = {E1} + {E2} - {Bias} = {Result}\\\\, ({ExpBits})\\\\)","haftungsauschlussBody":"The respective institutions are responsible for the content of other websites. All information provided on this website has been compiled and checked to the best of our knowledge and belief. However, we cannot guarantee that the information provided is up-to-date, correct, complete or available at all times. A contractual relationship with the users of the Internet offer does not come about. We are not liable for any damage caused by the use of this internet offer. This exclusion of liability does not apply if the provisions of §839 of the German Civil Code (liability for breach of official duty) are relevant. No liability is accepted for any damage caused by malware or the installation or use of software when calling up or downloading data. As a service provider, we are responsible for our own content on these pages in accordance with § 7 para.1 TMG under the general laws. According to § 8 to 10 TMG we are not obligated to monitor transmitted or stored information or to investigate circumstances that indicate illegal activity. Obligations to remove or block the use of information under the general laws remain unaffected. However, liability in this regard is only possible from the point in time at which a concrete infringement of the law becomes known. If we become aware of any such infringements, we will remove the relevant content immediately. The operator expressly reserves the right to change, supplement or delete individual web pages, web services or the entire offer without separate announcement or to cease publication temporarily or permanently.","systemInBase":"System of base","basis":"Base","minterms":"Minterms","maxterms":"Maxterms","contact":"Contact","impressumText":"The imprint can be found at: ","and":", and","weThank":"We would like to thank the following people for their help at creating this website:","Danksagung":"Acknowledgement","thankProfessorTeich":"The materials on this page are based on the lecture GTI by Professor Dr.-Ing. Jürgen Teich of the Friedrich-Alexander-University (FAU). We thank him for his expertise and patronage.","wintersemester":"Winter term","sommersemester":"Summer term","downloadSvg":"Export as SVG","downloadPng":"Export as PNG","formula":"Formula","translate_big":"Translate","divByZero":"Division by 0 is NaN.","falseFormat":"Wrong format!"}'),uu=JSON.parse('{"complementExample":"Complement","shiftZero":"Zéro après le décalage","doubleNegative":"Negative","denormalized":"Denormaliser","fpExerciseIntro":"Entraînez-vous à l\'arithmétique entre nombres à virgule flottante au format IEEE-754 à l\'aide d\'exercices générés","fpFormatSelectionSimple":"Pour choisir votre propre format, définissez la répartition des bits entre l\'exposant et la mantisse","fpFormatSelection":"Pour choisir un format personnalisé, sélectionnez d\'abord le nombre de bits du nombre à virgule flottante, puis définissez la répartition des bits entre les exposants et les mantisses.","fpArithIntro":"Entraînez-vous à l\'arithmétique entre nombres à virgule flottante dans le format IEEE-754 ou dans un format défini par l\'utilisateur qui s\'en inspire","fpConvIntro":"Entraînez-vous à la conversion entre le système décimal et le format de nombres à virgule flottante IEEE-754 ou un format défini par l\'utilisateur qui s\'en inspire, à l\'aide d\'exercices générés","polyConvIntro":"Entraînez-vous à la conversion entre des systèmes polyadiques que vous pouvez choisir librement.","polyConvGenIntro":"Pratiquez la conversion entre systèmes polyadiques en résolvant les exercices générés.","fpExerciseText":"On donne les nombres à virgule flottante \\\\( fp_1 \\\\) et \\\\( fp_2 \\\\) au format 16 bits à virgule flottante. Calculez \\\\( fp_1 {op2} fp_2 \\\\) ({op1}) sans quitter la représentation binaire et redonnez le sous forme de nombre à virgule flottante:","polyadicDivisionDescription":"Les chiffres avant la virgule sont obtenus à partir des chiffres du reste, en les lisant de bas en haut.","polyadicMultiplicationDescription":"Les chiffres après la virgule sont obtenus à partir des chiffres du reste, en les lisant de haut en bas.","numVarInput":"Nombre de Variables","confirm":"Confirmer","input":"Entrée","disclaimerFooter":"Aucune garantie n\'est donnée quant à l\'exactitude du matériel mis à disposition sur ce site.","varNaming":"Nommage des Variables","kvDiagram":"Table de Karnaugh","numeralSystem":"Système de numération","polyadic":"Polyadique","floatingPoint":"Virgule flottante","functionMin":"Minimisation","exercises":"Exercises","newMantissaSignBit":"En raison du complément, nous comptons avec un bit de signe :","generateEx":"Générer l\'exercice","generate":"Générer","addition":"Addition","subtraction":"Soustraction","multiplication":"Multiplication","division":"Division","solution":"Solution","ownSolution":"Propre Solution","signBit":"Signe","correctSolution":"Solution","exponentBits":"Exposant","load":"Charger","fractionBits":"Mantisse","attRound":"N\'oubliez pas d\'arrondir!","attSolve":"Veuillez essayer de résoudre l\'exercice au préalable!","step":"Étape","freeCalculation":"Calcul libre","operationSelect":"Configurer le calcul","firstFloatingPoint":"Premier numéro à virgule flottante","secondFloatingPoint":"Deuxième numéro à virgule flottante","polyFreeIntro":"Entraînez-vous à l\'arithmétique polyadique avec vos propres valeurs numériques dans le système de votre choix.","operand":"Operand","decimal":"Décimale","binary":"Binaire","inputNumber":"Entrez le numéro","fpformat":"Format en virgule flottante","check":"Vérifier","values":"Valeurs","arithmetic":"Arithmétique","conversion":"Conversion","conversionExercise1":"Convertir: ","conversionExercise2":"en un nombre à virgule flottante IEEE avec un exposant de longueur de ","steps":"étapes","repeatMinuend":"repeat\\\\ minuend","doDivision":"réaliser la division","doMultiplication":"réaliser la multiplication","getDescription":"Imprimer","approach":"Approche","gti":"Fondements de l\'ingénierie informatique","disclaimer":"Disclaimer:<br>Il s\'agit d\'une approche de solution générée automatiquement par le GTI-Online-Website. Chaque sortie est complètement <u>non officielle</u> et à l\'état de brouillon.<br>Nous faisons beaucoup d\'efforts pour construire un outil correct et fiable pour vous. Néanmoins, il peut y avoir des défaillances dans la solution ou l\'approche. Cela peut notamment dépendre de la version de votre navigateur. Veuillez vérifier avant de l\'utiliser, par exemple dans un examen.","example":"Exemple","composition":"composition","negativeSummand":"Une addition avec une valeur négative est similaire à une soustraction.","negativeSubtrahend":"Une soustraction négative est similaire à une addition positive.","negativeMinuendSubtrahend":"Simplification pour le cas \\\\( - x - y \\rightarrow - (x + y) \\\\)","addWithZero":"Une addition avec 0 donne l\'autre somme","subWithZero":"Une soustraction avec 0 donne l\'autre valeur","mulWithZero":"Une multiplication avec 0 donne toujours 0","divWithZero":"Une division avec 0 au numérateur donne toujours 0.","zeroDivision":"Une division par 0 est illégale!","arithmeticFree":"Arithmétique libre","conversionFree":"Conversion libre","value":"Valeur","givenValues":"valeurs des nombres transmis","leftValue":"valeur gauche","rightValue":"valeur de droite","firstSummand":"1. sommande","secondSummand":"2. sommande","firstFactor":"1. facteur","secondFactor":"2. facteur","minuend":"minuend","subtrahend":"subtrahend","numerator":"numerator","denominator":"dénominateur","sign":"signe","exponent":"exposant","adjustExponents":"Les exposants des deux nombres doivent être équilibrés","addExponents":"Les exposants des deux nombres doivent être additionnés.","subtExponents":"Les exposants des deux nombres doivent être soustraits.","diffExponent":"Différence des exposants","smallerExponent":"Le plus petit exposant sera soustrait du plus grand.","resDiffExponent":"D\'où résulte cette différence","newExponent":"nouvel exposant","considerExponent":"considère l\'exposant","mantissa":"mantisse","mulMantissa":"La mantisse des deux nombres doit être multipliée","solutionIsNan":"La mantisse ne peut pas être calculée car l\'entrée conduit à NaN.","solutionIsInf":"La mantisse ne peut pas être calculée car l\'entrée mène à l\'infini.","solutionIsZero":"La mantisse ne peut pas être calculée car l\'entrée conduit à zéro.","addMantissa":"La mantisse des deux nombres doit être additionnée.","divMantissa":"La mantisse des deux nombres doit être divisée.","newMantissa":"Nouvelle mantisse","zeroMantissa":"les deux mantisses sont égales \\\\( \\\\rightarrow \\\\) la nouvelle mantisse est la mantisse 0","newMantissaIs":"La nouvelle mantisse est donc","equalMantissa":"Les deux mantisses sont égales \\\\( \\\\rightarrow \\\\) l\'exposant sera incrémenté la mantisse reste","equalMantissaDiv":"Les deux mantisses sont égales, aucune division binaire ne sera exécutée","adjustSmallerMantissa":"Ajuste la mantisse","shiftMantissa":"Décale la mantisse","mantissaFloat":"Mantisse à l\'intérieur du flottant","mantissa1float":"La position initial ne fait pas partie du flottant","subtTwosComplement":"La soustraction est similaire à l\'addition avec le complément à deux","mantissaTwosComplement":"Formation du complément à deux à partir de la mantisse","switchBits":"Inverser les bits","add1":"Ajouter 1","normalize":"Normaliser","shiftExpMant":"Le facteur de décalage de l\'exposant doit être appliqué à la mantisse","shift":"shift","considerRepresentation":"Tenir compte de la représentation","consider1comma":"La mantisse commence par un 1 dans la forme standard (et un 0 dans la représentation dénormalisée).","firstFormat":"format initial","secondFormat":"format cible","doConversion":"Convertir:","modus":"modus","to":"en","TenToPower":"La conversion du système décimal en un système arbitraire se fait en deux étapes. Avant la virgule, les chiffres sont convertis à l\'aide de l\'algorithme de division. Après la virgule, l\'algorithme de multiplication sera appliqué","PowerToTen":"Un système numérique arbitraire peut être converti en système décimal en résumant tous les chiffres potentialisés.","PowerToPower":"Nous convertissons un système numérique arbitraire en un autre en deux étapes via le système décimal. Dans un premier temps, le nombre original sera transféré dans le système décimal en résumant les chiffres potentialisés. Dans la deuxième étape, nous utilisons l\'algorithme de division et de multiplication pour créer le nombre résultant.","noValuesBeforeComma":"Il n\'y a pas de valeurs devant la virgule. Par conséquent, l\'algorithme de division peut être ignoré.","noValuesAfterComma":"Il n\'y a pas de valeur après la virgule. Par conséquent, l\'algorithme de multiplication peut être ignoré.","firstToTen":"1. somme des chiffres potentialisés","secondToPower":"2. conversion via l\'algorithme de division et de multiplication","shortcutBinToHex":"Lors de la conversion du binaire en hexadécimal, les valeurs peuvent être lues directement","shortcutHexToBin":"Lors de la conversion d\'hexadécimal en binaire, les valeurs peuvent être lues directement","divisionAlgorithm":"Algorithme de division","multiplicationAlgorithm":"Algorithme de multiplication","summation":"Sommation","factor":"Facteur","quotient":"Quotient","remainder":"reste","newBasis":"Base_{\'{nouvelle}\'}","calcStep":"étape\\\\ de\\\\ calcul","summands":"sommets","polyadicExercise1":"Convertissez la valeur:","polyadicExercise2":"à partir du format initial: ","polyadicExercise3":"au format cible:","exerciseArchive":"Archive d\'exercices","randomExercise":"Exercice aléatoire","doCalculation":"Calculer","colorCoding":"Code couleur","mathDistribution":"Distribution","easy":"simple","difficultyMiddle":"moyenne","difficultyHard":"difficile","sheet":"feuille","goal":"Objectif","difficultyUC":"Difficulté","bf_infotext_or_interact_with_kv":"Ou interagir directement avec le Diagramme KV","bf_infotext_kv_must_not_be_empty":"Le Diagramme KV doit contenir des 1 et des 0","bf_infotest_click_on_hidden_areas_to_make_visible":"Cliquez sur les zones cachées pour les révéler","bf_normal_forms":"Formes normales","bf_disjunctiveNormalForm":"Forme normale disjonctive","bf_conjunctiveNormalForm":"Forme normale conjonctive","bf_disjunctiveMinimalForm":"Forme minimale disjonctive","bf_conjunctiveMinimalForm":"Forme minimale conjonctive","bf_quineMCCluskeyClasses":"Classes de méthode de Quine-Mc Cluskey","bf_primeTerms":"Primeterms","bf_primeImplicants":"Primo-implicants","bf_primeImplicates":"Primo-implicats","bf_primeCoverTable":"Prime implicant chart / \'Cover Table\'","bf_petrickExpression":"Expression de Petrick","bf_minimalForms":"Formes minimales","bf_tableWithCyclicRest":"Table avec repos cyclique","bf_einstelle":"Un","bf_nullstelle":"Zéro","bf_einstellen":"Ones","bf_nullstellen":"Zéros","bf_goal_determine_DNF":"déterminer la DNF","bf_goal_determine_KNF":"déterminer la KNF","bf_goal_determine_prime_implicants":"déterminer les primo-implicants","bf_goal_determine_prime_implicates":"déterminer les primo-implicats","bf_covertable_step_description_initial":"<h4>Étape initiale:</h4>Saisissez tous les termes de base dans les colonnes et tous les termes premiers (PI) dans les lignes du tableau. Si un terme premier couvre un {ifMinTermsEinstelleElseNullstelle}, marquez cette cellule d\'un X. Le coût c d\'un terme premier est le nombre de ses littéraux. Plus il est élevé, plus l\'implémentation en matériel est complexe (c\'est-à-dire coûteuse).<br>Tip:<br>Un implicaNT premier couvre un \'ONE\' exactement si tous les littéraux du primeterm apparaissent également de la même manière dans le terme de base.","bf_covertable_step_description_core_found":"<h4>Core found:</h4>Le seul primeterm qui couvre la colonne {columnName} est le terme {rowName}. Par conséquent, ce primeterme doit absolument apparaître dans notre fonction résultante! Marquez la ligne comme une \'core\' (Kern) et rayez la colonne.","bf_covertable_step_description_cross_column_bc_covered":"<h4>Colonne déjà couverte:</h4>La colonne {columnName} est déjà couverte par le primeterm {rowName}. Supprimez la colonne.","bf_covertable_step_description_cross_row_bc_covered":"<h4>Row already covered:</h4>Tous les X de la ligne {rowName} sont déjà couverts. Rayez la ligne.","bf_covertable_step_description_row_domination":"<h4>Row dominance / Reihendominanz:</h4>La ligne {dominatorName} domine la ligne {dominatedName}; c\'est-à-dire que la rangée {dominatorName} a des marqueurs partout où la rangée {dominatedName} en a aussi (et peut-être plus!). => croise la ligne dominée {dominatedName}. <br>Notez que la dominance de rangée n\'est applicable, que parce que la rangée {dominatorName} coûte moins que, ou la même que {dominatedName}; ou parce qu\'il n\'existe aucune autre rangée qui couvre les marqueurs supplémentaires de {dominatorName} et dont le coût est inférieur à {dominatorName} - {dominatedName}.","bf_covertable_step_description_column_domination":"<h4>Column dominance / Spaltendominanz:</h4> La colonne {dominatorName} domine la colonne {dominatedName}; c\'est-à-dire que la colonne {dominatorName} a des marqueurs partout où la colonne {dominatedName} en a aussi (et peut-être plus!). => Traverser la colonne dominante {dominatorName} <br>Contrairement à la dominance de ligne, la dominance de colonne ne nécessite pas du tout de considérer les coûts.","bf_covertable_step_description_cyclic_rest":"<h4>Repos cyclique:</h4> Aucune règle de l\'algorithme des tables premières n\'est applicable. On parle alors d\'un \'repos cyclique\' (ger : \'Zyklischer Rest\'). <br>En établissant l\'expression de Petrick (ger: Petrick Ausdruck) pour la table de repos, on est toujours capable de déterminer une forme minimale de la fonction originale.","bf_infoblob_random_exercise_selection":"La difficulté indique le nombre de termes individuels d\'un certain type (par exemple, les termes mineurs, les primo-implicants) que la fonction booléenne doit produire.","bf_infoblob_petrick_statement":"L\'algorithme se compose de deux phases:<ol><li>Faire en sorte que les termes qui s\'absorbent les uns les autres soient facilement visibles grâce à un tri (affiché uniquement s\'il a un effet quelconque)</li><li>Multiplier les deux premiers termes entre eux jusqu\'à ce que la somme typique subsiste.</li></ol>","bf_distributionUC":"Distribution","bf_idempotenceUC":"Idempotence","bf_absorptionUC":"Absorption","bf_sortingUC":"Triage","contactPersonHeader":"Contact","contact":"Contact","copyright":"Chaire d\'informatique 12, FAU. Tous droits réservés.","herausgeber":"Éditeur","impressum":"Mentions légales","representedByHeader":"Représenté par","representedBy":"La chaire d\'informatique 12 est une institution de droit public au sein de la Friedrich-Alexander-Universität Erlangen-Nürnberg (FAU). Conformément aux articles 20 et 21 de la BayHSchG, la FAU, en tant qu\'établissement public et collectivité autonome de droit public, est représentée à l\'extérieur par son président.","haftungsauschlussHeader":"Clause de non-responsabilité","mantissaComplement":"La mantisse est négative. Il faut donc former le complément et placer le bit de signe.","mantissaNormalize":"Pour que la mantisse commence par un 1, nous devons normaliser la mantisse en appliquant le décalage de {shift}. Nous devons également appliquer ce décalage à l\'exposant, ce qui donne le nouvel exposant {exposant}.","mantissaNormalizeDenorm":"Le résultat ne peut pas être affiché en représentation normalisée avec le décalage {shift}, c\'est pourquoi nous utilisons la représentation dénormalisée avec l\'exposant {exponent}","newExponentDivision":"Le nouvel exposant est obtenu par \\\\( E_{\'{neu}\'} = E_1 - E_2 + BIAS = {E1} - {E2} + {Bias} = {Result} \\\\)","newExponentMultiplication":"Le nouvel exposant est obtenu par \\\\( E_{\'{neu}\'} = E_1 + E_2 - BIAS = {E1} + {E2} - {Bias} = {Result}\\\\, ({ExpBits})\\\\)","haftungsauschlussBody":"Les contenus d\'autres offres web relèvent de la responsabilité des institutions concernées. Nous avons élaboré et vérifié en toute conscience toutes les informations mises à disposition sur ce site Internet. Nous ne pouvons toutefois pas garantir l\'actualité, l\'exactitude, l\'exhaustivité et la disponibilité des informations mises à disposition à tout moment. Aucune relation contractuelle n\'est établie avec les utilisateurs de l\'offre Internet. Nous ne sommes pas responsables des dommages causés par l\'utilisation de cette offre Internet. Cette exclusion de responsabilité ne s\'applique pas dans la mesure où les dispositions de l\'article 839 du code civil (responsabilité en cas de manquement à une obligation officielle) sont pertinentes. Nous déclinons toute responsabilité pour les éventuels dommages causés par des logiciels malveillants lors de l\'appel ou du téléchargement de données ou de l\'installation ou de l\'utilisation de logiciels. En tant que prestataire de services, nous sommes responsables, conformément au § 7 alinéa 1 de la loi allemande sur les télémédias (TMG), de nos propres contenus sur ces pages selon les lois générales. Conformément aux § 8 à 10 de la TMG, nous ne sommes toutefois pas tenus, en tant que prestataire de services, de surveiller les informations externes transmises ou enregistrées ou de rechercher des circonstances indiquant une activité illégale. Les obligations de supprimer ou de bloquer l\'utilisation d\'informations conformément aux lois générales restent inchangées. Une responsabilité à cet égard n\'est toutefois possible qu\'à partir du moment où une violation concrète de la loi est connue. Dès la prise de connaissance d\'une telle violation de la loi, nous supprimerons immédiatement ces contenus. L\'exploitant se réserve expressément le droit de modifier, de compléter, de supprimer ou de suspendre temporairement ou définitivement la publication de certaines pages web, de certains services web ou de l\'ensemble de l\'offre sans préavis particulier.","startTraining":"Allons-y","sequentialCircuit":"Exemple de circuit séquentiel comprenant deux D-flipflops et des multiplexeurs.","enter_cmos":"Veuillez entrer votre formule CMOS.","conversionExercise":"Exercices de conversion","homePageText":"L\'objectif de GTI-Online est d\'approfondir la connaissance des sujets sélectionnés appris dans le cours et l\'exercice correspondant. Sélectionnez dans le menu un sujet et commencez à vous entraîner.","cmos_infoblob_description":"Le CMOS est une composition d\'un réseau complémentaire NMOS (réseau pull-down, puisque connecté à la masse) et PMOS (réseau pull-up, puisque connecté à la tension d\'alimentation).\\n Par conséquent, moins d\'énergie est consommée dans l\'état de commutation fixe, puisque PDN et PUN sont complémentaires et ne conduisent donc simultanément que pendant un court moment lors de la commutation. Cependant, une plus grande surface est nécessaire sur la puce.","bf_bf_primeImplicants_explanation":"Les primitifs sont des primitifs qui ne couvrent que des uns (avec des indifférents).","bf_conjunctiveMinimalForm_explanation":"Conjonction de littéraux liés par disjonction, qui ne peut être simplifiée davantage (sans violer cette forme) (KNF simplifiée).","bf_primeTerms_explanation":"Termes avec un nombre minimum de littéraux couvrant uniquement des uns ou des zéros.","bf_primeImplicates_explanation":"Les primo-implicates sont des primitives qui ne couvrent que des zéros (avec des indifférences).","bf_infoblob_functionMin":"Sur cette page, vous trouverez différentes procédures pour minimiser les expressions booléennes.","bf_disjunctiveNormalForm_explanation":"La forme normale disjonctive est une disjonction (combinaison des termes utilisant ou opérateurs) de tous les mintermes (1) d\'une fonction. Chaque minterme correspond exactement à un 1 dans la fonction, tous les littéraux doivent apparaître niés ou non niés.","bf_infoblob_quineMCCluskeyClasses_01":"Normalement, nous écrivons les termes minimum et maximum dans les différentes classes. Il est également possible de travailler avec des 0 (pour les littéraux niés) et des 1 (pour les littéraux non niés), la position de ces derniers déterminant de quel littéral il s\'agit.","bf_conjunctiveNormalForm_explanation":"La forme normale conjonctive est une conjonction (combinaison des termes utilisant et opérateurs) de tous les maxtermes (0s) d\'une fonction. Les 0 ne sont pas sélectionnés dans les maxterms (comme les 1 dans les minterms), mais exclus. Chaque maxterme correspond exactement à un 0 dans la fonction, tous les littéraux doivent apparaître niés ou non niés.","bf_quineMCCluskeyClasses_explanation":"L\'algorithme de Quine/McCluskey est un algorithme de minimisation qui permet de déterminer les primetermes d\'une fonction.","bf_infoblob_quineMCCluskeyClasses_colorCoding":"Tous les termes utilisés dans la réduction sont normalement barrés dans l\'algorithme de Quine/McCluskey. Si le codage couleur est actif, ils sont affichés en gris clair à la place.","bf_disjunctiveMinimalForm_explanation":"Disjonction de littéraux liés par une conjonction, qui ne peut être simplifiée davantage (sans violer cette forme) (DNF simplifiée).","octal":"Nombre octal","quaternary":"Nombre quaternaire","representation":"Représentation dans le format initial","number":"nombre","novenary":"Nombre nonal","ternary":"Nombre ternaire","senary":"Nombre hexaire","quinary":"Nombre de quintal","septenary":"Système heptal","hex":"Hexadécimal","cmos_infoblob_input_description":"Note : On peut utiliser \'+\' pour les portes OU, \'*\' pour les portes ET et \'~\' pour la négation. Les variables peuvent avoir des noms arbitraires (Attention : \'ab\' est considéré comme une seule variable, et non comme \'a\' mutiplié par \'b\').","hexadecimal":"Nombre hexadécimal","systemInBase":"Système à la base","basis":"Base","minterms":"Termes minimaux","maxterms":"Termes maximaux","impressumText":"Vous trouverez les mentions légales sous :","and":" et","weThank":"Nous remercions les personnes suivantes pour leur aide à la création de ce site:","Danksagung":"Remerciements","thankProfessorTeich":"Le matériel de cette page est basé sur le cours GTI du professeur Dr. Jürgen Teich de l\'université Friedrich-Alexander-Universität (FAU). Nous le remercions pour son expertise et son parrainage.","wintersemester":"Semestre d\'hiver","sommersemester":"Semestre d\'été","downloadSvg":"Exporter en SVG","downloadPng":"Exporter en PNG","formula":"Formule","divByZero":"La division par 0 donne NaN.","falseFormat":"Mauvais format"}'),hu=JSON.parse('{"complementExample":"Complemento","shiftZero":"Cero después del desplazamiento","doubleNegative":"Negativo","denormalized":"Denormalización","fpExerciseIntro":"Practique aritmética entre números de punto flotante en formato IEEE-754 utilizando ejercicios generados","fpFormatSelectionSimple":"Para seleccionar un formato personalizado, especifica la distribución de bits entre los exponentes y la mantisa","fpFormatSelection":"Para seleccionar su propio formato, selecciona primero el número de bits del número en coma flotante y luego especifique la distribución de bits entre los exponentes y la mantisa","fpArithIntro":"Practique la aritmética entre números de punto flotante en el formato según IEEE-754 o un formato autodefinido basado en él","fpConvIntro":"Practique la conversión entre el sistema decimal y el formato de números de punto flotante según IEEE-754 o un formato autodefinido basado en él, utilizando ejercicios generados","polyConvIntro":"Practique la conversión entre sistemas poliádicos que puedes elegir libremente.","polyConvGenIntro":"Practique la conversión entre sistemas poliádicos resolviendo los ejercicios generados.","numVarInput":"Número de variables","confirm":"Confirmar","input":"Entrada","varNaming":"Nombramiento variable","kvDiagram":"Mapa de Karnaugh","numeralSystem":"Sistema de numeración","polyadic":"Poliádico","floatingPoint":"Coma Flotante","functionMin":"Minimización","exercises":"Ejercicios","generateEx":"Generar Ejercicio","generate":"Generar","addition":"Adición","subtraction":"Sustracción","multiplication":"Multiplicación","division":"División","solution":"Solución","ownSolution":"Solución propia","signBit":"Bit de signo","correctSolution":"Solución","exponentBits":"Exponente","fractionBits":"Fracción","attRound":"¡No olvide redondear!","attSolve":"¡Por favor, intente resolver el ejercicio de antemano!","step":"Paso","freeCalculation":"Cálculo libre","operationSelect":"Configurar la computación","firstFloatingPoint":"Primer número de punto flotante","secondFloatingPoint":"Segundo número de punto flotante","operand":"Operativo","decimal":"Decimal","binary":"Binario","inputNumber":"Introduce el número","fpformat":"Formato de punto flotante","check":"Comprobar","values":"Valores","arithmetic":"Aritmética","conversion":"Conversión","conversionExercise1":"Convertir: ","conversionExercise2":"en un número de punto flotante IEEE con una longitud de exponente de ","steps":"pasos","repeatMinuend":"repite\\\\ minuendo","doDivision":"Realice una división","doMultiplication":"Realice una multiplicación","getDescription":"Imprimir","approach":"Procedimiento","gti":"Fundamentos de la informática técnica","disclaimer":"Descargo de responsabilidad:<br> Este es un enfoque de solución generado automáticamente por el sitio web de GTI-Online. Todos los resultados son completamente no oficiales y están en estado de borrador. Estamos haciendo muchos esfuerzos para construir una herramienta correcta y fiable para usted. Independientemente de ello, puede haber fallos en la solución o en el planteamiento. Esto puede depender especialmente de la versión de su navegador.","example":"Ejemplo","composition":"Composición","negativeSummand":"Una suma con valor negativo es similar a una resta","negativeSubtrahend":"Un sustraendo negativo es similar a un sumando positivo","negativeMinuendSubtrahend":"Simplificación para el caso \\\\( - x - y \\\\rightarrow - (x + y) \\\\)","addWithZero":"Una suma con 0 da como resultado el otro sumando","subWithZero":"Una resta con 0 da como resultado el otro valor","mulWithZero":"Una multiplicación con 0 da como resultado siempre 0","divWithZero":"Una división con 0 en el numerador da como resultado siempre 0","zeroDivision":"¡Una división por 0 es ilegal!","arithmeticFree":"Aritmética libre","conversionFree":"Conversión Libre","value":"Valor","givenValues":"Valores de los números transmitidos","leftValue":"El valor de la izquierda","rightValue":"El valor de la derecha","firstSummand":"1. Sumario","secondSummand":"2. Sumario","firstFactor":"1. Factor","secondFactor":"2. Factor","minuend":"Minucioso","subtrahend":"Restando","numerator":"Numerador","denominator":"Denominador","sign":"Firma","exponent":"Exponente","adjustExponents":"Los exponentes de ambos números deben estar equilibrados.","addExponents":"Hay que sumar los exponentes de ambos números.","subtExponents":"Hay que restar los exponentes de ambos números.","diffExponent":"Diferencia de los exponentes","smallerExponent":"El exponente menor se restará del mayor.","resDiffExponent":"De ahí que esta diferencia resulte","newExponent":"Nuevo exponente","considerExponent":"Considere el exponente","mantissa":"Mantisa","mulMantissa":"Hay que multiplicar la mantisa de ambos números.","solutionIsNan":"La mantisa no se puede calcular porque la entrada lleva a NaN.","solutionIsInf":"La mantisa no se puede calcular porque la entrada lleva al infinito","solutionIsZero":"La mantisa no se puede calcular porque la entrada lleva a cero.","addMantissa":"Hay que sumar la mantisa de ambos números.","divMantissa":"Hay que dividir la mantisa de ambos números","newMantissa":"Nueva mantisa","zeroMantissa":"Ambas mantisas son iguales \\\\( \\\\rightarrow \\\\) la nueva mantisa es la mantisa 0","newMantissaIs":"Por lo tanto la nueva mantisa es","equalMantissa":"Ambas mantisas son iguales \\\\( \\\\rightarrow \\\\) el exponente se incrementará la mantisa permanece","equalMantissaDiv":"Ambas mantisas son iguales, no se ejecutará la división binaria","adjustSmallerMantissa":"Ajuste la mantisa","shiftMantissa":"Desplace la mantisa","mantissaFloat":"Mantisa dentro del float","mantissa1float":"La cifra inicial no forma parte del float","subtTwosComplement":"La resta es similar a la suma con el complemento a dos","mantissaTwosComplement":"Formación del complemento a dos a partir de la mantisa","switchBits":"Invierta los bits","add1":"Añada  1","normalize":"Normalice","shiftExpMant":"El factor de desplazamiento del exponente debe aplicarse a la mantisa.","shift":"Desplazamiento","considerRepresentation":"Considere la representación","consider1comma":"La mantisa comienza con un 1 en la forma estándar (y un 0 en la representación desnormalizada).","ternary":"Número ternario","quaternary":"Número cuaternario","quinary":"Número quintal","senary":"Número hexal","septenary":"Número heptal","octal":"Número octal","novenary":"Número nonal","hexadecimal":"Número hexadecimal","hex":"Hexadecimal","number":"Número","modus":"Modus","summation":"Summation","factor":"Factor","quotient":"Cociente","polyadicExercise2":"del formato inicial:","polyadicExercise3":"al formato de destino:","cmos_infoblob_input_description":"Nota: Para OR se puede usar \' \', para AND \'*\' y para negación \'~\'. \\nLas variables pueden tener nombres arbitrarios (Atención: \'ab\' se considera como una variable, no como \'a\' multiplicada por \'b\').","contactPersonHeader":"Contacto","herausgeber":"Editorial","impressum":"Pie de imprenta","coypright":"Cátedra de Informática 12, FAU. Todos los derechos reservados.","representedByHeader":"Representado por","representedBy":"La Cátedra de Informática 12 es una institución de derecho público de la Friedrich-Alexander-Universität Erlangen-Nürnberg (FAU). De acuerdo con los artículos 20 y 21 de la BayHSchG, la FAU, como institución estatal y organismo autónomo de derecho público, está representada externamente por el Presidente.","haftungsauschlussHeader":"Descargo de responsabilidad","mantissaComplement":"La mantisa es negativa. Así que tenemos que formar el complemento y poner el bit de signo.","mantissaNormalize":"Para que la mantisa comience con un 1 a la izquierda, necesitamos normalizar la mantisa aplicando el desplazamiento de {shift}. También tenemos que aplicar este desplazamiento al exponente, lo que da como resultado el nuevo exponente {exponente}.","mantissaNormalizeDenorm":"El resultado no se puede representar en la representación normalizada con el desplazamiento {shift}, así que usamos la representación desnormalizada con el exponente {exponent}","newExponentDivision":"El nuevo exponente resulta como \\\\( E_{\'{neu}\'} = E_1 - E_2 + BIAS = {E1} - {E2} + {Bias} = {Result} \\\\)","newExponentMultiplication":"El nuevo exponente resulta como \\\\( E_{\'{neu}\'} = E_1 + E_2 - BIAS = {E1} + {E2} - {Bias} = {Result}\\\\, ({ExpBits})\\\\)","haftungsauschlussBody":"Las instituciones respectivas son responsables del contenido de otros sitios web. Toda la información proporcionada en este sitio web ha sido recopilada y comprobada según nuestro leal saber y entender. Sin embargo, no podemos garantizar que la información proporcionada esté actualizada, sea correcta, completa o esté disponible en todo momento. No se establece una relación contractual con los usuarios de la oferta de Internet. No nos hacemos responsables de los daños causados por el uso de este sitio web. Esta exclusión de responsabilidad no se aplica si son pertinentes las disposiciones del artículo 839 del Código Civil alemán (responsabilidad por incumplimiento del deber oficial). No se acepta ninguna responsabilidad por los daños causados por programas maliciosos o por la instalación o el uso de programas informáticos al llamar o descargar datos. Como proveedor de servicios, somos responsables de nuestros propios contenidos en estas páginas de acuerdo con la legislación general según el artículo 7 (1) de la Ley de Telemedia alemana (TMG). Sin embargo, de acuerdo con los artículos 8 a 10 de la TMG, no estamos obligados, como proveedores de servicios, a controlar la información de terceros transmitida o almacenada, ni a investigar las circunstancias que indiquen una actividad ilegal. Las obligaciones de eliminar o bloquear el uso de la información de acuerdo con las leyes generales no se ven afectadas por esto. Sin embargo, la responsabilidad a este respecto sólo es posible a partir del momento en que se conoce una infracción concreta de la ley. Si tenemos conocimiento de tales infracciones, eliminaremos el contenido correspondiente inmediatamente. El operador se reserva expresamente el derecho a modificar, complementar o eliminar páginas web individuales, servicios web o la oferta completa sin previo aviso o a suspender la publicación de forma temporal o permanente.","bf_absorptionUC":"Absorción","bf_einstelle":"Un","bf_einstellen":"Ones","contact":"Contacto","bf_distributionUC":"Distribución","bf_goal_determine_DNF":"Determinar el DNF","bf_goal_determine_KNF":"Determinar el KNF","bf_goal_determine_prime_implicants":"Determinar los implicantes primos","bf_idempotenceUC":"Idempotencia","bf_nullstelle":"Cero","bf_nullstellen":"Ceros","bf_petrickExpression":"Método de Petrick","bf_minimalForms":"Formas mínimas","bf_tableWithCyclicRest":"Mesa con reposo cíclico","colorCoding":"Código de colores","difficultyHard":"Difícil","difficultyUC":"Dificultad","easy":"Fácil","difficultyMiddle":"Medio","doCalculation":"Calcule","goal":"Destino","load":"Cargar","mathDistribution":"Distribución","sheet":"Hoja","startTraining":"Vamos","newMantissaSignBit":"Debido al complemento, calculamos con un bit de signo:","disclaimerFooter":"No se garantiza la exactitud del material proporcionado en este sitio web.","sequentialCircuit":"Ejemplo de un circuito secuencial compuesto por dos D-flipflops y multiplexores.","polyadicMultiplicationDescription":"Los decimales resultan de los dígitos del resto leyéndolos de arriba a abajo.","polyadicDivisionDescription":"Los dígitos que preceden al punto decimal se derivan de los dígitos del resto leyéndolos de abajo a arriba.","enter_cmos":"Por favor, introduzca su fórmula CMOS.","conversionExercise":"Ejercicios de conversión","exerciseArchive":"Archivo de ejercicios","homePageText":"El objetivo de GTI-Online es profundizar en los conocimientos de los temas seleccionados aprendidos en la clase y en el ejercicio correspondiente. Seleccione en el menú un tema y empiece a practicar.","fpExerciseText":"Sean los números de punto flotante \\\\( fp_1 \\\\) y \\\\( fp_2 \\\\) dados en formato de punto flotante de 16 bits. Calcule la {op1} \\\\( fp_1 {op2} fp_2 \\\\) sin salir de la representación binaria y déselo de nuevo como un número de punto flotante:","bf_sortingUC":"Clasificación ","polyFreeIntro":"Practique la aritmética poliádica con sus propios valores numéricos en el sistema que desee.","randomExercise":"Ejercicio aleatorio","cmos_infoblob_description":"CMOS es una composición de una red complementaria NMOS (red pull-down, ya que está conectada a tierra) y una red PMOS (red pull-up, ya que está conectada a la tensión de alimentación).\\n Como resultado, se consume menos energía en el estado de conmutación fijo, ya que PDN y PUN son complementarias y, por tanto, sólo conducen simultáneamente durante un breve periodo de tiempo durante la conmutación. Sin embargo, se requiere más área en el chip.","bf_bf_primeImplicants_explanation":"Los implicantes primos son términos primos que cubren sólo unos (con don\'t cares).","bf_conjunctiveMinimalForm":"Forma mínima conjuntiva","bf_conjunctiveMinimalForm_explanation":"Conjunción de literales unidos por disyunción, que no puede simplificarse más (sin violar esta forma) (KNF simplificado).","bf_conjunctiveNormalForm":"Forma normal conjuntiva","bf_normal_forms":"Formas normales","bf_primeTerms":"Términos primos","bf_primeTerms_explanation":"Términos con un número mínimo de literales que cubren sólo unos o ceros.","bf_primeImplicates_explanation":"Los implicados primos son términos primos que cubren sólo ceros (con don\'t cares).","bf_primeImplicants":"Implicantes primos","bf_primeCoverTable":"Tabla de Cobertura","bf_infotext_kv_must_not_be_empty":"El diagrama KV debe contener unos y ceros","bf_infotext_or_interact_with_kv":"O interactúe directamente con el Diagrama KV","bf_quineMCCluskeyClasses":"Clases de Quine MC Cluskey","bf_infoblob_functionMin":"En esta página puede encontrar diferentes procedimientos para minimizar las expresiones booleanas.","bf_goal_determine_prime_implicates":"Determine los implicados primos","bf_disjunctiveNormalForm_explanation":"La forma normal disyuntiva es una disyunción (combinación de los términos utilizando operadores o) de todos los minitérminos (1s) de una función. Cada minitérmino corresponde exactamente a un 1 en la función, todos las literales deben ocurrir negados o no negados.","bf_infoblob_quineMCCluskeyClasses_01":"Normalmente, escribimos los mínimos o máximos en las clases individuales. Alternativamente, también podemos trabajar con 0s (para las literales negados) y 1s (para las literales no negados), por lo que la posición de éstos determina de qué literal se trata.","bf_primeImplicates":"Implicados primos","bf_infotest_click_on_hidden_areas_to_make_visible":"Haz clic en las zonas ocultas para revelarlas","bf_infoblob_random_exercise_selection":"La dificultad indica cuántos términos individuales de algún tipo (por ejemplo, minitérminos, implicantes primos) debe producir la función booleana.","bf_infoblob_petrick_statement":"El algoritmo consta de dos fases:<ol><li>Haga que los términos que se absorben entre sí sean fácilmente visibles mediante la ordenación (sólo se muestra si tiene algún efecto).</li><li>Multiplique los dos primeros términos entre sí hasta que quede la suma típica.</li></ol>","bf_disjunctiveNormalForm":"Forma normal disyuntiva","bf_disjunctiveMinimalForm":"Forma mínima disyuntiva","bf_conjunctiveNormalForm_explanation":"La forma normal conjuntiva es una conjunción (combinación de los términos usando AND operadores) de todos los maxitérminos (0s) de una función. Los 0s no se seleccionan en los maxitérminos (como los 1s en los minitérminos), sino que se excluyen. Cada maxitérmino corresponde exactamente a un 0 en la función, todos las literales deben ocurrir negados o no negados.","bf_covertable_step_description_core_found":"<h4>Núcleo encontrado:</h4>El único término primo que cubre la columna {columnName} es el término {rowName}. Por lo tanto, ¡este término primo debe aparecer definitivamente en nuestra función resultante! Marque la fila como \\"núcleo\\" (Kern) y tache la columna.","bf_covertable_step_description_cross_row_bc_covered":"<h4>Fila ya cubierta:</h4>Todas las X de la fila {rowName} ya están cubiertas. Tache la fila.","bf_covertable_step_description_initial":"<h4>Paso inicial:</h4>T Introduce todos los términos base en las columnas y todos los términos primos (PI) en las filas de la tabla. Si un término primo cubre un {ifMinTermsEinstelleElseNullstelle}, marque esa celda con una X. El coste c de un primo es el número de sus literales. Cuanto mayor sea, más compleja (es decir, costosa) será la implementación en hardware. <br>Consejo:<br> Un implicante primo cubre un \'UNO\' exactamente si todos las literales del término primo también ocurren de la misma manera en el término base.","bf_quineMCCluskeyClasses_explanation":"El algoritmo de Quine/McCluskey es un algoritmo de minimización con el que se pueden determinar los términos primos de una función.","bf_infoblob_quineMCCluskeyClasses_colorCoding":"Todos los términos utilizados en la reducción están normalmente tachados en el algoritmo Quine/McCluskey. Si la codificación por colores está activa, se muestran en gris claro en su lugar.","bf_covertable_step_description_cross_column_bc_covered":"<h4>Columna ya cubierta:</h4> La columna {columnName} ya está siendo cubierta por término primo {rowName}. Tacha la columna","bf_disjunctiveMinimalForm_explanation":"Disyunción de literales unidos por la conjunción, que no puede simplificarse más (sin violar esta forma) (DNF simplificado).","bf_covertable_step_description_column_domination":"<h4>Dominio de columna:</h4>La columna {dominatorName} domina la columna {dominatedName}; es decir, la columna {dominatorName} tiene marcadores allí donde la columna {dominatedName} también los tiene (¡y posiblemente más!). => Cruzar la columna dominante {dominatorName}<br>A diferencia de lo que ocurre con el dominio de filas, el dominio de columnas no requiere que se consideren los costes en absoluto.","bf_covertable_step_description_row_domination":"<h4>Dominio de fila:</h4>La fila {dominatorName} domina la fila {dominatedName}; es decir, la fila {dominatorName} tiene marcadores donde la fila {dominatedName} también los tiene (¡y posiblemente más!). => cruza la fila dominada {dominatedName}. <br>Tenga en cuenta que la dominación de la fila sólo es aplicable, porque la fila {dominatorName} cuesta menos que, o lo mismo que {dominatedName}; o porque no hay ninguna otra fila que cubra los marcadores adicionales de {dominatorName} y cuesta menos que {dominatorName} - {dominatedName}.","bf_covertable_step_description_cyclic_rest":"<h4>Resto cíclico:</h4> Ninguna regla del algoritmo de la tabla de primos es aplicable. Esto se denomina \\"resto cíclico\\" (ger: \\"Zyklischer Rest\\"). Al establecer la expresión de Petrick (ger: Petrick Ausdruck) para la tabla de reposo, uno todavía es capaz de determinar una forma mínima de la función original.","PowerToPower":"Convertimos un sistema numérico arbitrario en otro en dos pasos a través del sistema decimal. Al principio, el número original se transfiere al sistema decimal resumiendo los dígitos potenciados. En el segundo paso, utilizamos el algoritmo de división y multiplicación para crear el número resultante.","PowerToTen":"Un sistema numérico arbitrario puede convertirse al sistema decimal resumiendo todos los dígitos potenciados.","calcStep":"Paso\\\\ de\\\\ cálculo","divisionAlgorithm":"Algoritmo de división","newBasis":"Base_{\'{nueva}\'}","noValuesAfterComma":"No hay valores después de la coma. Por lo tanto, se puede omitir el algoritmo de multiplicación.","polyadicExercise1":"Convierta el valor de","representation":"Representación en formato original","secondToPower":"2. Conversión mediante el algoritmo de división y multiplicación","shortcutHexToBin":"En la conversión de hexadecimal a binario, los valores se pueden leer directamente.","summands":"Sumandos","multiplicationAlgorithm":"Algoritmo de multiplicación","secondFormat":"Formato del objetivo","shortcutBinToHex":"En la conversión de binario a hexadecimal, los valores se pueden leer directamente.","firstToTen":"1. Suma de los dígitos potenciados","firstFormat":"Formato inicial","doConversion":"Convierta:","to":"a","TenToPower":"La conversión del sistema decimal a uno arbitrario se realiza en dos pasos. Antes de la coma, los dígitos se convierten con el uso del algoritmo de la división. Después de la coma, se aplicará el algoritmo de multiplicación.","remainder":"Resto","noValuesBeforeComma":"No hay valores delante de la coma. Por lo tanto, se puede omitir el algoritmo de división.","systemInBase":"Sistema de base","basis":"Base","minterms":"Minitérminos","maxterms":"Maxitérminos","impressumText":"Puede encontrar el pie de imprenta en:","and":" y","weThank":"Nos gustaría agradecer a las siguientes personas su ayuda en la creación de este sitio web:","Danksagung":"Agradecimiento","thankProfessorTeich":"Los materiales de esta página se basan en la lección de la GTI impartida por el profesor Dr.-Ing. Jürgen Teich de la Friedrich-Alexander-Universität (FAU). Le agradecemos su experiencia y patrocinio.","wintersemester":"Semestre de invierno","sommersemester":"Semestre de verano","downloadSvg":"Exportar como SVG","downloadPng":"Exportar como PNG","formula":"Fórmula","divByZero":"La división por 0 da NaN","falseFormat":"Formato incorrecto!"}'),du=JSON.parse('{"complementExample":"补充","shiftZero":"移位后为零","doubleNegative":"负数","denormalized":"去正规化","fpExerciseIntro":"使用生成的练习在IEEE-754格式的浮点数之间练习算术","fpFormatSelectionSimple":"要选择一个自定义格式，指定指数和尾数之间的比特分布","fpFormatSelection":"要选择一个自定义格式，首先选择浮点数的位数，然后指定指数和尾数之间的位数分布","fpArithIntro":"按照IEEE-754的格式或基于它的自定格式练习浮点数之间的算术,","fpConvIntro":"根据IEEE-754或基于它的自定格式，使用生成的练习题，练习十进制系统和浮点数格式之间的转换","polyConvIntro":"练习你可以自由选择的位置数字系统之间的转换,","polyConvGenIntro":"通过解决生成的练习题来练习位置数字系统之间的转换,","polyadicMultiplicationDescription":"小数点后的数字是通过从上到下阅读余数的数字得到的,","polyadicDivisionDescription":"小数点之前的数字通过从下到上读取余数的数字得出,","enter_cmos":"请输入你的CMOS公式,","sequentialCircuit":"由两个D-flip-flops和多路复用器组成的顺序电路的例子,","homePageText":"GTI-Online的目标是加深在讲座和相应练习中所学的选定主题的知识,在菜单中选择一个主题并开始练习,","startTraining":"我们走吧","numVarInput":"变量的数量","fpExerciseText":"让 \\\\( fp_1 \\\\) 和 \\\\( fp_2 \\\\) 作为16位浮点格式的浮点数,计算{op1}的 \\\\( fp_1 {op2} fp_2 \\\\) 而不离开二进制表示，并再次指定为浮点数：","confirm":"确认","varNaming":"变量命名","kvDiagram":"Karnaugh Map","numeralSystem":"数字系统","polyadic":"位置性数字系统","floatingPoint":"浮动点","functionMin":"最小化","exercises":"练习","generateEx":"生成练习","generate":"生成","polyFreeIntro":"用你自己的数值在你想要的系统中练习位置数字算术","addition":"加法","subtraction":"减法","multiplication":"乘法","division":"除法","solution":"解决方案","ownSolution":"自己的解决方案","signBit":"签名位","load":"加载","correctSolution":"解决方案","exponentBits":"指数","fractionBits":"分数","attRound":"不要忘记四舍五入！","attSolve":"请事先尝试解决这个练习！","step":"步骤","freeCalculation":"免费计算","operationSelect":"配置计算","firstFloatingPoint":"第一个浮点数字","secondFloatingPoint":"第二个浮点数字","operand":"操作数","decimal":"十进制","binary":"二进制","inputNumber":"输入数","fpformat":"浮点格式","check":"检查","values":"数值","arithmetic":"算术","conversion":"转换","conversionExercise":"转换的练习","conversionExercise1":"转换,","conversionExercise2":"转换成一个IEEE浮点数，指数长度为","steps":"步骤","repeatMinuend":"重复\\\\ 闽南语","doDivision":"执行除法","doMultiplication":"执行乘法","getDescription":"打印","approach":"办法","gti":"计算机工程基础","disclaimer":"免责声明:<br>这是一个由网站自动生成的解决方案方法。 每个输出都是完全非官方的，处于草稿状态。我们正在努力为您建立一个正确和可靠的工具。 不管怎么说，在解决方案或方法上可能会有失误,这尤其取决于你的浏览器版本,在考试中使用它之前，请先审查一下,","example":"例子","composition":"组成","negativeSummand":"带负值的加法类似于减法","negativeSubtrahend":"负数的下弦与正数的上弦相似,","negativeMinuendSubtrahend":"简化的情况是 \\\\(- x - y \\\\rightarrow - (x + y) \\\\)","addWithZero":"用0做加法的结果是另一个和值","subWithZero":"用0做减法，结果是另一个值","mulWithZero":"带0的乘法的结果总是0","zeroDivision":"除以0是非法的！","arithmeticFree":"自由算术","conversionFree":"免费转换","value":"价值","givenValues":"传送数字的值","leftValue":"左边的值","rightValue":"右边的值","firstSummand":"1. summand","secondSummand":"2. summand","firstFactor":"1.因素","secondFactor":"2.因素","minuend":"闽南语","subtrahend":"剩余部分","numerator":"分子","denominator":"分母","sign":"符号","exponent":"指数","adjustExponents":"两个数字的指数必须是平衡的,","addExponents":"两个数字的指数必须相加","subtExponents":"两个数字的指数必须被减去,","diffExponent":"指数之差","smallerExponent":"较小的指数将从较大的指数中减去","resDiffExponent":"因此，这个差值是","newExponent":"新的指数","considerExponent":"考虑指数","mantissa":"尾数","mulMantissa":"两个数字的尾数必须相乘","solutionIsNan":"不能计算尾数，因为输入的结果是NaN","solutionIsInf":"不能计算尾数，因为输入的结果是无穷大,","solutionIsZero":"不能计算尾数，因为输入的结果是零,","addMantissa":"两个数字的尾数必须相加,","divMantissa":"两个数字的尾数必须被除掉,","newMantissa":"新的尾数","zeroMantissa":"两个尾数相等 \\\\( \\\\rightarrow \\\\) 新的尾数是0尾数","newMantissaIs":"因此，新的尾数是","equalMantissa":"两个尾数都相等 \\\\( \\\\rightarrow \\\\) 指数将被递增，尾数保持不变","equalMantissaDiv":"两个尾数都相等，不会执行二进制除法","adjustSmallerMantissa":"调整尾数","shiftMantissa":"移动尾数","mantissaFloat":"浮点数内的尾数","mantissa1float":"前导数字不是浮点数的一部分","subtTwosComplement":"减法与加法类似，都是用二的补数","mantissaTwosComplement":"从尾数中形成二的补数","switchBits":"反转比特","add1":"加1","normalize":"正常化","shiftExpMant":"指数的移位系数必须应用于尾数","shift":"移位","considerRepresentation":"考虑表示法","consider1comma":"尾数在标准形式下以1开始","ternary":"三元系统","quaternary":"四进制系统","quinary":"二元系统","senary":"二元系统","septenary":"九宫格系统","octal":"八进制系统","novenary":"Nonal系统","hexadecimal":"十六进制系统","十六进制":"十六进制","输入":"输入","数字":"数字","代表":"原始格式的表述","初始格式":"初始格式","secondFormat":"目标格式","doConversion":"转换：","modus":"模式","to":"到","TenToPower":"从十进制系统到任意系统的转换分两步进行,在逗号之前，数字的转换是使用除法算法的,逗号之后，将采用乘法算法,","PowerToTen":"一个任意的数字系统可以通过总结所有电位的数字转换为十进制系统,","PowerToPower":"我们在两个步骤内通过十进制系统将一个任意的数字系统转换为另一个系统,首先，原始数字将被转移到十进制系统中，并总结出有效的数字,在第二步中，我们使用除法和乘法的算法来创造出结果的数字","noValuesBeforeComma":"逗号前面没有数值,因此，可以跳过除法算法,","noValuesAfterComma":"逗号后面没有值,因此，可以跳过乘法算法,","firstToTen":"1.增效数字的总和","secondToPower":"2.通过除法-和乘法算法进行转换","shortcutBinToHex":"在从二进制到十六进制的转换中，可以直接读取数值","shortcutHexToBin":"在从十六进制到二进制的转换中，可以直接读取数值,","divisionAlgorithm":"除法算法","multiplicationAlgorithm":"乘法算法","summation":"求和","factor":"因数","quotient":"商数","remainder":"余数","newBasis":"Base_{\'{new}\'}","calcStep":"计算/步骤","summands":"Summands","newMantissaSignBit":"因为是补数，所以我们用符号位来计算：","disclaimerFooter":"不保证本网站所提供材料的正确性,","polyadicExercise1":"转换 中的值","polyadicExercise2":"从初始格式","polyadicExercise3":"转换为目标格式","exerciseArchive":"练习档案","randomExercise":"随机练习","doCalculation":"计算","colorCoding":"颜色编码","mathDistribution":"分布","easy":"简单","difficultyMiddle":"中等","difficultyHard":"难","sheet":"床单","goal":"目标","difficultyUC":"难度","bf_infotext_or_interact_with_kv":"或直接与KV-Diagram互动","bf_infotext_kv_must_not_be_empty":"KV-Diagram必须包含1和0","bf_infotest_click_on_hidden_areas_to_make_visible":"点击隐藏的区域使其显现","bf_normal_forms":"正常形式","bf_disjunctiveNormalForm":"不连贯的正常形式","bf_conjunctiveNormalForm":"共轭正常形式","bf_disjunctiveMinimalForm":"不连贯的最小形式","bf_conjunctiveMinimalForm":"共轭最小形式","bf_quineMCCluskeyClasses":"Quine MC Cluskey类","bf_primeTerms":"素数词","bf_primeImplicants":"质数内含物","bf_primeImplicates":"质数内含物","bf_primeCoverTable":"主蕴涵体图表/\'覆盖表\'","bf_petrickExpression":"Petrick的方法","bf_minimalForms":"最小的形式","bf_tableWithCyclicRest":"具有循环休息功能的表","bf_einstelle":"一个","bf_nullstelle":"零","bf_einstellen":"Ones","bf_nullstellen":"零","bf_goal_determine_DNF":"确定DNF","bf_goal_determine_KNF":"确定KNF","bf_goal_determine_prime_implicants":"确定质数内含物","bf_goal_determine_prime_implicates":"确定质数内含物","bf_covertable_step_description_initial":"<h4>初始步骤:</h4>在表格的列中输入所有基本术语，在行中输入所有内含物。 如果一个隐含语涵盖了{ifMinTermsEinstelleElseNullstelle}，则用X标记该单元。越多，在硬件上的实现就越复杂（即成本高）。<br>技巧:<br>如果内含物的所有字词也以同样的方式出现在基词中，那么质数内含物就完全覆盖了 (一)。","bf_covertable_step_description_core_found":"<h4>发现的核心:</h4>唯一涵盖列{columnName}的内含子是术语{rowName}。因此，这个内含子肯定会出现在我们的结果函数中。将该行标记为 (核心)，并将该列删除。","bf_covertable_step_description_cross_column_bc_covered":"<h4>已经涵盖的栏目:</h4> 列{columnName}已经被内含的{rowName}所覆盖。剔除该列。","bf_covertable_step_description_cross_row_bc_covered":"<h4>行已被覆盖：</h4>{rowName}行的所有X已经被覆盖,划掉该行,","bf_covertable_step_description_row_domination":"<h4>行的主导地位:</h4>行{dominatorName}支配行{dominatedName}；即行{dominatorName}有标记的地方，行{dominatedName}也有（而且可能更多！）。 =>交叉支配行{dominatedName}。 <br>请注意，行的支配地位只适用于，因为行{dominatorName}的成本低于，或与{dominatedName}相同；或因为没有其他行能覆盖{dominatorName}的额外标记，并且成本低于{dominatorName}-{dominatedName}。","bf_covertable_step_description_column_domination":"<h4>柱状物的优势:</h4>列{dominatorName}支配列{dominatedName}；即列{dominatorName}有标记的地方，列{dominatedName}也有（而且可能更多！）。 =>跨越支配列{dominatorName}。<br>与行优势不同，列优势根本不需要你考虑成本。","bf_covertable_step_description_cyclic_rest":"<h4>素数表算法的任何规则都不适用,这被称为\'循环休止符\'（ger: \'Zyklischer Rest\'）,通过为休止符表设置佩特里克表达式（ger: Petrick Ausdruck），人们仍然能够确定原始函数的最小形式,","bf_infoblob_random_exercise_selection":"难度说明布尔函数应该产生多少个某种类型的单项（如最小项、素数内含物）,","bf_infoblob_petrick_statement":"该算法包括两个阶段：<ol><li>通过排序使相互吸收的术语容易被看到（只在有影响的情况下显示）,</li><li>将前两项相互相乘，直到剩下典型的和,</li></ol>","bf_distributionUC":"分布","bf_idempotenceUC":"异能性","bf_absorptionUC":"吸收","bf_sortingUC":"排序","bf_infoblob_functionMin":"在这个页面上，你可以找到最小化布尔表达式的不同程序,","bf_disjunctiveNormalForm_explanation":"disjunctive normal form是一个函数的所有minterm（1）的disjunction（使用或运算符的条款组合）,每个minterm都精确地对应于函数中的1，所有字词都必须发生否定或不否定,","bf_conjunctiveNormalForm_explanation":"共轭正常形式是一个函数的所有maxterms（0s）的连接（使用和运算符的组合）,0在maxterms中不是被选择的（像minterms中的1一样），而是被排除的,每个maxterm完全对应于函数中的一个0，所有的字词都必须发生否定或不否定,","bf_quineMCCluskeyClasses_explanation":"Quine/McCluskey算法是一种最小化算法，用它可以确定一个函数的内含物,","bf_infoblob_quineMCCluskeyClasses_colorCoding":"在Quine/McCluskey算法中，还原中使用的所有术语通常都被划掉了,如果颜色编码被激活，它们将以浅灰色显示代替,","bf_infoblob_quineMCCluskeyClasses_01":"通常情况下，我们将最小或最大项写入各个类中,另外，我们也可以用0（用于否定字词）和1（用于非否定字词）来工作，据此，这些字词的位置决定了它是哪个字词,","bf_primeTerms_explanation":"具有最少字数的条款，只包括1或0","bf_bf_primeImplicants_explanation":"素数隐含物是只涵盖一的术语（有不关心的）,","bf_primeImplicates_explanation":"质数内含物是只涵盖零的术语（不关心）,","bf_disjunctiveMinimalForm_explanation":"由连接词组成的二连体，不能进一步简化（不违反此形式）（简化DNF）","bf_conjunctiveMinimalForm_explanation":"由分离连接的字词的连接，不能进一步简化（不违反此形式）（简化的KNF）","cmos_infoblob_description":"CMOS是由互补的NMOS网络（下拉网络，因为连接到地）和PMOS网络（上拉网络，因为连接到电源电压）组成的,因此，在固定的开关状态下消耗的能量较少，因为PDN和PUN是互补的，因此在开关期间只在短时间内同时传导,然而，芯片上需要更多的面积,","cmos_infoblob_input_description":"注意：对于OR门可以使用\'+\'，对于AND门可以使用\'*\'，对于负数可以使用\'~\',变量可以有任意的名字（注意：\'ab\'被认为是一个变量，而不是\'a\'乘以\'b\'）","contactPersonHeader":"联系人","herausgeber":"出版商","divWithZero":"对于分子为0的除法，其结果总是0","impressum":"版本说明","representedByHeader":"代表人是","copyright":"联邦大学计算机科学12系主任,保留所有权利,","representedBy":"计算机科学系12教席是弗里德里希-亚历山大-纽伦堡大学（FAU）内的一个公共法律机构,根据Art. 20, 21 BayHSchG，FAU作为一个国家机构和公法下的自治机构，由校长对外代表,","haftungsauschlussHeader":"免责声明","mantissaComplement":"尾数是负数,所以我们必须形成补数并设置符号位,","mantissaNormalize":"为了使尾数以前导1开始，我们需要通过应用{shift}的移位来规范化尾数,我们还必须将这个移位应用于指数，从而得到新的指数{exponent}","mantissaNormalizeDenorm":"结果不能用移位{shift}的归一化表示，所以我们用指数{exponent}的归一化表示,","newExponentDivision":"新的指数结果为 \\\\ E_{\'{neu}\'} = E_1 - E_2 + BIAS = {E1} - {E2} + {Bias} = {Result} \\\\）","newExponentMultiplication":"新指数的结果为：\\\\( E_{\'{neu}\'} = E_1 + E_2 - BIAS = {E1}) + {E2}- {Bias} = {Result}\\\\, ({ExpBits}) \\\\)","haftungsauschlussBody":"各机构对其他网站的内容负责,本网站提供的所有信息都是根据我们的知识和信念汇编和检查的,然而，我们不能保证所提供的信息是最新的、正确的、完整的或在任何时候都可以得到的,与互联网报价的用户之间不存在合同关系,我们不对因使用该互联网报价而造成的任何损失负责,如果《德国民法典》第839条的规定（违反官方职责的责任）与此相关，则该免责条款不适用,对于因恶意软件或在调用或下载数据时安装或使用软件而造成的任何损害，我们不承担责任,作为服务提供者，根据一般法律中的§ 7 para.1 TMG，我们对自己在这些网页上的内容负责,根据§8至10 TMG，我们没有义务监测传输或存储的信息或调查表明有非法活动的情况,根据一般法律，删除或阻止使用信息的义务仍然不受影响,然而，这方面的责任只有在具体的违法行为被知道时才有可能,如果我们意识到任何此类侵权行为，我们将立即删除相关内容,经营者明确保留更改、补充或删除个别网页、网络服务或整个报价的权利，而无需单独宣布，或暂时或永久停止发布","systemInBase":"基地的系统","basis":"基地","minterms":"最小条款","maxterms":"马克斯特姆","contact":"联系","impressumText":"该印记可以在以下地方找到,","and":"和","weThank":"我们要感谢以下人士在创建本网站时提供的帮助：","Danksagung":"致谢","thankProfessorTeich":"本网页上的材料是基于弗里德里希-亚历山大大学（FAU）的Jürgen Teich教授（Dr.-Ing）所做的GTI讲座,我们感谢他的专业知识和赞助,","wintersemester":"冬季学期","sommersemester":"夏季学期","downloadSvg":"导出为SVG","downloadPng":"导出为PNG","formula":"公式","divByZero":"除以0是NaN,","falseFormat":"错误的格式！"}'),mu=JSON.parse('{"complementExample":"相補計算","shiftZero":"シフト後の仮数ゼロ","doubleNegative":"ネガティヴ","denormalized":"非正規化","fpExerciseIntro":"IEEE-754に準拠した浮動小数点演算を自動生成されたタスクで練習することができます。","fpFormatSelectionSimple":"指数部と仮数部のビット数を選択します。","fpFormatSelection":"浮動小数点数のビット幅を定義し、指数部と仮数部のビット数を選択します。","fpArithIntro":"IEEE-754またはそれに基づく自己定義フォーマットによる浮動小数点演算を実践する。","fpConvIntro":"10進法とIEEE-754またはそれに基づく自己定義フォーマットによる浮動小数点数フォーマットとの変換を、作成した演習問題で練習することができます。","sequentialCircuit":"2つのD-フリップフロップと複数のマルチプレクサで構成されるスイッチング機構の例。","polyadicDivisionDescription":"小数点の前の桁は、余りの桁を下から上に読んで導きます。","polyadicMultiplicationDescription":"小数点以下は、余りの桁を上から下へ読むと出てきます。","homePageText":"このサイトでは、「コンピュータ工学の基礎（GTI）」の講義から厳選したトピックと、関連する演習の知識を深めることができます。","startTraining":"レッツゴー","polyFreeIntro":"自分の好きな方式の数値で多項式計算の練習をする。","polyConvGenIntro":"生成された練習問題で多項式間の変換を練習する。","polyConvIntro":"自由に選べる多項式間の変換練習をする。","numVarInput":"変数数","conversionExercise":"変換タスク","impressum":"インプレッサ","copyright":"FAUコンピュータサイエンス学科長。無断転載を禁じます。","herausgeber":"出版社","disclaimerFooter":"本ウェブサイトで提供される資料の正確性については、いかなる保証もいたしません。","representedByHeader":"代表者名","contactPersonHeader":"お問い合わせ先","representedBy":"コンピュータサイエンス12番教室は、フリードリヒ・アレクサンダー大学エアランゲン・ニュルンベルク校（FAU）内の公法上の機関です。BayHSchGの第20条および第21条に従い、FAUは、公的機関に属する自治団体として、学長が対外的な代表を務めています。","haftungsauschlussHeader":"免責事項","haftungsauschlussBody":"他のウェブサイトの内容については、それぞれの機関が責任を負います。本ウェブサイトで提供されるすべての情報は、当社が知り、信じる限りにおいて、編集・確認されたものです。しかしながら、当社は、提供する情報が最新であること、正確であること、完全であること、または常に利用可能であることを保証するものではありません。インターネット提供の利用者との契約関係は生じない。本ウェブサイトをご利用になったことにより生じるいかなる損害についても、当社は一切責任を負いません。この免責は、ドイツ民法典第839条（公序良俗違反に対する責任）の規定が関連する限り、適用されません。データの呼び出しやダウンロードを行う際に、マルウェアやソフトウェアのインストールや使用によって生じた損害については、当社は一切の責任を負いません。サービス提供者である当社は、一般法第7条第1項TMG（ドイツ・テレメディア法）に基づき、これらのページにおける当社自身のコンテンツに責任を負います。ただし、ドイツ連邦共和国政令第8条から10条に基づき、当社はサービス提供者として、送信または保存された第三者の情報を監視したり、違法行為を示唆する状況を調査したりする義務はありません。一般的な法律に従って情報の削除や使用を阻止する義務は影響を受けません。ただし、この点に関する責任は、具体的な侵害の事実を知った時点からしか生じません。該当する法令違反が判明した場合、当社は直ちにこのコンテンツを削除します。運営者は、個別の通知なしに、個々のウェブページ、ウェブサービスまたは提供物全体を変更、補足または削除する権利、あるいは一時的または恒久的に公開を停止する権利を明示的に留保します。","confirm":"確認","varNaming":"変数の命名","kvDiagram":"CT図","numeralSystem":"ナンバーシステム","polyadic":"ポリアディック","floatingPoint":"浮動小数点数","functionMin":"関数最小化","exercises":"演習","generateEx":"タスクの生成","generate":"生成する","addition":"追加","subtraction":"引き算","multiplication":"乗算","division":"事業部","ownSolution":"独自のソリューション","signBit":"符号ビット","correctSolution":"かいけつほうほう","solution":"解決方法","exponentBits":"指数","fractionBits":"マンティス","attRound":"ラウンドをお忘れなく","attSolve":"事前に自主的に課題を解いてみてください","step":"ステップ","freeCalculation":"無料計算","operationSelect":"手術の選択","firstFloatingPoint":"最初の浮動小数点数","secondFloatingPoint":"2番目の浮動小数点数","operand":"オペランド","decimal":"10進数","binary":"2進数","inputNumber":"番号を入力する","fpformat":"浮動小数点演算のフォーマット","check":"チェック","values":"価値観","load":"ショップ","arithmetic":"算術","conversion":"変換","conversionExercise1":"変換してください。 ","conversionExercise2":"の指数長を持つIEEE浮動小数点数値に変換する。 ","steps":"ステップス","repeatMinuend":"リピート\\\\ミニエンド","doDivision":"パフォーム部門","doMultiplication":"乗算を行う","getDescription":"プリント","approach":"かいけつほうほう","gti":"コンピュータ工学の基礎","disclaimer":"免責事項<br>：これは、GTI Onlineのウェブサイトを通じて自動的に生成されたソリューションパスです</br>。<br>また、この解決策は<u>非公式な</u>ものであり、正確性を保証するものではありません。<br>私たちは、お客様のために信頼性の高い正しいツールを開発するために、多大な労力を費やしています。とはいえ、解答経路や解答自体に誤りがある場合もある。また、ブラウザのバージョンによっても異なる場合があります。試験などで使用する際は、事前に解答を確認してください。</br></br>","example":"例","composition":"構成","negativeSummand":"負の値を持つ加算は、減算と同様に扱われる。","negativeSubtrahend":"負の下辺は正の上辺と同じ効果があります。","negativeMinuendSubtrahend":"の場合の簡便法\\\\( - x - y \\\\rightarrow - (x + y) \\\\)","addWithZero":"0を使った足し算では、もう一方の和が変化することはない。","subWithZero":"0の引き算は、最小値を変更しません。","divWithZero":"分子に0を含む除算があった場合、結果は0となる。","mulWithZero":"0を掛けると、結果は常に0になります。","zeroDivision":"0による除算は不可能です","arithmeticFree":"自由な算数","conversionFree":"無償変換","value":"価値","givenValues":"送信番号の値","leftValue":"残数","rightValue":"ナンバーライト","firstSummand":"1.加算","secondSummand":"2.2.Summand","firstFactor":"ファクター1","secondFactor":"ファクター2","numerator":"カウンター","denominator":"分母","minuend":"ミニエンド","subtrahend":"サブラヘンド","sign":"サイン","exponent":"指数","adjustExponents":"両数値の指数を調整する必要があります。","addExponents":"両方の数値の指数を足し合わせる必要があります。","subtExponents":"両方の数値の指数を引き算する必要があります。","diffExponent":"差分指数","smallerExponent":"小さい方の指数は常に大きい方の指数から減算されます。","resDiffExponent":"したがって、その差は","newExponentDivision":"新しい指数は次のように与えられます。 \\\\( E_{\'{new}\'} = E_1 - E_2 + BIAS = {E1} - {E2} + {Bias} = {Result} \\\\)","newExponentMultiplication":"新しい指数は、次のように与えられます。\\\\( E_{\'{neu}\'} = E_1 + E_2 - BIAS = {E1} + {E2} - {Bias} = {Result}\\\\, ({ExpBits})\\\\)","considerExponent":"注釈 指数","fpExerciseText":"浮動小数点数\\\\(fp_1\\\\)と\\\\(fp_2\\\\)を16bit浮動小数点形式で与えましょう。2進表現のままで{op1} \\\\( fp_1 {op2} fp_2 \\\\) を計算し、結果を再び浮動小数点数で与えます。","mantissa":"マンティス","solutionIsNan":"結果は確実にNaNなので仮数を計算する必要はない。","solutionIsInf":"結果は確実に無限大なので、仮数を計算する必要はありません。","solutionIsZero":"結果は確実に0なので、仮数を計算する必要はありません。","mulMantissa":"両方の数値のマンティサを掛け合わせる必要があります。","addMantissa":"両方の数字のマンティサを足す必要があります。","divMantissa":"両数値のマンティサスを分割する必要があります。","newMantissa":"新しい仮数","zeroMantissa":"仮数は同一である \\\\( \\\\rightarrow \\\\) 新仮数は0仮数である","newMantissaIs":"そこで、次のように計算します。","newMantissaSignBit":"補数の関係で、符号ビットで計算する。","equalMantissa":"仮数は同じで、指数を1増やしただけ( ˶ˆ꒳ˆ˵ )","equalMantissaDiv":"2つのマンティサは等しいので、2進法の除算は行いません。仮数は{Mantissa}とする。","adjustSmallerMantissa":"仮数を調整する","shiftMantissa":"仮数部のシフト","mantissaFloat":"浮動小数点数の仮数","mantissaNormalize":"仮数が先頭の1から始まるようにするには、{shift}のシフトを適用して仮数を正規化する必要があります。また、このシフトを指数に適用して、新しい指数{exponent}を得る必要があります。","mantissaNormalizeDenorm":"その結果は、シフト{shift}を用いた正規化表現では表現できないので、指数{exponent}を用いた非正規化表現を用いる。","mantissaDenormalize":"シフトをかけると負の指数になるので、結果を表示するには、非正規化表現を使わなければならない。そのため、指数を完全に0にし、先頭の1も含めて仮数を指数分だけシフトさせる。仮数には先行するゼロを仮定する。","mantissa1float":"最後に、仮数の先頭桁を削除して、IEEE-754表現の仮数ビットを得る。したがって、仮数ビットは","mantissaComplement":"仮数は負とする。そこで、補数を形成し、符号ビットを設定する必要があります。","subtTwosComplement":"引き算は、2の補数による加算に対応する","mantissaTwosComplement":"仮数から2の補数を形成する。","switchBits":"ビットを反転させる","add1":"1加算","normalize":"ノーマライズ","shiftExpMant":"指数のシフトファクターは、マンティサスに適用する必要があります。","shift":"シフト","considerRepresentation":"注釈表示","consider1comma":"仮数は標準表現では常に小数点の前の1（非正規化された場合は0）で始まる。","ternary":"三元数","quaternary":"第四世代数","quinary":"クインタルナンバー","senary":"六角番号","septenary":"ヘプタールシステム","octal":"8進数","novenary":"ノナル数","hexadecimal":"16進数","hex":"十六進法","input":"入力","number":"番号","representation":"出力フォーマットの再現性","firstFormat":"出力フォーマット","secondFormat":"対象フォーマット","doConversion":"変換を行う。","modus":"モデュス","to":"まで","TenToPower":"10進法から他の多進法に変換する場合、小数点の前に除算アルゴリズムが、小数点の後に乗算アルゴリズムが適用されます。","PowerToTen":"任意のシステムの10進法への変換は、指数化された桁を合計することで行われます。","PowerToPower":"ある数体系から別の数体系への変換は、2つのステップで行われる。まず、原始系の数字を足し算して10進数に移します。そして、この10進数は、小数点以下の桁を逐次除算し、小数点以下の桁を逐次乗算することで目的系に変換される。","noValuesBeforeComma":"小数点以下の数値がない。除算アルゴリズムは省略可能","noValuesAfterComma":"小数点以下の数値がない。乗算のアルゴリズムは省略可能","firstToTen":"1. 指数化された数字を合計する","secondToPower":"2.除算・乗算アルゴリズムによる変換","shortcutBinToHex":"バイナリから16進数に変換する場合、値を直接読み取ることができます。","shortcutHexToBin":"16進数から2進数に変換する場合、値を直接読み取ることができる。","divisionAlgorithm":"整数部（除算アルゴリズム）","multiplicationAlgorithm":"小数点以下の桁数（乗算アルゴリズム）","summation":"加算する","factor":"ファクター","quotient":"商","remainder":"休息","newBasis":"Base_{\'{new}\'}を使用します。","calcStep":"計算ステップ","summands":"スマンド","polyadicExercise1":"を変換する。","polyadicExercise3":"にしています。 ","exerciseArchive":"タスクアーカイブ","randomExercise":"ランダムタスク","doCalculation":"計算する","colorCoding":"色分けについて","mathDistribution":"ディストリビューター","easy":"徒に","difficultyMiddle":"巫女","difficultyHard":"ヘビー","sheet":"シート","goal":"目的地","difficultyUC":"難易度","bf_infotext_or_interact_with_kv":"またはKV図と直接対話する","bf_infotext_kv_must_not_be_empty":"KVダイアグラムは1と0を含むこと","bf_infotest_click_on_hidden_areas_to_make_visible":"隠れた部分をクリックすると、その部分が表示されます","bf_normal_forms":"正規形","bf_disjunctiveNormalForm":"選言的正規形","bf_conjunctiveNormalForm":"接続型正規形","bf_disjunctiveMinimalForm":"選言的最小形式","bf_conjunctiveMinimalForm":"接続可能な最小形態","bf_quineMCCluskeyClasses":"クワイン・マクルスキークラス","bf_primeTerms":"プリムテルム","bf_primeImplicants":"プリムプリカンツ","bf_primeImplicates":"プリムプリケート","bf_primeCoverTable":"オーバーラップテーブル","bf_petrickExpression":"ペトロール表現","bf_minimalForms":"ミニマムフォーム","bf_tableWithCyclicRest":"巡回残差表","bf_einstelle":"エントリーポイント","bf_nullstelle":"ゼロ","bf_einstellen":"勤務地","bf_nullstellen":"ゼロ","bf_goal_determine_DNF":"DNFを決定する","bf_goal_determine_KNF":"KNFを決定する","bf_goal_determine_prime_implicants":"素因数分解を行う","bf_goal_determine_prime_implicates":"プライムインプリケートの決定","bf_covertable_step_description_initial":"<h4>最初の手順：</h4>すべての基本語（{ifMinTermsSetElseNull}）を列に、すべての主要語（PI）を行に、テーブルに入力します。ifMinTermsEinstelleElseNullstelle}を素項が覆っている場合、そのセルに×印をつける。コストcはすべての素項（{ifMinTermsEinstellenElseNullstelle}）を合計したものである。素数項のコストcは、そのリテラルの数である。数字が大きくなるほど、ハードウェアで実装する際のコストが高くなる。<br>ヒント：<br>プリムプリカントは、プリム項のすべてのリテラルがベース項にも同じように出現する場合に、ON桁を正確にカバー</br>します。</br>","bf_covertable_step_description_core_found":"<h4>Core found:</h4>{ifMinTermsElseNull}をカバーする唯一の素性項。{columnName}は{rowName}の項である。だから、この素性項は、スイッチング関数に絶対に登場しなければならないのです行をコアとマークし、列をクロスする。","bf_covertable_step_description_cross_column_bc_covered":"<h4>Column already covered:</h4>{ifMinTermsSetElseNullSets}{columnName}は、素性項{rowName}によってすでにカバーされています。欄を消してください。","bf_covertable_step_description_cross_row_bc_covered":"<h4>Row already fully covered:</h4>行{rowName}のすべてのXはすでにカバーされています。列を消してください。","bf_covertable_step_description_row_domination":"線分支配<h4>：</h4>線分{dominatorName}は線分{dominatedName}を支配する。すなわち、線分{dominatedName}にもマーカーがあるところ（あるいはもっとあるかもしれないところ）に{dominatorName}はマーカーを有する。=&gt; 支配された行{dominatedName}を削除します。<br>行の優位性は、行{dominatorName}のコストが{dominatedName}よりも低いか同じであるか、または{dominatorName}の追加桁をカバーし、{dominatorName} - {dominatedName}よりも低いコストの他の行が存在しない場合にのみ適用できることに留意してください。</br>","bf_covertable_step_description_column_domination":"カラムの優位性<h4>：</h4>カラム {dominatorName} はカラム {dominatedName} を優位に保ちます。つまり、カラム {dominatedName} にもマーカーがある場所（あるいはそれ以上）には {dominatorName} にもマーカーがあるということです。=&gt; 支配する列 {dominatorName} を削除します。<br>行の</br>支配とは<br>対照的に</br>、<br>列の支配ではコストを考慮する必要は全くありません (/â-½ï¼¼</br>) 。","bf_covertable_step_description_cyclic_rest":"<h4>周期的余り：</h4>オーバーラップテーブルのルールは適用されない。これを「周期的余り」という。<br>切り替え関数の最小形式を決定できるようにするために、ペトリック式をリストアップすることが可能であり、それによって、まだクロスアウトされていない行と列のみが入力されることになる。</br>","bf_infoblob_random_exercise_selection":"選択された難易度は、一種類の項（mintermsやprime implicantsなど）をいくつ含むべきかを決定します。","bf_infoblob_petrick_statement":"このアルゴリズムは、2つのフェーズで構成されています。<ol><li>できるだけ多くのものを吸収できるように用語を並べ替えてください。</li><li>項を掛け合わせる。</li></ol>","bf_distributionUC":"流通","bf_idempotenceUC":"イデムポテンツ","bf_absorptionUC":"吸収量","bf_sortingUC":"ソート","bf_infoblob_functionMin":"関数最小化のさまざまな手順を練習する","bf_disjunctiveNormalForm_explanation":"分離正規形とは、ある関数のすべてのminterms（1s）の論理和（veroderung）である。各mintermは関数内のちょうど1つの1に対応する。すべてのリテラルはその中で否定されるか、否定されないかでなければならない。","bf_conjunctiveNormalForm_explanation":"結合正規形は、関数のすべての項（0）を結合したものである。maxtermsでは0は（mintermsの1のように）選択されず、除外される。各maxtermは関数内のちょうど1つの0に対応する。すべてのリテラルはその中で否定されるか、否定されないかでなければならない。","bf_quineMCCluskeyClasses_explanation":"Quine/McCluskey法は、関数の素項を決定する最小化法である。","bf_infoblob_quineMCCluskeyClasses_colorCoding":"Quine/McCluskeyの手順では、通常、縮小された用語には取り消し線が引かれている。色分けが有効な場合は、代わりにライトグレーで表示されます。 ","bf_infoblob_quineMCCluskeyClasses_01":"通常、個々のクラスでmin-やmaxtermsを書く。また、0（否定されたリテラル）と1（否定されないリテラル）を使って、これらの位置によってどちらのリテラルであるかを決定することもできます。","bf_primeTerms_explanation":"最小限のリテラル数で、1または0のみをカバーする条件。 ","bf_bf_primeImplicants_explanation":"プリミティブは、1つの位置だけをカバーするプリミティブです（クロッピングあり）。 ","bf_primeImplicates_explanation":"プライムインプリケートとは、ゼロだけをカバーする（空孔を持つ）素数項である。 ","bf_disjunctiveMinimalForm_explanation":"接続詞で結ばれたリテラルのディスジャンクション。これは（この形式に反しない限り）これ以上単純化できない（単純化DNF）。","bf_conjunctiveMinimalForm_explanation":"ディスジャンクションで結ばれたリテラル同士の接続。これをさらに（本形式に反しない範囲で）簡略化することはできない（簡略化KNF）。","cmos_infoblob_description":"CMOSは、相補的なNMOSスイッチングネットワーク（プルダウンネットワーク、グランドに接続）とPMOSスイッチングネットワーク（プルアップネットワーク、電源電圧に接続）を組み合わせたものである。その結果、PDNとPUNは相補的であるため、スイッチング時に短時間しか同時に導通しないため、固定スイッチング状態での消費電力は少なくなります。しかし、チップ上でより多くの面積を必要とします。","cmos_infoblob_input_description":"注）ORゲートには「＋」、ANDゲートには「*」、否定には「~」を使用することができる。変数は任意の名前を持つことができる（注意：入力の\'ab\'は変数として解釈され、\'a\'と\'b\'の合成とはみなされない）。","enter_cmos":"CMOSの入力を行ってください。","polyadicExercise2":"を初期フォーマットから変更しました。","newExponent":"新指数","systemInBase":"ベースへのシステム","basis":"ベース","minterms":"ミンテルム","maxterms":"マックスターム","contact":"お問い合わせ先","impressumText":"下に刻印があります。 ","and":"と","weThank":"本サイトの作成にあたり、以下の方々にご協力いただきました。","Danksagung":"謝辞","thankProfessorTeich":"本ページの資料は、フリードリヒ・アレクサンダー大学（FAU）のJörgen Teich教授による講演「GTI」をもとに作成されています。彼の専門知識と愛顧に感謝します。","wintersemester":"冬学期","sommersemester":"夏学期","downloadSvg":"SVGの書き出し","downloadPng":"PNGの書き出し","formula":"式","divByZero":"0で割るとNaNになります。","falseFormat":"フォーマットが違う"}'),pu=JSON.parse('{"complementExample":"Додатковий розрахунок","shiftZero":"Нульова мантиса після зсуву","doubleNegative":"Негатив","denormalized":"Денормалізація","fpExerciseIntro":"Потренуйтеся в арифметиці з плаваючою комою за стандартом IEEE-754, використовуючи автоматично згенеровані завдання.","fpFormatSelectionSimple":"Виберіть кількість розрядів для експоненти та мантиси.","fpFormatSelection":"Визначте розрядність числа з плаваючою комою, а потім виберіть кількість розрядів для експоненти та мантиси.","fpArithIntro":"Практикувати арифметику з плаваючою комою відповідно до стандарту IEEE-754 або самостійно визначеного формату на його основі.","fpConvIntro":"За допомогою згенерованих вправ відпрацювати перетворення між десятковою системою числення та форматом чисел з плаваючою комою за стандартом IEEE-754 або самостійно визначеним форматом на його основі.","sequentialCircuit":"Приклад комутаційного механізму, що складається з двох D-тригерів і декількох мультиплексорів.","polyadicDivisionDescription":"Цифри перед десятковою крапкою утворюються з цифр остачі шляхом їх читання знизу вгору.","polyadicMultiplicationDescription":"Десяткові знаки виходять з цифр залишку, якщо читати їх зверху вниз.","homePageText":"На цьому сайті ви можете поглибити свої знання з окремих тем лекції \\"Основи комп\'ютерної інженерії\\" (GTI) та пов\'язаних з нею вправ.","startTraining":"Ходімо.","polyFreeIntro":"Практикуйте поліадичну арифметику з власними числовими значеннями в бажаній системі.","polyConvGenIntro":"Відпрацювати конвертацію між поліадичними системами на згенерованих вправах.","polyConvIntro":"Практикуйте конвертацію між поліадичними системами, які ви можете вільно обирати.","numVarInput":"Кількість змінних","conversionExercise":"Завдання конверсії","impressum":"Impressum","copyright":"Кафедра комп\'ютерних наук 12, ФАУ. Всі права захищені.","herausgeber":"Видавець","disclaimerFooter":"Ми не надаємо жодних гарантій щодо точності матеріалів, розміщених на цьому веб-сайті.","representedByHeader":"В особі","contactPersonHeader":"Контакти","representedBy":"Кафедра комп\'ютерних наук 12 є установою публічного права у складі Університету Фрідріха-Александра в Ерланген-Нюрнберзі (FAU). Відповідно до статей 20 та 21 BayHSchG, ФАУ, як державну установу та самоврядний орган публічного права, зовні представляє Президент.","haftungsauschlussHeader":"Відмова від відповідальності","haftungsauschlussBody":"Відповідальність за зміст інших веб-сайтів несуть відповідні установи. Вся інформація, надана на цьому веб-сайті, була зібрана і перевірена, наскільки нам відомо і наскільки ми вважаємо за потрібне. Однак ми не можемо гарантувати, що надана інформація є актуальною, правильною, повною або доступною в будь-який час. Договірні відносини з користувачами інтернет-оферти не виникають. Ми не несемо відповідальності за будь-яку шкоду, спричинену використанням цього веб-сайту. Це виключення відповідальності не застосовується в частині, що стосується положень §839 Цивільного кодексу Німеччини (відповідальність за порушення службових обов\'язків). Ми не несемо відповідальності за будь-які збитки, спричинені шкідливим програмним забезпеченням або встановленням чи використанням програмного забезпечення під час виклику чи завантаження даних. Як постачальник послуг, ми несемо відповідальність за власний контент на цих сторінках відповідно до § 7 абз. 1 TMG (Закон про телемедіа Німеччини) згідно із загальним законодавством. Однак, відповідно до §§ 8-10 TMG, ми не зобов\'язані як постачальник послуг здійснювати моніторинг переданої або збереженої інформації третіх осіб або розслідувати обставини, що вказують на незаконну діяльність. Зобов\'язання видаляти або блокувати використання інформації відповідно до загальних законів залишаються незмінними. Однак, відповідальність у цьому відношенні можлива лише з моменту, коли стало відомо про конкретне порушення. Якщо нам стане відомо про відповідні порушення законодавства, ми негайно видалимо цей контент. Оператор прямо залишає за собою право змінювати, доповнювати або видаляти окремі веб-сторінки, веб-сервіси або всю пропозицію без окремого повідомлення, а також тимчасово або постійно припиняти публікацію.","confirm":"Підтвердити","varNaming":"Іменування змінних","kvDiagram":"Схема КТ","numeralSystem":"Системи числення","polyadic":"Поліадичний","floatingPoint":"Числа з плаваючою комою","functionMin":"Мінімізація функцій","exercises":"Навчання","generateEx":"Сформувати завдання","generate":"Згенерувати","addition":"Доповнення","subtraction":"Віднімання","multiplication":"Множення","division":"Підрозділ","ownSolution":"Власне рішення","signBit":"Знаковий біт","correctSolution":"спосіб вирішення","solution":"Рішення","exponentBits":"Показник","fractionBits":"Mantisse","attRound":"Не забувайте про патрони!","attSolve":"Будь ласка, спробуйте розв\'язати завдання самостійно заздалегідь!","step":"Крок","freeCalculation":"Безкоштовний розрахунок","operationSelect":"Вибір операції","firstFloatingPoint":"Перше число з плаваючою комою","secondFloatingPoint":"Друге число з плаваючою комою","operand":"Операнд","decimal":"Десяткове число","binary":"Двійкове число","inputNumber":"Введіть номер","fpformat":"Формат з плаваючою комою","check":"Перевірте.","values":"Цінності","load":"Магазин","arithmetic":"Арифметика","conversion":"Конверсія","conversionExercise1":"Навернись: ","conversionExercise2":"в IEEE число з плаваючою комою експоненціальної довжини ","steps":"Кроки","repeatMinuend":"Повторити мінусовку","doDivision":"Виконавчий відділ","doMultiplication":"Виконати множення","getDescription":"Друк","approach":"спосіб вирішення","gti":"Основи комп\'ютерної інженерії","disclaimer":"Відмова від відповідальності<br>: Це автоматично згенерований шлях до рішення через веб-сайт GTI Online. Ми не можемо гарантувати правильність, тому запропоноване рішення є <u>неофіційним</u>.<br>Ми докладаємо багато зусиль, щоб розробити для вас надійний і правильний інструмент. Тим не менш, шлях вирішення або саме рішення може містити помилки. Це також може бути пов\'язано з певними версіями браузерів. Будь ласка, перевірте рішення, перш ніж використовувати його, наприклад, на іспиті.</br></br>","example":"Приклад","composition":"Склад","negativeSummand":"Додавання з від\'ємним значенням розглядається як віднімання.","negativeSubtrahend":"Від\'ємний підчлен має такий самий ефект, як і додатний доданок.","negativeMinuendSubtrahend":"Спрощення для випадку \\\\( - x - y \\\\rightarrow - (x + y) \\\\)","addWithZero":"При додаванні з 0 інший доданок не змінюється.","subWithZero":"Віднімання з 0 не змінює зменшуваного","divWithZero":"Якщо є ділення з 0 в чисельнику, то результат дорівнює 0.","mulWithZero":"При множенні на 0 результат завжди дорівнює 0.","zeroDivision":"Ділення на 0 неможливе!","arithmeticFree":"Вільна арифметика","conversionFree":"Безкоштовна конвертація","value":"Значення","givenValues":"Значення переданих номерів","leftValue":"Кількість зліва","rightValue":"Номер праворуч","firstSummand":"1. Доданок","secondSummand":"2. Доданок","firstFactor":"Фактор 1","secondFactor":"Фактор 2","numerator":"Лічильник","denominator":"Знаменник","minuend":"Minuend","subtrahend":"Subtrahend","sign":"Знак","exponent":"Показник","adjustExponents":"Показники обох чисел мають бути скориговані.","addExponents":"Експоненти обох чисел необхідно скласти разом.","subtExponents":"Показники степенів обох чисел необхідно відняти.","diffExponent":"Експонента різниці","smallerExponent":"Менший показник завжди віднімається від більшого показника.","resDiffExponent":"Тому різниця полягає в тому, що","newExponentDivision":"Нова експонента визначається як \\\\( E_{\'{new}\'} = E_1 - E_2 + BIAS = {E1} - {E2} + {Bias} = {Result} \\\\)","newExponentMultiplication":"Нова експонента задається як \\\\( E_{\'{new}\'} = E_1 + E_2 - BIAS = {E1} + {E2} - {Bias} = {Result}\\\\, ({ExpBits})\\\\)","considerExponent":"Експонента примітки","fpExerciseText":"Нехай числа з плаваючою комою \\\\( fp_1 \\\\) та \\\\( fp_2 \\\\) задано у 16-бітному форматі з плаваючою комою. Обчислити {op1} \\\\( fp_1 {op2} fp_2 \\\\), не виходячи з двійкового представлення, і знову видати результат у вигляді числа з плаваючою комою:","mantissa":"Mantisse","solutionIsNan":"Мантису не потрібно обчислювати, оскільки результат, безумовно, є NaN.","solutionIsInf":"Мантису не потрібно обчислювати, тому що результат, безумовно, нескінченний.","solutionIsZero":"Мантису обчислювати не потрібно, оскільки результат, безумовно, дорівнює 0.","mulMantissa":"Мантиси обох чисел необхідно перемножити.","addMantissa":"Мантиси обох чисел потрібно скласти разом.","divMantissa":"Богомолів обох чисел необхідно розділити.","newMantissa":"Нова мантиса","zeroMantissa":"Мантиси однакові \\\\( \\\\rightarrow \\\\) new mantissa is 0-mantissa","newMantissaIs":"Отже, ми підрахували","newMantissaSignBit":"Через доповнення ми обчислюємо зі знаковим розрядом:","equalMantissa":"Мантиси однакові, експонента \\\\( \\\\rightarrow \\\\) збільшується на 1, мантиса залишається незмінною","equalMantissaDiv":"Дві богомолки рівні, тому двійкове ділення не виконується. Мантиса дорівнює {Мантиса}.","adjustSmallerMantissa":"Налаштування мантиси","shiftMantissa":"Зсув мантиси","mantissaFloat":"Мантиса в поплавку","mantissaNormalize":"Для того, щоб мантиса починалася з ведучої 1, потрібно нормалізувати мантису, застосувавши зсув {shift}. Ми також повинні застосувати цей зсув до експоненти, в результаті чого отримаємо нову експоненту {exponent}.","mantissaNormalizeDenorm":"Результат не може бути представлений в нормалізованому представленні зі зсувом {shift}, тому використовується денормалізоване представлення з експонентою {exponent}.","mantissaDenormalize":"Оскільки після застосування зсуву ми отримуємо від\'ємну експоненту, ми повинні використовувати денормалізоване представлення для відображення результату. Для цього ми встановлюємо експоненту повністю в 0 і зсуваємо наші мантиси, в тому числі і ведучу, на величину експоненти. За мантису приймається ведучий нуль.","mantissa1float":"Нарешті, ми видаляємо старший розряд мантиси, щоб отримати біти мантиси представлення IEEE-754. Отже, біти мантиси є такими:","mantissaComplement":"Мантиса від\'ємна. Отже, ми маємо сформувати доповнення і встановити знаковий біт.","subtTwosComplement":"Віднімання відповідає додаванню з доповненням двійки","mantissaTwosComplement":"Утворення доповнення двійки з мантиси","switchBits":"Інвертні біти","add1":"1 addieren","normalize":"Нормалізувати","shiftExpMant":"До мантис необхідно застосовувати коефіцієнт зсуву експоненти.","shift":"Зміна","considerRepresentation":"Представлення векселів","consider1comma":"Мантиса завжди починається з 1 перед десятковою крапкою в стандартному поданні (і з 0, якщо денормалізовано).","ternary":"Тернарне число","quaternary":"Четвертинне число","quinary":"Кількість центнерів","senary":"Шестизначне число","septenary":"Гептальна система","octal":"Вісімкове число","novenary":"Нецифрове число","hexadecimal":"Шістнадцяткове число","hex":"Шістнадцяткова система числення","input":"Вхідні дані","number":"Кількість","representation":"Відтворення вихідного формату","firstFormat":"Вихідний формат","secondFormat":"Цільовий формат","doConversion":"Виконати конвертацію:","modus":"Модус","to":"до","TenToPower":"При переведенні з десяткової системи числення в іншу поліадичну систему алгоритм ділення застосовується до десяткової крапки, а алгоритм множення - після десяткової крапки.","PowerToTen":"Переведення будь-якої системи числення в десяткову здійснюється шляхом підсумовування піднесених до степеня цифр.","PowerToPower":"Переведення числа однієї системи числення в іншу систему числення відбувається у два етапи. Спочатку число вихідної системи переводиться в десяткову систему шляхом додавання. Потім це десяткове число переводиться в цільову систему шляхом послідовного ділення цифр до коми та послідовного множення цифр після коми.","noValuesBeforeComma":"Без значень до десяткової крапки. Алгоритм ділення можна опустити","noValuesAfterComma":"Значення після десяткової крапки відсутні. Алгоритм множення можна опустити","firstToTen":"1. підсумовування піднесених до степеня цифр","secondToPower":"2. перетворення за допомогою алгоритму ділення та множення","shortcutBinToHex":"При перетворенні з двійкової системи числення в шістнадцяткову, значення можна зчитувати безпосередньо.","shortcutHexToBin":"При перетворенні з шістнадцяткової системи числення в двійкову, значення можна зчитувати безпосередньо.","divisionAlgorithm":"Ціла частина (алгоритм ділення)","multiplicationAlgorithm":"Десяткові знаки (алгоритм множення)","summation":"Підсумувати","factor":"Фактор","quotient":"Коефіцієнт","remainder":"Відпочинок","newBasis":"Base_{\'{new}\'}","calcStep":"Крок розрахунку","summands":"Доданки","polyadicExercise1":"Перетворіть","polyadicExercise3":"в ","exerciseArchive":"Архів завдань","randomExercise":"Випадкове завдання","doCalculation":"Розрахувати","colorCoding":"Кольорове кодування","mathDistribution":"Distribriierung","easy":"просто","difficultyMiddle":"середній","difficultyHard":"важкий","sheet":"аркуш","goal":"мета","difficultyUC":"труднощі","bf_infotext_or_interact_with_kv":"Або взаємодіяти безпосередньо з діаграмою КВ","bf_infotext_kv_must_not_be_empty":"Діаграма КВ повинна містити одиниці та нулі","bf_infotest_click_on_hidden_areas_to_make_visible":"Натисніть на приховані області, щоб показати їх","bf_normal_forms":"Звичайні_форми","bf_disjunctiveNormalForm":"Диз\'юнктивна нормальна форма","bf_conjunctiveNormalForm":"Сполучникова нормальна форма","bf_disjunctiveMinimalForm":"Диз\'юнктивна мінімальна форма","bf_conjunctiveMinimalForm":"Сполучникова мінімальна форма","bf_quineMCCluskeyClasses":"Класи Quine McCluskey","bf_primeTerms":"Примтерм","bf_primeImplicants":"прості імпліканти","bf_primeImplicates":"основні причетні","bf_primeCoverTable":"титульна таблиця","bf_petrickExpression":"Вираз Петрика","bf_minimalForms":"Мінімальні форми","bf_tableWithCyclicRest":"Циклічна таблиця залишків","bf_einstelle":"Один","bf_nullstelle":"Нуль","bf_einstellen":"Одні","bf_nullstellen":"Нулі","bf_goal_determine_DNF":"Визначити DNF","bf_goal_determine_KNF":"Визначити КNF","bf_goal_determine_prime_implicants":"Визначити прості імпліканти","bf_goal_determine_prime_implicates":"Визначити первинні імплікати","bf_covertable_step_description_initial":"<h4>Початковий крок:</h4>Введіть всі базисні члени ({ifMinTermsSetElseNull}) у стовпці та всі прості члени (PI) у рядки таблиці. Якщо простий член покриває {ifMinTermsEinstelleElseNullstelle}, позначте цю клітинку X. Вартість c є сумою всіх базисних членів ({ifMinTermsEinstellenElseNullstelle}). Вартість c простого терма дорівнює кількості його літералів. Чим більша цифра, тим дорожче її реалізувати апаратно. <br>Підказка: Первісний терм<br>покриває цифру ON саме тоді, коли всі літерали первинного терма зустрічаються так само в базовому тер</br>мі.</br>","bf_covertable_step_description_core_found":"<h4>Знайдено ядро:</h4>Єдиний простий член, який покриває {ifMinTermsElseNull} {columnName} - це термін {rowName}. Тому цей первісний член обов\'язково має бути в нашій комутаційній функції! Позначте рядок як основний і закресліть стовпчик.","bf_covertable_step_description_cross_column_bc_covered":"<h4>Стовпець, що вже охоплений:</h4>{ifMinTermsSetElseNullSets} {columnName} вже охоплений головним членом {rowName}. Викреслити стовпчик.","bf_covertable_step_description_cross_row_bc_covered":"<h4>Рядок вже повністю покритий:</h4>Всі X рядка {ім\'я_рядка} вже покриті. Перекресліть рядок.","bf_covertable_step_description_row_domination":"Домінування лінії<h4>:</h4>Лінія {ім\'я домінанта} домінує над лінією {ім\'я домінанти}, тобто {ім\'я домінанта} має маркери скрізь, де лінія {ім\'я домінанти} також має маркери (і, можливо, навіть більше). =&gt; Видалити домінуючий рядок {dominatedName}. <br>Зауважте, що домінування рядка застосовується лише тому, що рядок {ім\'я домінуючого учасника} коштує менше або стільки ж, скільки {ім\'я домінуючого учасника}; або тому, що не існує іншого рядка, який покриває додаткові цифри {ім\'я домінуючого учасника} і коштує менше, ніж {ім\'я домінуючого учасника} - {ім\'я домінуючого учасника}.</br>","bf_covertable_step_description_column_domination":"Домінування стовпців<h4>:</h4>Стовпець {ім\'я домінанта} домінує над стовпцем {ім\'я домінанти}, тобто {ім\'я домінанта} має маркери скрізь, де стовпець {ім\'я домінанти} також має маркери (і, можливо, навіть більше). =&gt; Видалити домінуючий стовпець {dominatorName}На<br>відміну від</br>домінування<br>рядків, домінування стовпців взагалі не потребує врахування витрат (/â-½ï¼¼</br>).","bf_covertable_step_description_cyclic_rest":"<h4>Циклічний залишок:</h4>правило таблиці перекриття не застосовується. Це називається \\"циклічним залишком\\".<br>Для того, щоб мати можливість визначити мінімальну форму перемикальної функції, можна перерахувати вираз Петрика, при цьому вписуються тільки ті рядки і стовпці, які ще не були викреслені.</br>","bf_infoblob_random_exercise_selection":"Обрана складність визначає, скільки термів одного виду (наприклад, мінтермів, простих імплікант) повинна містити перемикальна функція.","bf_infoblob_petrick_statement":"Алгоритм складається з двох етапів:<ol><li>Переставити терміни так, щоб якомога більше було засвоєно.</li><li>Перемножте терміни.</li></ol>","bf_distributionUC":"Дистрибуція","bf_idempotenceUC":"Idempotenz","bf_absorptionUC":"Поглинання","bf_sortingUC":"Сортування","bf_infoblob_functionMin":"Практикуйте різні процедури мінімізації функцій","bf_disjunctiveNormalForm_explanation":"Диз\'юнктивна нормальна форма - це диз\'юнкція (veroderung) всіх мінтермів (1s) функції. Кожному мінтерму відповідає рівно одна 1 у функції, всі літерали в ній повинні бути заперечуваними або не заперечуваними.","bf_conjunctiveNormalForm_explanation":"Кон\'юнктивна нормальна форма - це кон\'юнкція всіх членів (0) функції. Нулі не вибираються в макстернах (як одиниці в мінтермах), а виключаються. Кожному maxterm відповідає рівно один 0 у функції, всі літерали в ній повинні бути заперечуваними або не заперечуваними.","bf_quineMCCluskeyClasses_explanation":"Метод Квайна/Мак-Класкі - це метод мінімізації, за допомогою якого можна визначити прості члени функції.","bf_infoblob_quineMCCluskeyClasses_colorCoding":"Скорочені строки, як правило, позначаються закресленням у процедурі Куайна/МакКласкі. При активному кольоровому кодуванні вони забарвлюються у світло-сірий колір. ","bf_infoblob_quineMCCluskeyClasses_01":"Зазвичай ми пишемо мінімальні або максимальні терміни в окремих класах. Крім того, ми також можемо працювати з 0 (для заперечних літералів) і 1 (для незаперечних літералів), причому позиція цих символів визначає, який це літерал.","bf_primeTerms_explanation":"Терміни з мінімальною кількістю літер, що охоплюють тільки одиниці або нулі. ","bf_bf_primeImplicants_explanation":"Приімплікації - це приставки, які охоплюють лише ОДНУ позицію (з обрізанням). ","bf_primeImplicates_explanation":"Прості імплікати - це прості члени, які охоплюють тільки нулі (з вакантними місцями). ","bf_disjunctiveMinimalForm_explanation":"Диз\'юнкція літералів, з\'єднаних сполучником. Це не може бути спрощено далі (без порушення цієї форми) (спрощений ФНП).","bf_conjunctiveMinimalForm_explanation":"Об\'єднання літералів, з\'єднаних диз\'юнкцією. Це не може бути спрощено далі (без порушення цієї форми) (спрощена КНФ).","cmos_infoblob_description":"КМОП являє собою композицію взаємодоповнюючих NMOS-мереж перемикання (pull-down мережа, оскільки підключена до землі) і PMOS-мережі перемикання (pull-up мережа, оскільки підключена до напруги живлення). Як наслідок, у фіксованому стані перемикання споживається менше енергії, оскільки PDN і PUN доповнюють один одного і, таким чином, працюють одночасно лише протягом короткого часу під час перемикання. Однак, на мікросхемі потрібно більше площі.","cmos_infoblob_input_description":"Примітка: Для воріт АБО можна використовувати \\"+\\", для воріт І - \\"*\\", а для заперечення - \\"~\\". Змінні можуть мати довільні імена (увага: вхідні дані \\"ab\\" інтерпретуються як змінна, а не як з\'єднання \\"a\\" і \\"b\\").","enter_cmos":"Будь ласка, введіть свій CMOS запис.","polyadicExercise2":"від початкового формату:","newExponent":"Новий експонента","systemInBase":"Система до основи","basis":"База","minterms":"Minterme","maxterms":"Maxterme","contact":"Контакти","impressumText":"Відбиток ви знайдете під ним: ","and":" і","weThank":"Ми хотіли б подякувати наступним людям за допомогу у створенні цього веб-сайту:","Danksagung":"Подяка","thankProfessorTeich":"Матеріали на цій сторінці базуються на лекції GTI професора д-ра інж. Юргена Тайча з Університету Фрідріха-Александра (FAU). Ми дякуємо йому за експертизу та меценатство.","wintersemester":"Зимовий семестр","sommersemester":"Літній семестр","downloadSvg":"Експорт SVG","downloadPng":"Експорт Папуа-Нової Гвінеї","formula":"Формула","divByZero":"Ділення на 0 дає NaN.","falseFormat":"Неправильний формат"}'),fu=JSON.parse('{"complementExample":"Cálculo complementar","shiftZero":"Mantissa zero após o turno","doubleNegative":"Negativ","denormalized":"Desnormalização","fpExerciseIntro":"Praticar aritmética de ponto flutuante de acordo com IEEE-754 utilizando tarefas geradas automaticamente.","fpFormatSelectionSimple":"Seleccionar o número de bits para o expoente e para a mantissa.","fpFormatSelection":"Definir a largura do bit do número do ponto flutuante e depois seleccionar o número de bits para o expoente e a mantissa.","fpArithIntro":"Prática de aritmética de ponto flutuante de acordo com IEEE-754 ou um formato auto-definido com base nele.","fpConvIntro":"Praticar a conversão entre o sistema decimal e o formato do número de ponto flutuante de acordo com IEEE-754 ou um formato auto-definido com base nele utilizando exercícios gerados.","sequentialCircuit":"Exemplo de um mecanismo de comutação constituído por dois D-flipflops e vários multiplexadores.","polyadicDivisionDescription":"Os dígitos antes do ponto decimal são derivados dos dígitos dos restantes, lendo-os de baixo para cima.","polyadicMultiplicationDescription":"As casas decimais resultam dos dígitos dos restantes, lendo-os de cima para baixo.","homePageText":"Neste sítio web pode aprofundar os seus conhecimentos sobre temas seleccionados da palestra Fundamentos de Engenharia Informática (GTI) e do exercício associado.","startTraining":"Vamos","polyFreeIntro":"Pratique a aritmética poliádica com os seus próprios valores numéricos no seu sistema desejado.","polyConvGenIntro":"Praticar a conversão entre sistemas poliádicos utilizando exercícios gerados.","polyConvIntro":"Pratique a conversão entre sistemas poliádicos, que pode escolher livremente.","numVarInput":"Número de variáveis","conversionExercise":"Tarefas de conversão","impressum":"Impressum","copyright":"Cátedra de Informática 12, FAU. Todos os direitos reservados.","herausgeber":"Editora","disclaimerFooter":"Não é dada qualquer garantia quanto à exactidão do material fornecido neste website.","representedByHeader":"Representado por","contactPersonHeader":"Contacto","representedBy":"A cadeira de Informática 12 é uma instituição de direito público no âmbito da Friedrich-Alexander-UniversitÃ¤t Erlangen-Nürnberg (FAU). Em conformidade com os artigos 20 e 21 da BayHSchG, a FAU, como instituição estatal e organismo autónomo de direito público, é representada externamente pelo Presidente.","haftungsauschlussHeader":"Declaração de exoneração de responsabilidade","haftungsauschlussBody":"As respectivas instituições são responsáveis pelo conteúdo de outros sítios web. Toda a informação fornecida neste sítio web foi compilada e verificada com o melhor dos nossos conhecimentos e crenças. No entanto, não podemos garantir que a informação fornecida esteja sempre actualizada, correcta, completa ou disponível. Uma relação contratual com os utilizadores da oferta da Internet não se concretiza. Não somos responsáveis por quaisquer danos causados pela utilização deste website. Esta exclusão de responsabilidade não se aplica na medida em que as disposições do Â§839 do Código Civil Alemão (responsabilidade por violação do dever oficial) sejam relevantes. Não seremos responsáveis por quaisquer danos causados por malware ou pela instalação ou utilização de software ao chamar ou descarregar dados. Como prestador de serviços, somos responsáveis pelo nosso próprio conteúdo nestas páginas, de acordo com Â§ 7 para. 1 TMG (Lei de Telemedia alemã) ao abrigo das leis gerais. No entanto, de acordo com Â§ 8 a 10 TMG, não somos obrigados, como prestador de serviços, a monitorizar informações transmitidas ou armazenadas por terceiros ou a investigar circunstâncias que indiquem actividade ilegal. As obrigações de remover ou bloquear a utilização da informação de acordo com as leis gerais permanecem inalteradas. No entanto, a responsabilidade a este respeito só é possível a partir do momento em que se tem conhecimento de uma infracção concreta. Se tivermos conhecimento de violações legais correspondentes, removeremos imediatamente este conteúdo. O operador reserva-se expressamente o direito de alterar, complementar ou eliminar páginas web individuais, serviços web ou toda a oferta sem aviso prévio em separado, ou de cessar temporária ou permanentemente a publicação.","confirm":"Confirme","varNaming":"Nomear as variáveis","kvDiagram":"Diagrama CT","numeralSystem":"Sistemas de números","polyadic":"Poliádico","floatingPoint":"Números de pontos flutuantes","functionMin":"Minimização da função","exercises":"Exercícios","generateEx":"Gerar tarefa","generate":"Gerar","addition":"Adição","subtraction":"Subtracção","multiplication":"Multiplicação","division":"Divisão","ownSolution":"Solução própria","signBit":"Bit de sinal","correctSolution":"forma de resolução","solution":"Solução","exponentBits":"Exponente","fractionBits":"Mantisse","attRound":"Não se esqueça das rondas!","attSolve":"Por favor, tente resolver a tarefa de forma independente de antemão!","step":"Etapa","freeCalculation":"Cálculo gratuito","operationSelect":"Selecção cirúrgica","firstFloatingPoint":"Primeiro número de ponto flutuante","secondFloatingPoint":"Segundo número de ponto flutuante","operand":"Operand","decimal":"Número decimal","binary":"Número binário","inputNumber":"Introduzir número","fpformat":"Formato de Ponto Flutuante","check":"Verifique","values":"Valores","load":"Loja","arithmetic":"Aritmética","conversion":"Conversão","conversionExercise1":"Convert: ","conversionExercise2":"num número de ponto flutuante IEEE de um expoente de ","steps":"Passos","repeatMinuend":"Repetir minuend","doDivision":"Divisão Perform","doMultiplication":"Efectuar multiplicação","getDescription":"Imprimir","approach":"forma de resolução","gti":"Fundamentos da Engenharia Informática","disclaimer":"Aviso<br>:Este é um caminho de solução gerado automaticamente através do website GTI Online. Não podemos garantir a correcção e a solução sugerida é, portanto, <u>não-oficial</u>.<br>Fazemos um grande esforço para desenvolver uma ferramenta fiável e correcta para si. No entanto, o caminho da solução ou a solução em si pode conter erros. Isto também pode estar relacionado com certas versões do navegador. Por favor verifique a solução antes de a utilizar num exame, por exemplo.</br></br>","example":"Exemplo","composition":"Composição","negativeSummand":"Uma adição com um valor negativo é tratada como uma subtracção.","negativeSubtrahend":"Uma subtraenda negativa tem o mesmo efeito que uma soma positiva.","negativeMinuendSubtrahend":"Simplificação para o caso \\\\\\\\ ( - x - y {\\\\i1}rightarrow - (x + y) {\\\\i})","addWithZero":"Numa adição com 0, a outra soma não é alterada.","subWithZero":"A subtracção com 0 não altera o minuend","divWithZero":"Se houver uma divisão com 0 no numerador, o resultado é 0.","mulWithZero":"Quando se multiplica por 0, o resultado é sempre 0.","zeroDivision":"Uma divisão por 0 não é possível!","arithmeticFree":"Aritmética livre","conversionFree":"Conversão livre","value":"Valor","givenValues":"Valores dos números transmitidos","leftValue":"Número restante","rightValue":"Direito ao número","firstSummand":"1. Summand","secondSummand":"2. Summand","firstFactor":"Fator 1","secondFactor":"Fator 2","numerator":"Contador","denominator":"Denominador","minuend":"Minuend","subtrahend":"Subtrahend","sign":"Assine","exponent":"Exponente","adjustExponents":"Os expoentes de ambos os números devem ser ajustados.","addExponents":"Os expoentes de ambos os números devem ser somados.","subtExponents":"Os expoentes de ambos os números devem ser subtraídos.","diffExponent":"Expoente da diferença","smallerExponent":"O expoente menor é sempre subtraído do expoente maior.","resDiffExponent":"Portanto, a diferença é","newExponentDivision":"O novo expoente é dado como \\\\( E_{\'{novo}\'} = E_1 - E_2 + BIAS = {E1} - {E2} + {Bias} = {Resultado} \\\\)","newExponentMultiplication":"O novo expoente é dado como \\\\( E_{\'{novo}\'} = E_1 + E_2 - BIAS = {E1} + {E2} - {Bias} = {Resultado}, ({ExpBits})})","considerExponent":"Nota expoente","fpExerciseText":"Deixar os números de ponto flutuante \\\\( fp_1 \\\\) e fp_2 \\\\) serem dados em formato de ponto flutuante de 16 bits. Calcular a {op1} {op2} fp_1 {op2} fp_2 } sem deixar a representação binária e dar o resultado novamente como um número de ponto flutuante:","mantissa":"Mantisse","solutionIsNan":"A mantissa não tem de ser calculada porque o resultado é certamente NaN.","solutionIsInf":"A mantissa não tem de ser calculada porque o resultado é certamente infinito.","solutionIsZero":"A mantissa não tem de ser calculada porque o resultado é certamente 0.","mulMantissa":"As mantissas de ambos os números devem ser multiplicadas.","addMantissa":"As mantissas de ambos os números devem ser somadas.","divMantissa":"As mantissas de ambos os números devem ser divididas.","newMantissa":"Nova mantissa","zeroMantissa":"Mantissas são idênticas (\\"rightarrow\\") nova mantissa é 0-mantissa","newMantissaIs":"Por isso calculamos","newMantissaSignBit":"Por causa do complemento, calculamos com um bit de sinal:","equalMantissa":"As mantissas são idênticas, o expoente de direito é aumentado em 1; a mantissa permanece a mesma","equalMantissaDiv":"As duas mantissas são iguais, pelo que não é realizada nenhuma divisão binária. A mantissa é {Mantissa}.","adjustSmallerMantissa":"Ajustar a mantissa","shiftMantissa":"Mudar a mantissa","mantissaFloat":"Mantissa na bóia","mantissaNormalize":"Para que a mantissa comece com um 1, precisamos de normalizar a mantissa, aplicando o turno de {shift}. Precisamos também de aplicar esta mudança ao expoente, resultando no novo expoente {expoente}.","mantissaNormalizeDenorm":"O resultado não pode ser representado na representação normalizada com o deslocamento {deslocamento}, por isso usamos a representação desnormalizada com o expoente {expoente}.","mantissaDenormalize":"Uma vez que recebemos um expoente negativo após a aplicação do turno, temos de utilizar a representação desnormalizada para exibir o resultado. Para tal, fixamos o expoente completamente em 0 e deslocamos a nossa mantissa incluindo o expoente principal pela quantidade do expoente. Assume-se que a mantissa é um zero inicial.","mantissa1float":"Finalmente, removemos o dígito principal da mantissa para obter os pedaços de mantissa da representação IEEE-754. Os pedaços de mantissa são, portanto:","mantissaComplement":"A mantissa é negativa. Portanto, temos de formar o complemento e definir o bit do sinal.","subtTwosComplement":"A subtracção corresponde à adição com o complemento dos dois","mantissaTwosComplement":"Formação do complemento de dois a partir de mantissa","switchBits":"Bocados invertidos","add1":"1 adieren","normalize":"Normalizar","shiftExpMant":"O factor de mudança do expoente deve ser aplicado às mantissas.","shift":"Shift","considerRepresentation":"Representação de notas","consider1comma":"A mantissa começa sempre com um 1 antes do ponto decimal na representação padrão (e um 0 se desnormalizada).","ternary":"Número do ternário","quaternary":"Número do Quaternário","quinary":"Número Quintal","senary":"Número hexal","septenary":"Sistema Heptal","octal":"Número de octal","novenary":"Número Nonal","hexadecimal":"Número hexadecimal","hex":"Hexadecimal","input":"Entrada","number":"Número","representation":"Reprodução no formato de saída","firstFormat":"Formato de saída","secondFormat":"Formato alvo","doConversion":"Efectuar conversão:","modus":"Modus","to":"para","TenToPower":"Ao converter-se do sistema decimal para outro sistema polídico, o algoritmo de divisão é aplicado antes do ponto decimal e o algoritmo de multiplicação após o ponto decimal.","PowerToTen":"A conversão de qualquer sistema para o sistema decimal é feita através da soma dos dígitos exponenciados.","PowerToPower":"A conversão de um número de um sistema de números em outro sistema de números realiza-se em duas etapas. Primeiro, o número do sistema original é transferido para o sistema decimal, somando-o. Depois, este número decimal é convertido no sistema de destino por divisão sucessiva dos dígitos antes do ponto decimal e multiplicação sucessiva dos dígitos após o ponto decimal.","noValuesBeforeComma":"Sem valores antes da vírgula decimal. O algoritmo de divisão pode ser omitido","noValuesAfterComma":"Sem valores após a vírgula decimal. O algoritmo de multiplicação pode ser omitido","firstToTen":"1. somando os dígitos exponenciados","secondToPower":"2. conversão por meio de divisão e algoritmo de multiplicação","shortcutBinToHex":"Ao converter de binário para hexadecimal, os valores podem ser lidos directamente.","shortcutHexToBin":"Ao converter de hexadecimais para binários, os valores podem ser lidos directamente.","divisionAlgorithm":"Parte inteira (algoritmo de divisão)","multiplicationAlgorithm":"Lugares decimais (algoritmo de multiplicação)","summation":"Somar","factor":"Factor","quotient":"Quociente","remainder":"Descanso","newBasis":"Base_{\'{novo}\'}","calcStep":"Etapa de cálculo","summands":"Summands","polyadicExercise1":"Converta o","polyadicExercise3":"num ","exerciseArchive":"Arquivo de tarefas","randomExercise":"Tarefa aleatória","doCalculation":"Calcular","colorCoding":"Codificação por cores","mathDistribution":"Distribuierung","easy":"simplesmente","difficultyMiddle":"médio","difficultyHard":"pesado","sheet":"Folha","goal":"Destino","difficultyUC":"Dificuldade","bf_infotext_or_interact_with_kv":"Ou interagir directamente com o diagrama KV","bf_infotext_kv_must_not_be_empty":"O diagrama KV deve conter uns e zeros","bf_infotest_click_on_hidden_areas_to_make_visible":"Clique sobre as áreas ocultas para as revelar","bf_normal_forms":"Formulários normais","bf_disjunctiveNormalForm":"Forma disjuntiva normal","bf_conjunctiveNormalForm":"Forma Conjuntiva Normal","bf_disjunctiveMinimalForm":"Forma mínima disjuntiva","bf_conjunctiveMinimalForm":"Forma Conjuntiva mínima","bf_quineMCCluskeyClasses":"Aulas de Quine McCluskey","bf_primeTerms":"Primterme","bf_primeImplicants":"Primimplikanten","bf_primeImplicates":"Primimplikate","bf_primeCoverTable":"Tabela de sobreposição","bf_petrickExpression":"Expressão Petrick","bf_minimalForms":"Minimalformen","bf_tableWithCyclicRest":"Tabela do resto cíclico","bf_einstelle":"Ponto de entrada","bf_nullstelle":"Zero","bf_einstellen":"Lugares de emprego","bf_nullstellen":"Zeros","bf_goal_determine_DNF":"Determinar DNF","bf_goal_determine_KNF":"Determinar KNF","bf_goal_determine_prime_implicants":"Determinar os principais implantes","bf_goal_determine_prime_implicates":"Determinar o prime implica","bf_covertable_step_description_initial":"<h4>Passo inicial:</h4>Introduzir todos os termos base ({ifMinTermsSetElseNull}) em colunas e todos os termos principais (PI) em filas na tabela. Se um termo principal cobrir um {ifMinTermsEinstelleElseNullstelle}, marcar essa célula com um X. O custo c é a soma de todos os termos base ({ifMinTermsEinstellenElseNullstelle}). O custo c de um termo primo é o número dos seus literais. Quanto maior for o número, mais caro é implementá-lo no hardware. <br>Dica:<br>Uma primimplicaNT cobre um dígito ON exactamente quando todos os literais do primimplicativo também ocorrem da mesma forma no termo base</br>.</br>","bf_covertable_step_description_core_found":"<h4>Core found:</h4>O único termo principal que cobre o {ifMinTermsElseNull} {columnName} é o termo {rowName}. Por isso, este termo primordial deve aparecer absolutamente na nossa função de comutação! Marcar a fila como núcleo e riscar a coluna.","bf_covertable_step_description_cross_column_bc_covered":"<h4>Coluna já coberta:</h4>O {ifMinTermsSetElseNullSets} {columnName} já está coberto pelo termo principal {rowName}. Riscar a coluna.","bf_covertable_step_description_cross_row_bc_covered":"<h4>Fila já totalmente coberta:</h4>Todos os X da fila {rowName} já estão cobertos. Riscar a fila.","bf_covertable_step_description_row_domination":"Dominância da linha<h4>:</h4>A linha {dominatorName} domina a linha {dominatedName}, ou seja, {dominatorName} tem marcadores em todo o lado onde a linha {dominatorName} também tem marcadores (e talvez até mais). =&gt; Eliminar a linha dominada {dominatedName}. <br>Note-se que o domínio da linha só é aplicável porque a linha {dominatorName} custa menos ou o mesmo que {dominatorName}; ou porque não há outra linha que cubra os dígitos adicionais de {dominatorName} e custa menos que {dominatorName} - {dominatorName}.</br>","bf_covertable_step_description_column_domination":"Dominância da coluna<h4>:</h4>A coluna {dominatorName} domina a coluna {dominatedName}, ou seja, {dominatorName} tem marcadores em todo o lado onde a coluna {dominatorName} também tem marcadores (e talvez até mais). =&gt; Eliminar a coluna dominante {dominatorName} Em<br>contraste com a</br>dominância<br>em linha</br>, a<br>dominância em coluna não precisa de ter em conta os custos (/â-½ï¼¼)</br>.","bf_covertable_step_description_cyclic_rest":"<h4>Restante cíclico:</h4>Nenhuma regra da tabela de sobreposição é aplicável. Isto é referido como um \\"remanescente cíclico\\".<br>A fim de poder determinar uma forma mínima da função de comutação, é possível listar a expressão Petrick, em que apenas são introduzidas linhas e colunas que ainda não tenham sido riscadas.</br>","bf_infoblob_random_exercise_selection":"A dificuldade seleccionada determina quantos termos de um tipo (por exemplo, minterms, principais implantes) a função de comutação deve conter.","bf_infoblob_petrick_statement":"O algoritmo consiste em duas fases:<ol><li>Reorganizar os termos de modo a que o máximo possível seja absorvido.</li><li>Multiplicar os termos.</li></ol>","bf_distributionUC":"Distribuição","bf_idempotenceUC":"Idempotenz","bf_absorptionUC":"Absorção","bf_sortingUC":"Ordenação","bf_infoblob_functionMin":"Praticar os diferentes procedimentos para a minimização da função","bf_disjunctiveNormalForm_explanation":"A forma disjuntiva normal é uma disjunção (veroderung) de todos os minterms (1s) de uma função. Cada termo mineiro corresponde exactamente a um 1 na função; todos os literais devem ser negados ou não negados na função.","bf_conjunctiveNormalForm_explanation":"A forma conjuntiva normal é uma conjunção de todos os termos (0s) de uma função. Os 0s não são seleccionados em maxterms (como os 1s em minterms), mas excluídos. Cada maxterm corresponde exactamente a um 0 na função; todos os literais devem ser negados ou não negados na função.","bf_quineMCCluskeyClasses_explanation":"O método Quine/McCluskey é um método de minimização com o qual os principais termos de uma função podem ser determinados.","bf_infoblob_quineMCCluskeyClasses_colorCoding":"Os termos reduzidos são normalmente marcados por strikethrough no procedimento Quine/McCluskey. Quando a codificação por cores está activa, são em vez disso cinzento claro. ","bf_infoblob_quineMCCluskeyClasses_01":"Normalmente, escrevemos os min- ou maxterms nas aulas individuais. Alternativamente, também podemos trabalhar com 0s (para literais negados) e 1s (para literais não negados), em que a posição destes determina qual é literal.","bf_primeTerms_explanation":"Termos com um número mínimo de literais, cobrindo apenas um ou zeros. ","bf_bf_primeImplicants_explanation":"PrimimplicaNts são primatas que cobrem apenas UMA posição (com recorte). ","bf_primeImplicates_explanation":"Prime implícitos são termos primos que cobrem apenas zeros (com vagas). ","bf_disjunctiveMinimalForm_explanation":"Disjunção dos literais ligados por conjunção. Isto não pode ser mais simplificado (sem violar este formulário) (DNF simplificado).","bf_conjunctiveMinimalForm_explanation":"Conjunção de literais ligados por disjunção. Isto não pode ser mais simplificado (sem violar este formulário) (KNF simplificada).","cmos_infoblob_description":"CMOS é uma composição de uma rede complementar de comutação NMOS (rede pull-down, como ligada à terra) e rede de comutação PMOS (rede pull-up, como ligada à tensão de alimentação). Como resultado, é consumida menos energia no estado de comutação fixa, uma vez que o PDN e o PUN são complementares e, portanto, só conduzem simultaneamente por um curto período de tempo durante a comutação. No entanto, é necessária mais área no chip.","cmos_infoblob_input_description":"Nota: Para OU portões \'+\' pode ser usado, para E portões \'*\' e para negação \'~\'. As variáveis podem ter qualquer nome (Atenção: a entrada \'ab\' é interpretada como uma variável e não como um composto de \'a\' e \'b\').","enter_cmos":"Por favor, introduza a sua entrada CMOS.","polyadicExercise2":"a partir do formato inicial:","newExponent":"Novo expoente","systemInBase":"Sistema para a base","basis":"Base","minterms":"Minterme","maxterms":"Maxterme","contact":"Contacto","impressumText":"Encontrará a impressão em baixo: ","and":" e","weThank":"Gostaríamos de agradecer às seguintes pessoas pela sua ajuda na criação deste website:","Danksagung":"Agradecimentos","thankProfessorTeich":"Os materiais desta página baseiam-se na palestra GTI do Professor Dr.-Ing. Jürgen Teich of the Friedrich-Alexander-UniversitÃ¤t (FAU). Agradecemos-lhe a sua perícia e o seu patrocínio.","wintersemester":"Wintersemestre","sommersemester":"Semestre de Verão","downloadSvg":"Exportar SVG","downloadPng":"Exportação PNG","formula":"Fórmula","divByZero":"A divisão por 0 dá NaN.","falseFormat":"Formato errado"}');const gu=(0,ru.hU)({locale:"de",fallbackLocale:"de",messages:{de:lu,en:cu,fr:uu,es:hu,ch:du,ja:mu,pt:fu,uk:pu}});l.Yv.add(c.y_8),l.Yv.add(c.O26),l.Yv.add(c.cOs),l.Yv.add(c.QnR),l.Yv.add(c.iW_),l.Yv.add(c.tdl),l.Yv.add(c.ckx),l.Yv.add(c.jPR);const bu=(0,s.aE)({base:"/",history:(0,s.Bt)(""),routes:ou});u.A.registerLanguage("tex",h.A);const vu=(0,n.Ef)(Z);vu.use(bu);const wu={name:"_blank",specs:["fullscreen=yes","titlebar=yes","scrollbars=yes"]};vu.component("font-awesome-icon",r.gc),vu.use(wu),vu.use(gu),vu.use(o()),vu.use(d.A),vu.mount("#app")},4792:function(e,t,i){e.exports=i.p+"img/germanFlag.b0823d1a.png"}},t={};function i(n){var s=t[n];if(void 0!==s)return s.exports;var a=t[n]={exports:{}};return e[n].call(a.exports,a,a.exports,i),a.exports}i.m=e,function(){var e=[];i.O=function(t,n,s,a){if(!n){var o=1/0;for(u=0;u<e.length;u++){n=e[u][0],s=e[u][1],a=e[u][2];for(var r=!0,l=0;l<n.length;l++)(!1&a||o>=a)&&Object.keys(i.O).every((function(e){return i.O[e](n[l])}))?n.splice(l--,1):(r=!1,a<o&&(o=a));if(r){e.splice(u--,1);var c=s();void 0!==c&&(t=c)}}return t}a=a||0;for(var u=e.length;u>0&&e[u-1][2]>a;u--)e[u]=e[u-1];e[u]=[n,s,a]}}(),function(){i.n=function(e){var t=e&&e.__esModule?function(){return e["default"]}:function(){return e};return i.d(t,{a:t}),t}}(),function(){i.d=function(e,t){for(var n in t)i.o(t,n)&&!i.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})}}(),function(){i.g=function(){if("object"===typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"===typeof window)return window}}()}(),function(){i.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)}}(),function(){i.r=function(e){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}}(),function(){i.p=""}(),function(){var e={524:0};i.O.j=function(t){return 0===e[t]};var t=function(t,n){var s,a,o=n[0],r=n[1],l=n[2],c=0;if(o.some((function(t){return 0!==e[t]}))){for(s in r)i.o(r,s)&&(i.m[s]=r[s]);if(l)var u=l(i)}for(t&&t(n);c<o.length;c++)a=o[c],i.o(e,a)&&e[a]&&e[a][0](),e[a]=0;return i.O(u)},n=self["webpackChunkgtionline"]=self["webpackChunkgtionline"]||[];n.forEach(t.bind(null,0)),n.push=t.bind(null,n.push.bind(n))}();var n=i.O(void 0,[504],(function(){return i(9275)}));n=i.O(n)})();
//# sourceMappingURL=app.2b23f822.js.map